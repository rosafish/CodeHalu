{
    "189": {
        "id": 78,
        "task_id": 189,
        "test_case_id": 78,
        "question": "Salem gave you $n$ sticks with integer positive lengths $a_1, a_2, \\ldots, a_n$.\n\nFor every stick, you can change its length to any other positive integer length (that is, either shrink or stretch it). The cost of changing the stick's length from $a$ to $b$ is $|a - b|$, where $|x|$ means the absolute value of $x$.\n\nA stick length $a_i$ is called almost good for some integer $t$ if $|a_i - t| \\le 1$.\n\nSalem asks you to change the lengths of some sticks (possibly all or none), such that all sticks' lengths are almost good for some positive integer $t$ and the total cost of changing is minimum possible. The value of $t$ is not fixed in advance and you can choose it as any positive integer. \n\nAs an answer, print the value of $t$ and the minimum cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 1000$)\u00a0\u2014 the number of sticks.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 100$)\u00a0\u2014 the lengths of the sticks.\n\n\n-----Output-----\n\nPrint the value of $t$ and the minimum possible cost. If there are multiple optimal choices for $t$, print any of them.\n\n\n-----Examples-----\nInput\n3\n10 1 4\n\nOutput\n3 7\n\nInput\n5\n1 1 2 2 3\n\nOutput\n2 0\n\n\n\n-----Note-----\n\nIn the first example, we can change $1$ into $2$ and $10$ into $4$ with cost $|1 - 2| + |10 - 4| = 1 + 6 = 7$ and the resulting lengths $[2, 4, 4]$ are almost good for $t = 3$.\n\nIn the second example, the sticks lengths are already almost good for $t = 2$, so we don't have to do anything.",
        "solutions": "[\"n = int(input())\\na = list(map(int,input().split()))\\nt = 0\\nmn = 1000000000\\nfor i in range(1,100):\\n    cur = 0\\n    for j in range(n):\\n        cur += max(0,abs(i-a[j])-1)\\n    if cur < mn:\\n        mn = cur\\n        t = i\\nprint(t,mn)\\n\", \"n=int(input())\\na=[*map(int,input().split())]\\n\\nmcost = 10**8\\nans = 0\\n\\nfor i in range(1,101):\\n    tcost = 0\\n    for j in range(n):\\n        if a[j] > i:\\n            d = abs(a[j] - (i + 1))\\n        elif a[j] < i:\\n            d = abs(a[j] - (i - 1))\\n        else:\\n            d = 0\\n        tcost += d\\n    if tcost < mcost:\\n        mcost, ans = tcost , i\\n\\nprint(ans, mcost)\", \"n = int(input())\\ns = list(map(int,input().split()))\\na,b = -1,188888\\nfor t in range(1,101):\\n    mi = 0\\n    for i in range(n):\\n        mi += min(abs(s[i]-t),abs(s[i]-t-1),abs(s[i]-t+1))\\n    if b>mi:\\n        a,b = t,mi\\nprint(a,b)\", \"import math\\n\\nn = int(input())\\nA = [int(i) for i in input().split()]\\nA.sort()\\n\\nans = 10**18\\nval = 0\\nfor mid in range(1,100):\\n    cost = 0\\n    for i in range(n):\\n        cost += min(abs(A[i] - mid), abs(A[i]-mid+1), abs(A[i]-mid-1))\\n    if cost<ans:\\n        ans = cost\\n        val = mid\\n\\nprint(val, ans)\\n\", \"def read_nums():\\n    return [int(x) for x in input().split()]\\n\\n\\ndef compute_min_cost(t, nums):\\n    res = 0\\n    for num in nums:\\n        if abs(t - num) <= 1:\\n            continue\\n        res += abs(num - t) - 1\\n    return res\\n\\n\\ndef main():\\n    _ = read_nums()\\n\\n    costs = []\\n    nums = read_nums()\\n    for t in range(1, 101):\\n        min_cost = compute_min_cost(t, nums)\\n        costs.append((t, min_cost))\\n\\n    t, cost = sorted(costs, key=lambda x: x[1])[0]\\n    print(t, cost)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\\n\\nsys.setrecursionlimit(10**7)\\ninf = 10**20\\neps = 1.0 / 10**10\\nmod = 10**9+7\\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\\n\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef I(): return int(sys.stdin.readline())\\ndef F(): return float(sys.stdin.readline())\\ndef S(): return input()\\ndef pf(s): return print(s, flush=True)\\n\\n\\ndef main():\\n    n = I()\\n    a = LI()\\n    mm = inf\\n    mi = 0\\n    for i in range(1,100):\\n        t = 0\\n        for c in a:\\n            if c < i:\\n                t += i-1-c\\n            elif c > i:\\n                t += c - 1 - i\\n        if mm > t:\\n            mi = i\\n            mm = t\\n\\n    return '{} {}'.format(mi, mm)\\n\\n\\n\\nprint(main())\\n\\n\", \"n=int(input())\\nl=list(map(int,input().split()))\\nmincost=100000\\nans=0\\nfor t in range(1,101):\\n    curcost=0\\n    for i in l:\\n        if i==t:\\n            continue\\n        else:\\n            curcost+=abs(t-i)-1\\n    if curcost<mincost:\\n        mincost=curcost\\n        ans=t\\nprint(ans,mincost)\", \"n = int(input())\\n\\narr = list(map(int, input().split()))\\narr.sort()\\n\\na = []\\nfor t in range(1, 101):\\n    tot = 0\\n    for item in arr:\\n        if (abs(item - t) >= 1):\\n            tot += abs(item - t) - 1\\n    \\n    a.append((tot, t))\\n\\na.sort()\\n\\nprint(a[0][1], a[0][0])\\n\", \"n = int(input())\\narr = [int(x) for x in input().split()]\\nt = []\\nfor i in range(101):\\n    s = 0\\n    for j in arr:\\n        s += max(0, abs(j - i) - 1)\\n    t.append(s)\\np = t[1:].index(min(t)) + 1\\nprint(p, min(t))\", \"n=int(input())\\nans=10**18\\nval=-1\\narr=list(map(int,input().split()))\\nfor i in range(1,102):\\n    valx=0\\n    for j in arr:\\n        if(abs(j-i)>1):\\n            valx+=abs(j-i)-1\\n    if(valx<ans):\\n        ans=valx\\n        val=i\\nprint(val,ans)\", \"n = int(input())\\na = list(map(int, input().split()))\\nans = 10 ** 8\\nansi = 0\\nfor i in range(1, 101):\\n\\ttmp = sum(min(abs(i - t - 1), abs(i - t + 1), abs(i - t)) for t in a)\\n\\tif tmp < ans:\\n\\t\\tans = tmp\\n\\t\\tansi = i\\nprint(ansi, ans)\", \"n = int(input())\\nl = [*map(int, input().split())]\\ndef f(a):\\n    return [sum(min(\\n        [abs(e - a), abs(e - (a - 1)), abs(e - (a + 1))]) for e in l), a]\\nres = [float('inf'), float('inf')]\\nfor a in range(1, 101):\\n    res = min(res, f(a))\\nprint(res[1], res[0])\", \"N = int(input())\\nnumber_list = list(map(int, input().split(' ')))\\nret = [0, 9999999]\\nfor n in range(1, 101):\\n    temp = 0\\n    for number in number_list:\\n        temp += max(0, abs(number - n) - 1)\\n    if ret[1] > temp:\\n        ret[0] = n\\n        ret[1] = temp\\n\\nprint(ret[0], ret[1])\\n\", \"n = int(input())\\na = [int(t) for t in input().split(' ')]\\n\\nmincost = 1000 * 100 + 1\\nbest_t = None\\nfor t in range(1, 101):\\n    cost = 0\\n    for x in a:\\n        cost += max(0, abs(x - t) - 1)\\n    if cost < mincost:\\n        mincost = cost\\n        best_t = t\\n\\nprint(best_t, mincost)\", \"n = int(input())\\na = [int(v) for v in input().split()]\\na.sort()\\n\\ndef cost1(v, t):\\n    if v < t - 1:\\n        return t - 1 - v\\n    elif v > t + 1:\\n        return v - (t + 1)\\n    else:\\n        return 0\\n\\nbest_t = None\\nbest_cost = 9999999999999\\n\\nfor t in range(1, 101):\\n    cost = sum(cost1(v, t) for v in a)\\n    if cost < best_cost:\\n        best_cost = cost\\n        best_t = t\\n\\nprint(best_t, best_cost)\\n\", \"n=int(input())\\n\\nl=list(map(int,input().split()))\\n\\nmaxx=10000000000\\ncur=0\\nfor i in range(1,101):\\n\\tnow=0\\n\\tfor j in range(n):\\n\\t\\tif l[j]<i:\\n\\t\\t\\tnow+=i-l[j]-1\\n\\t\\telif l[j]>i:\\n\\t\\t\\tnow+=l[j]-i-1\\n\\n\\tif now<maxx:\\n\\t\\tmaxx=now\\n\\t\\tcur=i\\n\\nprint(cur, maxx)\", \"from sys import stdin\\nn=int(stdin.readline().strip())\\n#n,m=map(int,stdin.readline().strip().split())\\ns=list(map(int,stdin.readline().strip().split()))\\ns.sort()\\nans=10**20\\nt1=-1\\nfor t in range(1,101):\\n    aux1=0\\n    for j in range(n):\\n        aux=102\\n        aux=min(aux,abs(1+t-s[j]))\\n        aux=min(aux,abs(t-1-s[j]))\\n        aux=min(aux,abs(t-s[j]))\\n        aux1+=aux\\n    if aux1<ans:\\n        ans=aux1\\n        t1=t\\nprint(t1,ans)\\n        \\n        \\n\", \"import math\\nn = int(input())\\nar = [*map(int, input().split(' '))]\\nmint,mincost = int(1e9),int(1e9)\\nfor i in range(1,105):\\n\\tcost = sum([min(abs(x-i), abs(x-i-1), abs(x-i+1)) for x in ar])\\n\\tif cost < mincost:\\n\\t\\tmincost = cost\\n\\t\\tmint = i\\nprint(int(mint), int(mincost))\", \"n = int(input())\\nl = list(map(int, input().split()))\\nans = [0] * 101\\nfor i in range(1, 101):\\n    for k in range(n):\\n        ans[i] += max(abs(l[k] - i) - 1, 0)\\ncnt = [100000000, 100000000]\\nfor i in range(1, 101):\\n    if cnt[1] > ans[i]:\\n        cnt[0] = i\\n        cnt[1] = ans[i]\\nprint(cnt[0], cnt[1])\", \"n=int(input())\\nar=list(map(int,input().split()))\\ndef f(i):\\n    ans=0\\n    for e in ar:\\n        if(e==i):continue\\n        else:ans+=abs(e-i)-1\\n    return ans\\na=float('inf')\\nb=0\\nfor x in range(1,1001):\\n    if(f(x)<a):\\n        a=f(x)\\n        b=x\\nprint(b,a)\", \"n = int(input())\\na = [int(i) for i in input().split()]\\nmi = 10 ** 8\\nx = -1\\nfor i in range(1, 111):\\n    s = 0\\n    for j in range(n):\\n        if not i - 1 <= a[j] <= i + 1:\\n            if a[j] < i - 1:\\n                z = i - 1 - a[j]\\n            else:\\n                z = a[j] - i - 1\\n            s += z\\n    if s < mi:\\n        mi = s\\n        x = i\\nprint(x, mi)\\n\"]",
        "difficulty": "interview",
        "input": "4\n1 1 1 10\n",
        "output": "2 7\n",
        "halu_type": "Logic Deviation",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/1105/A",
        "input_output": "{\"inputs\": [\"4\\n1 1 1 10\\n\"], \"outputs\": [\"2 7\\n\"]}",
        "generated_code": "n = int(input())\nsticks = [int(x) for x in input().split()]\n\n# Initialize the minimum cost and the value of t\nmin_cost = 0\nt = 0\n\n# Loop through each stick and check if it is almost good for some integer t\nfor i in range(n):\n    for j in range(1, 100):\n        if abs(sticks[i] - j) <= 1:\n            # If the stick is almost good for some integer t, update the minimum cost and the value of t\n            if min_cost == 0 or min_cost > abs(sticks[i] - j):\n                min_cost = abs(sticks[i] - j)\n                t = j\n            break\n\n# Print the value of t and the minimum cost\nprint(t, min_cost)",
        "inout": "{\"inputs\": [\"5\\n1 1 2 2 3\\n\"], \"outputs\": [\"2 0\\n\"]}"
    },
    "199": {
        "id": 154,
        "task_id": 199,
        "test_case_id": 76,
        "question": "The Fair Nut likes kvass very much. On his birthday parents presented him $n$ kegs of kvass. There are $v_i$ liters of kvass in the $i$-th keg. Each keg has a lever. You can pour your glass by exactly $1$ liter pulling this lever. The Fair Nut likes this drink very much, so he wants to pour his glass by $s$ liters of kvass. But he wants to do it, so kvass level in the least keg is as much as possible.\n\nHelp him find out how much kvass can be in the least keg or define it's not possible to pour his glass by $s$ liters of kvass.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $s$ ($1 \\le n \\le 10^3$, $1 \\le s \\le 10^{12}$)\u00a0\u2014 the number of kegs and glass volume.\n\nThe second line contains $n$ integers $v_1, v_2, \\ldots, v_n$ ($1 \\le v_i \\le 10^9$)\u00a0\u2014 the volume of $i$-th keg.\n\n\n-----Output-----\n\nIf the Fair Nut cannot pour his glass by $s$ liters of kvass, print $-1$. Otherwise, print a single integer\u00a0\u2014 how much kvass in the least keg can be.\n\n\n-----Examples-----\nInput\n3 3\n4 3 5\n\nOutput\n3\n\nInput\n3 4\n5 3 4\n\nOutput\n2\n\nInput\n3 7\n1 2 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example, the answer is $3$, the Fair Nut can take $1$ liter from the first keg and $2$ liters from the third keg. There are $3$ liters of kvass in each keg.\n\nIn the second example, the answer is $2$, the Fair Nut can take $3$ liters from the first keg and $1$ liter from the second keg.\n\nIn the third example, the Fair Nut can't pour his cup by $7$ liters, so the answer is $-1$.",
        "solutions": "[\"def doit():\\n    xx = input().split()\\n    n = int(xx[0])\\n    s = int(xx[1])\\n    v = [int(k) for k in input().split()]\\n\\n    S = sum(v)\\n    newS = S - s\\n    if newS < 0:\\n        return -1\\n    return min(newS//n, min(v))\\n        \\nprint(doit())\\n\", \"n, s = list(map(int, input().split()))\\n\\nv = list(map(int, input().split()))\\n\\nif sum(v) < s:\\n    print(-1)\\n    return\\n\\nmv = min(v)\\n\\nfor i in range(n):\\n    s -= v[i] - mv\\n\\nif s < 1:\\n    print(mv)\\n    return\\n\\nans = mv - s // n\\nif s % n != 0:\\n    ans -= 1\\n\\nprint(ans)\\n\\n\\n\\n\", \"from sys import stdin, stdout\\nfrom math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial\\n\\n\\nn, s = map(int, stdin.readline().split())\\nvalues = list(map(int, stdin.readline().split()))\\n\\nl, r = -1, min(values) + 1\\nwhile r - l > 1:\\n    m = (l + r) >> 1\\n    \\n    cnt = 0\\n    for v in values:\\n        cnt += v - m\\n    \\n    if cnt >= s:\\n        l = m\\n    else:\\n        r = m\\n\\nif l == -1:\\n    stdout.write('-1\\\\n')\\nelse:\\n    stdout.write(str(l) + '\\\\n')\", \"n, s = list(map(int, input().split()))\\n\\nallCups = list(map(int, input().split()))\\nsumK = sum(allCups)\\nminK = min(allCups)\\nif sumK < s:\\n    print(-1)\\n\\nelse:\\n    if sumK - (minK * n) >= s:\\n        print(minK)\\n    else:\\n        s = s - (sumK - (minK * n))\\n        #print(s)\\n        if s % n == 0:\\n            print(minK - (s // n))\\n        else:\\n            print(minK - (s // n) - 1)\\n\", \"n, s = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\nd = sum(a)\\nif d >= s:\\n    r = d - s\\n    ans = min(r // n, a[0])\\nelse:\\n    ans = -1\\n\\nprint(ans)\\n\", \"n, s = map(int, input().split())\\nnum = list(map(int, input().split()))\\nx = sum(num)\\nif x < s:\\n    print(-1)\\nelse:\\n    k = min(num)\\n    for i in range(n):\\n        s -= abs(num[i] - k)\\n        num[i] = k\\n    if s <= 0:\\n        print(k)\\n    else:\\n        q = s // n\\n        k -= q\\n        if s % n == 0:\\n            print(k)\\n        else:\\n            print(k - 1)\", \"from math import ceil\\n\\nn, s = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nif sum(A) < s:\\n    print(-1)\\nelse:\\n    x = min(A)\\n    y = 0\\n    for k in range(n):\\n        y += (A[k] - x)\\n    if y >= s:\\n        print(x)\\n    else:\\n        a = s - y\\n        print(x - ceil(a / n))\", \"n,s=map(int,input().split())\\na=list(map(int,input().split()))\\ny=min(a)*n\\nx=sum(a)\\nif x<s:\\n    print(-1)\\nelse:\\n    if s<=x-y:\\n        print(y//n)\\n    else:\\n       s=s-(x-y)\\n       print((y-s)//n)\", \"import math\\nn,s=map(int,input().split())\\nv=list(map(int,input().split()))\\nx=sum(v)\\nif s>x:\\n    print(-1)\\nelse:\\n    a=min(v)\\n    if s<x-n*a:\\n        print(a)\\n    else:\\n        b=x-n*a\\n        c=s-b\\n        print(a-math.ceil(c/n))\", \"n, s = list(map(int, input().split()))\\nv = list(map(int, input().split()))\\nsm = sum(v)\\nsm -= s\\nif sm < 0:\\n    print(-1)\\nelse:\\n    mn = min(v)\\n    r = min(mn, sm // n)\\n    print(r)\\n\", \"import math, sys, itertools\\n\\ndef mp():\\n    return list(map(int, input().split()))\\n\\ndef main():\\n    n, s = mp()\\n    a = mp()\\n    sm = sum(a)\\n    if sm < s:\\n        print(-1)\\n        return\\n    ans = (sum(a) - s) // n\\n    print(min(ans, min(a)))\\n        \\n\\ndeb = 0\\nif deb:\\n    file = open('input.txt', 'r')\\n    input = file.readline\\nelse:\\n    input = sys.stdin.readline\\n    \\nmain()\", \"n, s = list(map(int, input().split()))\\nv = [int(k) for k in input().split()]\\nv.sort(reverse=True)\\nfor i in range(n):\\n    s -= v[i] - v[-1]\\n    v[i] = v[-1]\\nif s <= 0:\\n    print(v[-1])\\nelse:\\n    if s > n * v[0]:\\n        print(-1)\\n    else:\\n        print(v[0] - (s + n - 1) // n)  \\n\", \"import math\\nn,s = list(map(int,input().split()))\\nv = input().split()\\nmini = math.inf\\nfor i in range(n):\\n    mini = min(int(v[i]),mini)\\ns += mini*n\\nfor i in range(n):\\n    s -= int(v[i])\\nif s < 0:\\n    print(mini)\\nelif s > mini*n:\\n    print(-1)\\nelif s%n == 0:\\n    print(mini-s//n)\\nelse:\\n    print(mini-s//n-1)\\n\", \"n, s = list(map(int, input().split()))\\nv = [int(x) for x in input().split()]\\nt = sum(v)\\nif sum(v) < s:\\n\\tprint(-1)\\n\\treturn\\nb = min(v)\\nkol = t - b * n\\ns -= kol\\nif s <= 0:\\n\\tprint(b)\\n\\treturn\\ntmp = (s + n - 1) // n\\nprint(b - tmp)\\n\", \"n, s = map(int, input().split())\\nl = [*map(int, input().split())]\\nsm = sum(l)\\nif sm < s:\\n    print(-1)\\n    return\\nm = min(l)\\ns -= sm - m * n\\nif s <= 0:\\n    print(m)\\nelse:\\n    print(m - (s + n - 1)//n)\", \"n, s = map(int, input().split())\\nk = list(map(int, input().split()))\\nsumk = sum(k)\\nmink = min(k)\\nif sumk < s:\\n    print(-1)\\n    return\\nif sumk-n*mink >= s:\\n    print(mink)\\nelse:\\n    s -= sumk-n*mink\\n    if s%n == 0:\\n        print(mink-s//n)\\n    else:\\n        print(mink-s//n-1)\", \"import math\\nn,q=list(map(int,input().split()))\\nh=list(map(int,input().split()))\\nt=0\\nfor i in range (n):\\n    t+=h[i]\\nif t<q:\\n    print(-1)\\n    return\\nlow=min(h)\\nfor i in range (n):\\n    q-=(h[i]-low)\\nif q<=0:\\n    print(low)\\n    return\\nlow-=math.ceil(q/n)\\nprint(low)\\n\", \"n,s = map(int,input().split())\\nl = list(map(int, input().split()))\\n\\nif sum(l) < s:\\n\\tprint(-1)\\n\\treturn\\nq = sum(l) - min(l) * n\\nif q>=s:\\n\\tprint(min(l))\\n\\treturn\\nprint(min(l)-(s-q+n-1)//n)\", \"n, S = [int(x) for x in input().split()]\\n\\nA = [int(x) for x in input().split()]\\n\\ndef ans():\\n  nonlocal S\\n  to_min = sum(A) - n*min(A)\\n  S -= to_min\\n  if S <= 0:\\n    return min(A)\\n  if n*min(A) < S: return -1\\n  return (n*min(A) - S) // n\\n\\nprint(ans())\\n\", \"n, s = list(map(int, input().split()))\\nu = list(map(int, input().split()))\\nmu = min(u)\\nsu = sum(u)\\nif su < s:\\n    print(-1)\\nelse:\\n    s -= (su - mu * n)\\n    if s <= 0:\\n        print(mu)\\n    else:\\n        k = s // n\\n        if s % n != 0:\\n            k += 1\\n        print(mu - k)\\n\", \"n, k = list(map(int, input().split(' ')))\\n\\na = list(map(int, input().split(' ')))\\n\\nminV = min(a)\\n\\ns = sum(a)\\n\\nif(k > s):\\n  print(-1)\\nelse:\\n  rest = s - minV * n\\n  if(rest >= k):\\n    print(minV)\\n  else:\\n    k -= rest\\n    \\n    sol = k // n\\n    if(k % n):\\n      sol += 1\\n\\n    print(minV - sol)\", \"def ifPoss(arr,v,h):\\n    tot = 0\\n    for i in arr:\\n        tot += (i-h)\\n    return tot>=v\\ndef prog():\\n    n,v = map(int,input().split())\\n    arr = [int(x) for x in input().split()]\\n    minLev = -1\\n    l,h = 0,min(arr)\\n    while(l<=h):\\n        m = int((l+h)/2)\\n        if(ifPoss(arr,v,m)):\\n            minLev = max(minLev,m)\\n            l = m+1\\n        else:\\n            h = m-1\\n    return minLev\\nprint(prog())\", \"#!/usr/bin/env python\\n# coding: utf-8\\n\\n# In[15]:\\n\\n\\nimport math\\nns=list(map(int, input().rstrip().split()))\\nn=ns[0]\\ns=ns[1]\\n\\ndata=list(map(int, input().rstrip().split()))\\n\\n\\n# In[16]:\\n\\n\\ndata.sort()\\n\\n\\n# In[17]:\\n\\n\\nextras=[i-data[0] for i in data]\\n\\n\\n# In[18]:\\n\\n\\ntotal=sum(data)\\nextratotal=sum(extras)\\n\\n\\n# In[ ]:\\n\\n\\n\\n\\n\\n# In[19]:\\n\\n\\nif s>total:\\n    print(-1)\\nelif extratotal>=s:\\n    print(data[0])    \\nelse:\\n    sub=math.ceil((s-extratotal)/n)\\n    print(data[0]-sub)\\n    \\n\\n\\n# In[ ]:\\n\\n\", \"import sys\\nfrom math import ceil\\n\\n\\ndef main():\\n    n, s = map(int, sys.stdin.readline().split())\\n    arr = list(map(int, sys.stdin.readline().split()))\\n    if s > sum(arr):\\n        print(-1, sep=' ', end='\\\\n', file=sys.stdout, flush=False)\\n    else:\\n        count = 0\\n        arr.sort(reverse=True)\\n        for i in range(n-1):\\n            if count == s:\\n                break\\n            if count+(arr[i]-arr[-1]) <= s:\\n                count += arr[i]-arr[-1]\\n                arr[i] = arr[-1]\\n            elif count+(arr[i]-arr[-1]) > s:\\n                count = s\\n                arr[i] -= (s-count)\\n        if count == s:\\n            print(arr[-1])\\n        else:\\n            factor = (s-count)/n\\n\\n            print(arr[-1]-ceil(factor), sep=' ', end='\\\\n', file=sys.stdout, flush=False)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]",
        "difficulty": "interview",
        "input": "2 1\n1 7\n",
        "output": "1\n",
        "halu_type": "Logic Deviation",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/1084/B",
        "input_output": "{\"inputs\": [\"2 1\\n1 7\\n\"], \"outputs\": [\"1\\n\"]}",
        "generated_code": "n, s = map(int, input().split())\nv = list(map(int, input().split()))\n\n# Calculate the total volume of kvass\ntotal_volume = sum(v)\n\n# Check if it is possible to pour the glass by s liters of kvass\nif total_volume < s:\n    print(-1)\n    exit()\n\n# Find the least keg with the most kvass\nleast_keg = 0\nmost_kvass = 0\nfor i in range(n):\n    if v[i] > most_kvass:\n        least_keg = i\n        most_kvass = v[i]\n\n# Calculate the amount of kvass that can be poured from the least keg\npour_amount = min(most_kvass, s - total_volume + least_keg)\n\nprint(pour_amount)",
        "inout": "{\"inputs\": [\"3 4\\n5 3 4\\n\"], \"outputs\": [\"2\\n\"]}"
    },
    "226": {
        "id": 1069,
        "task_id": 226,
        "test_case_id": 9,
        "question": "You may have heard of the pie rule before. It states that if two people wish to fairly share a slice of pie, one person should cut the slice in half, and the other person should choose who gets which slice. Alice and Bob have many slices of pie, and rather than cutting the slices in half, each individual slice will be eaten by just one person.\n\nThe way Alice and Bob decide who eats each slice is as follows. First, the order in which the pies are to be handed out is decided. There is a special token called the \"decider\" token, initially held by Bob. Until all the pie is handed out, whoever has the decider token will give the next slice of pie to one of the participants, and the decider token to the other participant. They continue until no slices of pie are left.\n\nAll of the slices are of excellent quality, so each participant obviously wants to maximize the total amount of pie they get to eat. Assuming both players make their decisions optimally, how much pie will each participant receive?\n\n\n-----Input-----\n\nInput will begin with an integer N (1 \u2264 N \u2264 50), the number of slices of pie. \n\nFollowing this is a line with N integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.\n\n\n-----Output-----\n\nPrint two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.\n\n\n-----Examples-----\nInput\n3\n141 592 653\n\nOutput\n653 733\n\nInput\n5\n10 21 10 21 10\n\nOutput\n31 41\n\n\n\n-----Note-----\n\nIn the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.",
        "solutions": "[\"n = int(input())\\na = list(map(int, input().split()))\\na = a[::-1]\\nd = 0\\nfor i in range(len(a)):\\n    d = max(0 + d, a[i] + (sum(a[:i]) - d))\\nprint(sum(a)-d, d)\\n\", \"n = int(input())\\nX = list(map(int, input().split()))\\n\\nali = [None]*(n+1)\\nbob = [None]*(n+1)\\n\\nali[n] = 0\\nbob[n] = 0\\n\\nfor i in range(n-1, -1, -1):\\n\\tbob[i] = max(bob[i+1], ali[i+1]+X[i])\\n\\tali[i] = sum(X[i:n]) - bob[i]\\n\\t\\n#print(ali)\\n#print(bob)\\n\\nprint(ali[0], bob[0], sep=' ')\\n\\t\\n\", \"N = int(input())\\nA = list(map(int, input().split()))\\n\\ns = [0]*(N+1)\\ndp = [0]*(N+1)\\nfor i in range(N-1, -1, -1):\\n\\tdp[i] = max(A[i] + s[i+1] - dp[i+1], dp[i+1])\\n\\ts[i] = s[i+1] + A[i]\\nprint(s[0] - dp[0], dp[0])\", \"n = int(input())\\nvs = list(map(int, input().split(' ')))\\n\\nrs = [0, 0]\\n\\nfor i in range(n-1, -1, -1):\\n    rs = [\\n        min(vs[i] + rs[0], rs[1]),\\n        max(vs[i] + rs[0], rs[1])\\n    ]\\n\\nprint(sum(vs) - rs[1], rs[1])\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\n\\n\\ndef max_revenue(i, a):\\n    if i == len(a)-1:\\n        return a[-1], 0\\n    before = max_revenue(i+1, a)\\n    take = a[i] + before[1], before[0]\\n    give = before[0], a[i] + before[1]\\n\\n    if take[0] > give[0]:\\n        return take\\n    else:\\n        return give\\n\\nr = max_revenue(0, a)\\nprint(r[1], r[0])\\n\", \"\\nimport sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nn=int(input())\\n\\npie=list(map(int,input().split()))\\n\\ndef dp(i):\\n    # best result for this player\\n    if i>=len(pie): return (0,0)\\n    t1,t2=dp(i+1)\\n    return (max(pie[i]+t2-t1,t1),t2+pie[i])\\n\\nt1,t2=dp(0)\\n\\nprint(t2-t1,t1)\", \"import math\\nfrom random import random\\n\\ndef getInt():\\n    return(int(input()))\\n\\ndef getInts():\\n    line = input().split()\\n    return [int(l) for l in line]\\n\\ndef getFloat():\\n    return(float(input()))\\n\\ndef getFloats():\\n    line = input().split()\\n    return [float(l) for l in line]\\n\\ndef getStrings():\\n    line = input().split()\\n    return(line)\\n\\n\\nN = getInt()\\nvalues = getInts()\\n\\nnConsidered = 0\\n#                nC, nO\\nbestForChooserSoFar = [0, 0]\\n\\nfor i in range(len(values)):\\n    v = values[len(values) - i - 1]\\n    qsIfTaken = [v + bestForChooserSoFar[1], bestForChooserSoFar[0]]\\n    qsIfGiven = [bestForChooserSoFar[0], v + bestForChooserSoFar[1]]\\n\\n    if(qsIfTaken[0] >= qsIfGiven[0]):\\n        bestForChooserSoFar = qsIfTaken\\n    else:\\n        bestForChooserSoFar = qsIfGiven\\n\\nprint(str(bestForChooserSoFar[1]) + ' ' + str(bestForChooserSoFar[0]))\", \"N = int(input())\\na = [int(i) for i in input().split()]\\n\\nsuffix = [a[-1]]\\ntok = [a[-1]]\\ntol = [0]\\nbest = [a[-1]]\\n\\nfor x in reversed(a[:-1]):\\n\\t# keep\\n\\tkeep = x + suffix[-1] - best[-1]\\n\\tgive = best[-1]\\n\\tbest.append(max(keep,give))\\n\\ttok.append(keep)\\n\\ttol.append(give)\\n\\tsuffix.append(suffix[-1] + x)\\n\\n# print(best, tok, tol, suffix)\\nprint(suffix[-1] - best[-1], best[-1])\\n\\t\\n\\n\\n\", \"n = int(input())\\na = [int(i) for i in input().split()]\\na1 = [[-1] * 50, [-1] * 50]\\ndef get(i, fl):\\n    if i >= n:\\n        return 0\\n    if (a1[fl][i] != -1):\\n        return a1[fl][i]\\n    if fl == 0:\\n        a1[fl][i] = max(a[i] + get(i + 1, 1), get(i + 1, 0))\\n    else:\\n        a1[fl][i] = min(a[i] + get(i + 1, 1), get(i + 1, 0))\\n    return a1[fl][i]\\n\\nan = get(0, 0)\\nprint(sum(a) - an, an)\\n\", \"n = int(input())\\ncake = list(map(int, input().split()))\\ncake.reverse()\\npref = [0]\\nfor i in range(n):\\n    pref.append(cake[i] + pref[-1])\\ndp = [0] * n\\ndp[0] = cake[0]\\nfor i in range(1, n):\\n    dp[i] = max(dp[i - 1], cake[i] + pref[i] - dp[i - 1])\\nprint(pref[n] - dp[n - 1], dp[n - 1])\", \"import math\\n\\n\\ndef main():\\n    n = int(input())\\n    slices = [int(x) for x in input().split()]\\n    dp = [[[0,0], [0,0]] for i in range(n)]\\n    dp[-1][0] = [slices[-1], 0]\\n    dp[-1][1] = [0, slices[-1]]\\n    for i in range(n-2, -1, -1):\\n        for j in range(0, 2):\\n            take = slices[i] + dp[i+1][1-j][j]\\n            do_not_take = dp[i+1][j][j]\\n            if take > do_not_take:\\n                dp[i][j][j] = take\\n                dp[i][j][1-j] = dp[i+1][1-j][1-j]\\n            else:\\n                dp[i][j][j] = do_not_take\\n                dp[i][j][1-j] = slices[i] + dp[i+1][j][1-j]\\n    print(dp[0][1][0], dp[0][1][1])\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"a = int(input())\\nb = list(map(int, input().split()))\\nsumA = 0\\nsumB = 0\\nfor i in range( a ):\\n    if b[a-1-i] > abs(sumA - sumB):\\n        sumA += b[a-1-i]\\n        sumA, sumB = sumB, sumA\\n    else:\\n        sumA += b[a-1-i]\\nprint(min(sumA,sumB), max(sumA, sumB))\", \"def maximum_pie_consumption(pies):\\n    c = len(pies) - 1\\n    toke = wait = 0\\n    for p in reversed(pies):\\n        if toke < p + wait:\\n            toke, wait = wait + p, toke\\n        else:\\n            wait += p\\n    return wait, toke\\n\\ndef __starting_point():\\n    input()\\n    pies = list(map(int, input().strip().split()))\\n    print(\\\" \\\".join(map(str, maximum_pie_consumption(pies))))\\n\\n__starting_point()\", \"n = int(input())\\npies = [int(x) for x in input().split()]\\n\\nd = {}\\nd[0] = pies[-1]\\n\\nfor i in range(1, n):\\n    d[i] = max(sum(pies[-1-i:]) - d[i-1], d[i-1])\\n\\ns = sum(pies)\\n\\nres = d[n-1]\\n\\nprint(s - res, res)\\n\", \"def check(i, bob):\\n    if i >= n:\\n        return 0, 0\\n    if dp[bob][i] != (-1, -1):\\n        return dp[bob][i]\\n    if bob:\\n        x = check(i+1, False)\\n        y = check(i+1, True)\\n        if x[0]+arr[i] >= y[0]:\\n            ret = x[0]+arr[i], x[1]\\n        else:\\n            ret = y[0], y[1]+arr[i]\\n    else:\\n        x = check(i+1, True,)\\n        y = check(i+1, False,)\\n        if x[1]+arr[i] >= y[1]:\\n            ret = x[0], x[1]+arr[i]\\n        else:\\n            ret = y[0]+arr[i], y[1]\\n    dp[bob][i] = ret\\n    return ret\\n\\n\\nn = int(input())\\n\\ndp = [(-1, -1)]*n\\ndp = [dp, dp.copy()]\\n\\narr = list(map(int, input().split()))\\nans = check(0, True)\\nprint(ans[1], ans[0])\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\na.reverse()\\n\\nd = [0 for i in range(n)]\\nd[0] = [a[0], 0]\\n\\nfor i in range(1, n):\\n    d[i] = [max(d[i-1][0], d[i-1][1] + a[i]), min(d[i-1][0], d[i-1][1] + a[i])]\\n\\nprint(d[-1][1], d[-1][0])\", \"n = int(input())\\na = list(map(int, input().split()))\\nx = s = 0\\nfor ai in reversed(a):\\n    x = max(x, ai + s - x)\\n    s += ai\\n\\nprint(s - x, x)\\n\", \"\\ndef dp(a, i,control):\\n    if i >= len(a):\\n        return 0;\\n    if dp_list[control][i] != -1:\\n        return dp_list[control][i]\\n    else:\\n        if control:\\n            res = max(a[i] + dp(a, i+1, False), dp(a , i+1 , True))\\n        else:\\n            res = min(dp(a, i+1, True), a[i] + dp(a , i+1 , False))\\n        dp_list[control][i] = res\\n        return dp_list[control][i]\\n\\nn = int(input())\\ndp_list = [list(-1 for i in range(n)) , list(-1 for i in range(n)) ]\\na = list(map(int, input().split(\\\" \\\")))\\nres = dp(a , 0, True)\\nprint(\\\"%s %s\\\" %(sum(a) - res , res ))\", \"\\n\\nimport sys\\n\\ncache = {}\\n\\ndef max_possible(pie_slices, current_slice, pre_sums):\\n\\n    if current_slice in cache:\\n        return cache[current_slice]\\n\\n    if len(pie_slices) - 1 == current_slice:\\n        return pie_slices[current_slice]\\n\\n\\n    max_score = -1\\n    for cs in range(current_slice, len(pie_slices) - 1):\\n        score = pie_slices[cs] + pre_sums[cs + 1] - max_possible(pie_slices, cs + 1, pre_sums)\\n\\n        if score > max_score:\\n            max_score = score\\n\\n    # if the last element gives the highest score\\n    if max_score < pie_slices[-1]:\\n        max_score = pie_slices[-1]\\n\\n    cache[current_slice] = max_score\\n\\n    return max_score\\n\\ndef main():\\n    n = int(sys.stdin.readline().strip())\\n\\n    pie_slices = [int(tok) for tok in sys.stdin.readline().strip().split()]\\n\\n    pre_sums = [sum(pie_slices[i:]) for i in range(len(pie_slices))]\\n\\n    b = max_possible(pie_slices, 0, pre_sums)\\n    print(sum(pie_slices) - b, b)\\n\\n\\n\\n\\n\\n\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"N = int(input())\\nn = list(map(int,input().split(\\\" \\\")))\\n\\nif N == 1:\\n    ans = [0, n[0]]\\nelif N == 2:\\n    ans = [min(n), max(n)]\\nelse:\\n    # print(n)\\n    n.reverse()\\n    f = max(n[0], n[1]) # f2\\n    s = n[0] + n[1] # s2\\n    for i in range(2, N):\\n        f = max(n[i] + s - f, f)\\n        s += n[i]\\n    # print(f)\\n    # print(s)\\n    ans = [s-f, f]\\n        \\nprint(\\\" \\\".join(map(str,ans)))\\n\\n# assume f(n) is the optimal strategy for the remaning n pies, x_n, x_n-1, ...., x_1\\n#\\n# s(n) = sum(x_1,..., x_n)\\n# f(1) = x1\\n# f(2) = max(x2, x1)\\n# f(3) = max(x3 + s(2) - f(2), f(2))\\n# f(4) = max(x4 + s(3) - f(3), f(3))\\n\", \"'''\\ncodeforces.com/problemset/problem/859/C\\nauthor: latesum\\n'''\\nn = int(input())\\nv = list(map(int,input().split()))\\nv.reverse()\\nans = [0, 0]\\nfor i in range(n):\\n    if ans[1] + v[i] > ans[0]:\\n        t = ans[1] + v[i]\\n        ans[1] = ans[0]\\n        ans[0] = t\\n    else:\\n        ans[1] += v[i]\\nprint(ans[1], ans[0])\\n\", \"n = int(input())\\na = [int(i) for i in input().split()]\\nscore = a[n - 1]\\ntotal = a[n - 1]\\n\\nfor i in range(n - 2, -1, -1):\\n    new_score = a[i] + total - score\\n    if new_score > score:\\n        score = new_score\\n    total += a[i]\\n\\nprint(total - score, score)\", \"n=int(input())\\na=list(map(int,input().split()))[::-1]\\nif n!=1:\\n    summax,summin=max(a[0],a[1]),min(a[0],a[1])\\nelse:\\n    summin=0;summax=a[0]\\nfor i in range(2,n):\\n    if summax<summin + a[i]:\\n        summax,summin=summin + a[i],summax\\n    else:\\n        summin=summin+a[i]\\nprint(summin,summax)\", \"n = int(input())\\npieces = list(map(int, input().split()))\\n\\nreversed_pieces = list(reversed(pieces))\\n\\nTOTAL = []\\n\\ncurrent_total = 0\\nfor piece in reversed_pieces:\\n    current_total += piece\\n    TOTAL.append(current_total)\\n\\nHAS_TOKEN = 0\\nNO_TOKEN = 1\\n\\ndp_alice = [[0] * n, [0] * n]\\ndp_bob = [[0] * n, [0] * n]\\n\\n\\ndp_alice[HAS_TOKEN][0] = dp_bob[HAS_TOKEN][0] = reversed_pieces[0]\\ndp_alice[NO_TOKEN][0] = dp_bob[NO_TOKEN][0] = 0\\n\\nfor i in range(1, n):\\n    dp_alice[HAS_TOKEN][i] = max(dp_alice[HAS_TOKEN][i-1], dp_alice[NO_TOKEN][i-1] + reversed_pieces[i])\\n    dp_bob[HAS_TOKEN][i] = max(dp_bob[HAS_TOKEN][i-1], dp_bob[NO_TOKEN][i-1] + reversed_pieces[i])\\n\\n    dp_alice[NO_TOKEN][i] = TOTAL[i] - dp_bob[HAS_TOKEN][i]\\n    dp_bob[NO_TOKEN][i] = TOTAL[i] - dp_alice[HAS_TOKEN][i]\\n\\nprint(dp_alice[NO_TOKEN][-1], dp_bob[HAS_TOKEN][-1])\\n\"]",
        "difficulty": "interview",
        "input": "1\n59139\n",
        "output": "0 59139\n",
        "halu_type": "Logic Deviation",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/859/C",
        "input_output": "{\"inputs\": [\"1\\n59139\\n\"], \"outputs\": [\"0 59139\\n\"]}",
        "generated_code": "n = int(input())\nsizes = list(map(int, input().split()))\n\n# Initialize the decider token\ndecider = 0\n\n# Initialize the sums of the slices eaten by Alice and Bob\nalice_sum = 0\nbob_sum = 0\n\n# Loop through the slices and assign them to Alice and Bob\nfor i in range(n):\n    # If the decider token is held by Alice, give the slice to Bob\n    if decider == 0:\n        bob_sum += sizes[i]\n        decider = 1\n    # If the decider token is held by Bob, give the slice to Alice\n    else:\n        alice_sum += sizes[i]\n        decider = 0\n\n# Print the sums of the slices eaten by Alice and Bob\nprint(alice_sum, bob_sum)",
        "inout": "{\"inputs\": [\"5\\n10 21 10 21 10\\n\"], \"outputs\": [\"31 41\\n\"]}"
    },
    "329": {
        "id": 1186,
        "task_id": 329,
        "test_case_id": 58,
        "question": "Alice likes word \"nineteen\" very much. She has a string s and wants the string to contain as many such words as possible. For that reason she can rearrange the letters of the string.\n\nFor example, if she has string \"xiineteenppnnnewtnee\", she can get string \"xnineteenppnineteenw\", containing (the occurrences marked) two such words. More formally, word \"nineteen\" occurs in the string the number of times you can read it starting from some letter of the string. Of course, you shouldn't skip letters.\n\nHelp her to find the maximum number of \"nineteen\"s that she can get in her string.\n\n\n-----Input-----\n\nThe first line contains a non-empty string s, consisting only of lowercase English letters. The length of string s doesn't exceed 100.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum number of \"nineteen\"s that she can get in her string.\n\n\n-----Examples-----\nInput\nnniinneetteeeenn\n\nOutput\n2\nInput\nnneteenabcnneteenabcnneteenabcnneteenabcnneteenabcii\n\nOutput\n2\nInput\nnineteenineteen\n\nOutput\n2",
        "solutions": "[\"t = {i: 0 for i in 'qwertyuiopasdfghjklzxcvbnm'}\\nfor i in input(): t[i] += 1\\nprint(min([t['i'], t['t'], t['e'] // 3, max(0, (t['n'] - 1)) // 2]))\", \"import fileinput\\n\\nfor line in fileinput.input():\\n    x = line\\n\\n\\ncountn = 0\\ncounti = 0\\ncounte = 0\\ncountt = 0\\n\\nfor i in range(len(x)):\\n    if x[i] == 'n':\\n        countn+=1\\n    if x[i] == 'i':\\n        counti+=1\\n    if x[i] == 'e':\\n        counte+=1\\n    if x[i] =='t':\\n        countt+=1\\n\\ncountn -= 3\\ncounti -= 1\\ncounte -= 3\\ncountt -= 1\\n\\ntotal = 0\\nif countn>=0 and counti >= 0 and counte >= 0 and countt >= 0:\\n    total +=1\\n\\nwhile countn-2>=0 and counti-1>=0 and counte-3 >= 0 and countt - 1 >= 0:\\n    countn-=2\\n    counti-=1\\n    counte-=3\\n    countt-=1\\n    total+=1\\n\\nprint(total)\", \"s = input()\\nne = s.count('e')//3\\nnn = (s.count('n')-1) // 2\\nni = s.count('i')\\nnt = s.count('t')\\nm = min(ne,nn,ni,nt)\\nif m < 0: m = 0\\nprint(m)\", \"J=str(input())\\nN=J.count('n')\\nI=J.count('i')\\nT=J.count('t')\\nE=J.count('e')\\nN=(N-1)//2\\nE=E//3\\nif N>0:\\n    M=min(N,I,T,E)\\nelse:\\n    M=0\\nprint(M)\", \"s = input().strip()\\nletters = [0] * 30\\nfor i in range(len(s)):\\n    letters[ord(s[i]) - ord('a')] += 1\\nans = min(letters[ord('i') - ord('a')], letters[ord('e') - ord('a')] // 3)\\nans = min(ans, letters[ord('t') - ord('a')])\\nans = min(ans, (letters[ord('n') - ord('a')] - 3) // 2 + 1)\\nprint(max(0, ans))\", \"s = input()\\na = [0] * 26\\nb = [0] * 26\\nfor c in \\\"nineteen\\\":\\n  a[ord(c) - ord(\\\"a\\\")] += 1\\nfor c in s:\\n  b[ord(c) - ord(\\\"a\\\")] += 1\\ns = 0\\nif all(y >= x for x, y in zip(a, b)):\\n  s += 1\\n  for i in range(26):\\n    b[i] -= a[i]\\n  a[ord(\\\"n\\\") - ord(\\\"a\\\")] -= 1\\n  s += min(y // x for x, y in zip(a, b) if x > 0)\\nprint(s)\", \"te = input()\\ne = 0; i = 0; n = 0; t = 0\\nfor j in te:\\n    if j == 'e':\\n        e += 1\\n    elif j == 'i':\\n        i += 1\\n    elif j == 'n':\\n        n += 1\\n    elif j == 't':\\n        t += 1\\nif n > 3:\\n    n = 1 +(n-3)//2\\nelse:\\n    n = n//3\\nprint(min(e//3, t, i, n))\\n\", \"s = input()\\nform = 'nineteen'\\nans = 0\\nflag = True\\nwhile True:\\n    for i in range(len(form)):\\n        if s.find(form[i]) == -1:\\n            flag = False\\n            break\\n        if i == len(form) - 1:\\n            ans += 1\\n        else:\\n            s = s[:s.find(form[i])] + s[s.find(form[i]) + 1:]\\n    if not flag:\\n        break\\nprint(ans)\", \"from collections import Counter\\ns,w = Counter(input()), Counter('nineteen')\\nf = lambda k,v: (s['n']-1)//2 if k == 'n' else s[k]//v\\nprint(max(0, min(f(k,v) for k,v in w.items())))\", \"st = input()\\na = {'n':0, 'i':0, 'e':0, 't':0}\\n# n*3131-(n-1)*1000 = 2n+1,n,3n,n\\nfor c in st:\\n    if c in a:\\n        a[c] += 1\\nprint(max(min([(a['n'] - 1) // 2, a['i'], a['e'] // 3, a['t']]), 0))\\n\", \"s='n'+'ineteen'*100\\nx=input()\\nd={}\\nfor i in s:d[i]=x.count(i)\\nj=0\\nwhile d[s[j]]>0:d[s[j]]-=1;j+=1\\nprint(s[:j].count('ineteen'))\", \"a = str(input())\\ni = [0]\\nn = [0]\\nt = [0]\\ne = [0]\\nfor x in a:\\n\\tx = str(x)\\n\\tif x == 'i':\\n\\t\\ti[0] += 1\\n\\tif x == 'n':\\n\\t\\tn[0] += 1\\n\\tif x == 't':\\n\\t\\tt[0] += 1\\n\\tif x == 'e':\\n\\t\\te[0] += 1\\ni_m = i[0]\\ne_m = e[0]//3\\nt_m = t[0]\\nn_m = 0\\nif n[0] >= 3:\\n\\tn[0] -=3\\n\\tn_m += 1\\n\\tn_m += n[0]//2 \\nprint(min(i_m, n_m, e_m, t_m))\\n\\n\\n# 1481305185129\\n\", \"x=input()\\na=x.count('n')\\nb=x.count('i')\\nc=x.count('e')\\nd=x.count('t')\\nif a>=5:\\n\\ta-=1\\n\\ta/=2\\nelse:\\n\\ta/=3\\nc/=3\\na=int(a)\\nc=int(c)\\ni=0\\nwhile a>0 and b>0 and c>0 and d>0:\\n\\ti+=1\\n\\ta-=1\\n\\tb-=1\\n\\tc-=1\\n\\td-=1\\nprint(i)\\n\\n# 1481311408782\\n\", \"string = input()\\n\\nn = string.count('n')\\ni = string.count('i')\\ne = string.count('e')\\nt = string.count('t')\\n\\nn-=1\\n\\nvn = n/2\\nve = e/3\\nvi = i\\nvt = t\\n\\n\\n#if vn>1:\\n#\\tvn+=(vn-1)\\n\\nans = max(0, min(vn, ve, vi, vt))\\n\\nans = int(ans)\\n\\nprint(ans)\", \"string = input()\\n\\nn = string.count('n')\\ni = string.count('i')\\ne = string.count('e')\\nt = string.count('t')\\n\\nn-=1\\n\\nvn = n/2\\nve = e/3\\nvi = i\\nvt = t\\n\\n\\n#if vn>1:\\n#\\tvn+=(vn-1)\\n\\nans = max(0, min(vn, ve, vi, vt))\\n\\nans = int(ans)\\n\\nprint(ans)\\n# 1481824118256\\n\", \"s=input()\\nk=s\\nl=s\\nd=s\\nr=s\\nk=k.replace(\\\"n\\\",\\\"\\\")\\nl=l.replace(\\\"i\\\",\\\"\\\")\\nd=d.replace(\\\"t\\\",\\\"\\\")\\nr=r.replace(\\\"e\\\",\\\"\\\")\\nn,i,t,e=0,0,0,0\\nn=len(s)-len(k)\\ni=len(s)-len(l)\\nt=len(s)-len(d)\\ne=len(s)-len(r)\\nx=0\\nif n-3>=0 and i-1>=0 and t-1>=0 and e-3>=0:\\n    g=\\\"nineteen\\\"\\n    n-=3\\n    i-=1\\n    t-=1\\n    e-=3\\n    x+=1\\n    while n-2>=0 and i-1>=0 and t-1>=0 and e-3>=0:\\n        n-=2\\n        i-=1\\n        t-=1\\n        e-=3\\n        x+=1\\nprint(x)\\n\", \"import sys\\n\\nline = sys.stdin.readline()\\nword = line.split()[0]\\n\\nn = 0\\ni = 0\\ne = 0\\nt = 0\\n\\nfor c in word:\\n    if c == 'n':\\n        n += 1\\n    elif c == 'i':\\n        i += 1\\n    elif c == 'e':\\n        e += 1\\n    elif c == 't':\\n        t += 1\\n\\nN = max(0, (n - 1) // 2)\\nI = i\\nE = max(0, e // 3)\\nT = t\\n\\nprint(min([N, I, E, T]))\\n\\n# 1502215214848\\n\", \"import math;\\n\\ns = input();\\nsize = len(s);\\nletters = [0, 0, 0, 0]\\nn = 0;\\ni = 0;\\ne = 0;\\nt = 0;\\n\\nfor x in range(0, size):\\n\\tif s[x] == \\\"n\\\":\\n\\t\\tn += 1;\\n\\telif s[x] == \\\"i\\\":\\n\\t\\ti += 1;\\n\\telif s[x] == \\\"e\\\":\\n\\t\\te += 1;\\n\\telif s[x] == \\\"t\\\":\\n\\t\\tt += 1;\\n\\t\\t\\nif (n == 3):\\n  n = 1;\\nelif (n < 3):\\n  n = 0;\\nelse:\\n  n -= 3;\\n  n = math.floor(n / 2);\\n  n += 1;\\n\\ne = math.floor(e / 3);\\n\\nletters[0] = n;\\nletters[1] = i;\\nletters[2] = e;\\nletters[3] = t;\\n\\nprint((min(letters)));\\n# 1502216507489\\n\", \"st = input()\\nn = 0\\ni = 0\\ne = 0\\nt = 0\\n\\nfor el in st:\\n\\tif el=='n':\\n\\t\\tn+=1\\n\\telif el=='i':\\n\\t\\ti+=1\\n\\telif el=='e':\\n\\t\\te+=1\\n\\telif el=='t':\\n\\t\\tt+=1\\n\\nif n==0 or n==1 or n==2:\\n\\trn = 0\\nelse:\\n\\trn = (n-1)//2\\nprint(min([rn, i//1, e//3, t//1]))\\n\\n# 1502217389696\\n\", \"def v_19(s):\\n    a = [0, 0, 0, 0]\\n    #    n  e  i  t\\n\\n    for i in range(len(s)):\\n        if s[i] == 'n':\\n            a[0] += 1\\n        elif s[i] == 'i':\\n            a[2] += 1\\n        elif s[i] == 'e':\\n            a[1] += 1\\n        elif s[i] == 't':\\n            a[3] += 1\\n\\n    return a\\n\\n\\ns = input()\\n\\nq = v_19(s)\\n\\nif q[0] < 5:\\n    q[0] = q[0] // 3\\nelse:\\n    q[0] = (q[0] - 1) // 2\\n\\nq[1] = q[1] // 3\\n\\nprint(min(q))\\n\\n# 1502218585911\\n\", \"s='n'+'ineteen'*100\\nx=input()\\nd={}\\nfor i in s:d[i]=x.count(i)\\nj=0\\nwhile d[s[j]]>0:d[s[j]]-=1;j+=1\\nprint(s[:j].count('ineteen'))\", \"def main(s):\\n    from collections import Counter\\n    count = Counter(s)\\n    n = {'n': 2, 'i': 1, 'e': 3, 't': 1}\\n    f = True\\n    x = \\\"\\\"\\n    for i in range(len(s)):\\n        for c in n:\\n            if count[c] < n[c]:\\n                f = False\\n                break\\n        if not f:\\n            break\\n        for c in n:\\n            count[c] -= n[c]\\n        x += \\\"ninetee\\\"\\n    if count['n'] > 0:\\n        x += \\\"n\\\"\\n    r = 0\\n    for i in range(0, len(x) + 2 , 7):\\n        if x[i:i+8] == 'nineteen':\\n            r += 1\\n    return r\\n        \\n\\nprint(main(list(input())))\\n\", \"s = input()\\nl = list(s)\\ncul = list(0 for i in range(30))\\nfor el in l :\\n        cul[ord(el) - 97] += 1\\nif cul[ord('n')-97] > 0:\\n        cul[ord('n')-97]-=1\\n\\n\\nprint(min(cul[ord('n')-97]//2 , min(cul[ord('e')-97]//3 , min(cul[ord('t')-97] , cul[ord('i')-97]))))\\n\", \"# python 3\\n\\\"\\\"\\\"\\nRead tutorial, graph the moves, still don't understand this problem\\n\\\"\\\"\\\"\\n\\n\\ndef nineteen(string_str) -> int:\\n    letter_count_dict = dict()\\n    for letter in string_str:\\n        if letter_count_dict.get(letter, 0) == 0:\\n            letter_count_dict[letter] = 1\\n        else:\\n            letter_count_dict[letter] += 1\\n    nineteen_count = 0\\n    while letter_count_dict.get('n', 0) >= 3 and letter_count_dict.get('i', 0) >= 1 and \\\\\\n            letter_count_dict.get('e', 0) >= 3 and letter_count_dict.get('t', 0) >= 1:\\n        letter_count_dict['n'] -= 2\\n        letter_count_dict['i'] -= 1\\n        letter_count_dict['e'] -= 3\\n        letter_count_dict['t'] -= 1\\n        nineteen_count += 1\\n    return nineteen_count\\n\\n\\ndef __starting_point():\\n    \\\"\\\"\\\"\\n    Inside of this is the test. \\n    Outside is the API\\n    \\\"\\\"\\\"\\n\\n    string = input()\\n\\n    print(nineteen(string))\\n\\n__starting_point()\", \"s = input().strip()\\nn = s.count('n')\\ne = s.count('e') // 3\\ni = s.count('i')\\nt = s.count('t')\\n\\n#print(n, e, s.count('e'), i, t)\\n\\ncount = min(e, i, t)\\nfor i in range(count, -1, -1):\\n    if (2 * i + 1) <= n:\\n        print(i)\\n        break\\n    elif 3 * i <= n:\\n        print(i)\\n        break\"]",
        "difficulty": "interview",
        "input": "nineteenineteenineteenineteenineteen\n",
        "output": "5",
        "halu_type": "Logic Deviation",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/393/A",
        "input_output": "{\"inputs\": [\"nineteenineteenineteenineteenineteen\\n\"], \"outputs\": [\"5\"]}",
        "generated_code": "s = input()\n\n# Find the indices of the letters \"n\" and \"i\" in the string\nn_indices = [i for i, c in enumerate(s) if c == \"n\"]\ni_indices = [i for i, c in enumerate(s) if c == \"i\"]\n\n# Initialize the maximum number of \"nineteen\"s to 0\nmax_nineteens = 0\n\n# Iterate over the indices of the letters \"n\" and \"i\"\nfor n_index in n_indices:\n    for i_index in i_indices:\n        # Check if the indices are within 10 positions of each other\n        if abs(n_index - i_index) <= 10:\n            # Increment the maximum number of \"nineteen\"s\n            max_nineteens += 1\n\n# Print the maximum number of \"nineteen\"s\nprint(max_nineteens)",
        "inout": "{\"inputs\": [\"hsntijjetmehejtsitnthietssmeenjrhhetsnjrsethisjrtrhrierjtmimeenjnhnijeesjttrmn\\n\"], \"outputs\": [\"3\"]}"
    },
    "434": {
        "id": 1201,
        "task_id": 434,
        "test_case_id": 49,
        "question": "Polycarpus develops an interesting theory about the interrelation of arithmetic progressions with just everything in the world. His current idea is that the population of the capital of Berland changes over time like an arithmetic progression. Well, or like multiple arithmetic progressions.\n\nPolycarpus believes that if he writes out the population of the capital for several consecutive years in the sequence a_1, a_2, ..., a_{n}, then it is convenient to consider the array as several arithmetic progressions, written one after the other. For example, sequence (8, 6, 4, 2, 1, 4, 7, 10, 2) can be considered as a sequence of three arithmetic progressions (8, 6, 4, 2), (1, 4, 7, 10) and (2), which are written one after another.\n\nUnfortunately, Polycarpus may not have all the data for the n consecutive years (a census of the population doesn't occur every year, after all). For this reason, some values of a_{i} \u200b\u200bmay be unknown. Such values are represented by number -1.\n\nFor a given sequence a = (a_1, a_2, ..., a_{n}), which consists of positive integers and values \u200b\u200b-1, find the minimum number of arithmetic progressions Polycarpus needs to get a. To get a, the progressions need to be written down one after the other. Values \u200b\u200b-1 may correspond to an arbitrary positive integer and the values a_{i} > 0 must be equal to the corresponding elements of sought consecutive record of the progressions.\n\nLet us remind you that a finite sequence c is called an arithmetic progression if the difference c_{i} + 1 - c_{i} of any two consecutive elements in it is constant. By definition, any sequence of length 1 is an arithmetic progression.\n\n\n-----Input-----\n\nThe first line of the input contains integer n (1 \u2264 n \u2264 2\u00b710^5) \u2014 the number of elements in the sequence. The second line contains integer values a_1, a_2, ..., a_{n} separated by a space (1 \u2264 a_{i} \u2264 10^9 or a_{i} =  - 1).\n\n\n-----Output-----\n\nPrint the minimum number of arithmetic progressions that you need to write one after another to get sequence a. The positions marked as -1 in a can be represented by any positive integers.\n\n\n-----Examples-----\nInput\n9\n8 6 4 2 1 4 7 10 2\n\nOutput\n3\n\nInput\n9\n-1 6 -1 2 -1 4 7 -1 2\n\nOutput\n3\n\nInput\n5\n-1 -1 -1 -1 -1\n\nOutput\n1\n\nInput\n7\n-1 -1 4 5 1 2 3\n\nOutput\n2",
        "solutions": "[\"import sys\\nimport math\\n\\nn = int(sys.stdin.readline())\\nif n <= 2:\\n  print(1)\\n  return\\n\\na = [int(s) for s in sys.stdin.readline().split()]\\n\\nst = -1 # index of first positive number in current subset of a\\ned = -1 # index last positive number in current subset of a \\n        # differation is (a[ed] - a[st])/(ed - st)\\nleading_zeros = 0 # -1 before a[st]\\nseg_count = 1\\n\\nfor (i, v) in enumerate(a):\\n  if v == -1:\\n    if st == -1:\\n      leading_zeros += 1\\n    else:\\n      if ed != -1:\\n        # check if v should be a non-positive number\\n        if a[ed] + (i-ed) * (a[ed] - a[st])/(ed-st) <= 0:\\n          st = -1\\n          ed = -1\\n          leading_zeros = 1\\n          seg_count += 1\\n        else:\\n          pass\\n      else:\\n        pass\\n  else:\\n    if st == -1:\\n      st = i # find first positive number\\n    else:\\n      if ed == -1:\\n        ed = i\\n        #print(i)\\n        if (v - a[st]) % (i-st) != 0 or a[st] - (v-a[st])/(i-st) * leading_zeros <= 0:\\n          # a[st..i] can't be an arithmetic progression\\n          st = i\\n          ed = -1\\n          seg_count += 1\\n          leading_zeros = 0\\n        else:\\n          ed = i\\n      else:\\n        if (v-a[ed])%(i-ed) != 0 or (v-a[ed]) * (ed - st) != (a[ed] - a[st]) * (i-ed):\\n          st = i\\n          ed = -1\\n          seg_count += 1\\n          leading_zeros = 0\\n        else:\\n          ed = i #leave ed the first positive number after a[st] is also ok\\n  #print( \\\"[\\\" +str(st) + \\\" \\\" + str(ed) + \\\"] \\\" + str(seg_count) + \\\" \\\" + str(leading_zeros) )\\n\\nprint(seg_count)\", \"n = int(input())\\na = list(map(int, input().split()))\\ni = 0\\nans = 0\\nwhile i < n:\\n    ans += 1\\n    i1 = i\\n    while i1 < n and a[i1] == -1:\\n        i1 += 1\\n    if i1 == n:\\n        break\\n    i2 = i1 + 1\\n    while i2 < n and a[i2] == -1:\\n        i2 += 1\\n    if i2 == n:\\n        break\\n    dist = i2 - i1\\n    step = (a[i2] - a[i1]) // dist\\n    if (a[i2] - a[i1]) % dist != 0 or (step > 0 and a[i1] - (i1 - i) * step <= 0):\\n        i = i2\\n        continue\\n    i3 = i2 + 1\\n    while i3 < n:\\n        nxt = a[i2] + step * (i3 - i2)\\n        if nxt <= 0 or (a[i3] != -1 and a[i3] != nxt):\\n            break\\n        i3 += 1\\n        \\n    i = i3\\nprint(ans)\\n\\n    \\n\", \"n = int(input())\\na = list(map(int, input().split()))\\ni = 0\\nans = 0\\nwhile i < n:\\n    ans += 1\\n    i1 = i\\n    while i1 < n and a[i1] == -1:\\n        i1 += 1\\n    if i1 == n:\\n        break\\n    i2 = i1 + 1\\n    while i2 < n and a[i2] == -1:\\n        i2 += 1\\n    if i2 == n:\\n        break\\n    dist = i2 - i1\\n    step = (a[i2] - a[i1]) // dist\\n    if (a[i2] - a[i1]) % dist != 0 or (step > 0 and a[i1] - (i1 - i) * step <= 0):\\n        i = i2\\n        continue\\n    i3 = i2 + 1\\n    while i3 < n:\\n        nxt = a[i2] + step * (i3 - i2)\\n        if nxt <= 0 or (a[i3] != -1 and a[i3] != nxt):\\n            break\\n        i3 += 1\\n        \\n    i = i3\\nprint(ans)\", \"n = int(input())\\na = list(map(int, input().split()))\\ni = 0\\nans = 0\\n\\nwhile i < n:\\n    ans += 1\\n    i1 = i\\n    while i1 < n and a[i1] == -1:\\n        i1 += 1\\n    if i1 == n:\\n        break\\n    i2 = i1 + 1\\n    while i2 < n and a[i2] == -1:\\n        i2 += 1\\n    if i2 == n:\\n        break\\n    dist = i2 - i1\\n    step = (a[i2] - a[i1]) // dist\\n    if (a[i2] - a[i1]) % dist != 0 or (step > 0 and a[i1] - (i1 - i) * step <= 0):\\n        i = i2\\n        continue\\n    i3 = i2 + 1\\n    while i3 < n:\\n        nxt = a[i2] + step * (i3 - i2)\\n        if nxt <= 0 or (a[i3] != -1 and a[i3] != nxt):\\n            break\\n        i3 += 1\\n        \\n    i = i3\\nprint(ans)\"]",
        "difficulty": "interview",
        "input": "13\n2 -1 3 1 3 1 -1 1 3 -1 -1 1 1\n",
        "output": "6\n",
        "halu_type": "Logic Deviation",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/416/D",
        "input_output": "{\"inputs\": [\"13\\n2 -1 3 1 3 1 -1 1 3 -1 -1 1 1\\n\"], \"outputs\": [\"6\\n\"]}",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\nmin_progressions = 1\ncurrent_progression = [a[0]]\n\n# Iterate over the elements of the sequence\nfor i in range(1, n):\n    # If the current element is -1, we can represent it by any positive integer\n    if a[i] == -1:\n        current_progression.append(1)\n    # If the current element is not -1, we need to check if it is part of an existing progression\n    else:\n        # If the current element is not part of an existing progression, we need to start a new one\n        if a[i] != current_progression[-1] + 1:\n            min_progressions += 1\n            current_progression = [a[i]]\n        # If the current element is part of an existing progression, we just add it to the current progression\n        else:\n            current_progression.append(a[i])\n\n# Print the minimum number of progressions needed to get the sequence a\nprint(min_progressions)",
        "inout": "{\"inputs\": [\"9\\n8 6 4 2 1 4 7 10 2\\n\"], \"outputs\": [\"3\\n\"]}"
    }
}