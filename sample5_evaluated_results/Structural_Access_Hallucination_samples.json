{
    "1077": {
        "id": 265,
        "task_id": 1077,
        "test_case_id": 23,
        "question": "Polycarp is a music editor at the radio station. He received a playlist for tomorrow, that can be represented as a sequence a_1, a_2, ..., a_{n}, where a_{i} is a band, which performs the i-th song. Polycarp likes bands with the numbers from 1 to m, but he doesn't really like others. \n\nWe define as b_{j} the number of songs the group j is going to perform tomorrow. Polycarp wants to change the playlist in such a way that the minimum among the numbers b_1, b_2, ..., b_{m} will be as large as possible.\n\nFind this maximum possible value of the minimum among the b_{j} (1 \u2264 j \u2264 m), and the minimum number of changes in the playlist Polycarp needs to make to achieve it. One change in the playlist is a replacement of the performer of the i-th song with any other group.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (1 \u2264 m \u2264 n \u2264 2000).\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9), where a_{i} is the performer of the i-th song.\n\n\n-----Output-----\n\nIn the first line print two integers: the maximum possible value of the minimum among the b_{j} (1 \u2264 j \u2264 m), where b_{j} is the number of songs in the changed playlist performed by the j-th band, and the minimum number of changes in the playlist Polycarp needs to make.\n\nIn the second line print the changed playlist.\n\nIf there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n4 2\n1 2 3 2\n\nOutput\n2 1\n1 2 1 2 \n\n\n\n\nInput\n7 3\n1 3 2 2 2 2 1\n\nOutput\n2 1\n1 3 3 2 2 2 1 \n\n\n\n\nInput\n4 4\n1000000000 100 7 1000000000\n\nOutput\n1 4\n1 2 3 4 \n\n\n\n\n\n\n-----Note-----\n\nIn the first sample, after Polycarp's changes the first band performs two songs (b_1 = 2), and the second band also performs two songs (b_2 = 2). Thus, the minimum of these values equals to 2. It is impossible to achieve a higher minimum value by any changes in the playlist. \n\nIn the second sample, after Polycarp's changes the first band performs two songs (b_1 = 2), the second band performs three songs (b_2 = 3), and the third band also performs two songs (b_3 = 2). Thus, the best minimum value is 2.",
        "solutions": "[\"#!/usr/bin/env python3\\n\\nfrom collections import Counter\\n\\nn, m = [int(x) for x in input().split()]\\na = [int(x) for x in input().split()]\\n\\ntgt = n // m\\nb = Counter(a)\\nrd = sum(b[x] for x in b if x > m)\\nr = 0\\n\\nfor i in range(1, m+1):\\n  while rd and b[i] < tgt:\\n    for j in range(n):\\n      if a[j] > m:\\n        b[a[j]] -= 1\\n        b[i] += 1\\n        a[j] = i\\n        rd -= 1\\n        r += 1\\n        break\\n  while b[i] < tgt:\\n    for j in range(n):\\n      if b[a[j]] > tgt:\\n        b[a[j]] -= 1\\n        b[i] += 1\\n        a[j] = i\\n        r += 1\\n        break\\n\\nprint(tgt, r)\\nprint(\\\" \\\".join(str(x) for x in a))\", \"n, m = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\ncount_good = [[0, i + 1] for i in range(m)]\\nbad = 0\\nbad_places = []\\ngood_places = [[i + 1, []] for i in range(m)]\\nfor i in range(len(A)):\\n    elem = A[i]\\n    if elem <= m:\\n        count_good[elem - 1][0] += 1\\n        good_places[elem - 1][1].append(i)\\n    else:\\n        bad += 1\\n        bad_places.append(i)\\nideal = n // m\\nfor elem in good_places:\\n    bad_places.extend(elem[1][ideal:])\\nbad = len(bad_places)\\nbadd = bad\\ncount_good.sort()\\nminn = count_good[0][0]\\nbad_Cnt = 0\\nwhile minn != ideal:\\n    j = 0\\n    while j < len(count_good) and count_good[j][0] == minn and bad > 0:\\n        count_good[j][0] += 1\\n        A[bad_places[bad_Cnt]] = count_good[j][1]\\n        bad_Cnt += 1\\n        bad -= 1\\n        j += 1\\n    minn += 1\\nprint(minn, badd - bad)\\nprint(*A)\\n\", \"a=[int(i) for i in (str(input())).split() ]\\nn=a[0]\\nm=a[1]\\na=[int(i) for i in (str(input())).split() ]\\nmaxmin=n//m\\n\\ngroups={}\\nfor i in a:\\n    groups[i]=0\\nfor i in range(m):\\n    groups[i+1]=0\\n\\nfor i in a:\\n    groups[i]+=1\\nchanges=0\\nfor i in range(1,m+1):\\n    while groups[i]<maxmin:\\n        change=False\\n        for n,j in enumerate(a):\\n            #print(j)\\n            if j <= m:\\n                continue\\n            groups[j]-=1\\n            a[n]=i\\n            groups[i]+=1\\n            #print('kek')\\n            changes+=1\\n            change=True\\n            if groups[i]>=maxmin:\\n                break\\n        \\n        if groups[i]>=maxmin:\\n            continue\\n\\n        for n,j in enumerate(a):\\n            #print(j)\\n            if groups[j]<=maxmin:\\n                continue\\n            #print(groups[j])\\n            groups[j]-=1\\n            a[n]=i\\n            groups[i]+=1\\n            changes+=1\\n            change=True\\n            if groups[i]>=maxmin:\\n                break\\n\\nprint('%s %s'%(maxmin,changes))        \\nfor i in a:\\n    \\n    print(i,end=' ')\\n\", \"n, m = list(map(int, input().split()))\\ntarget = n//m\\nA = [int(i) for i in input().split()]\\nB = [0 for _ in range(2005)]\\nR = B[:]\\nch = 0\\nfor i in A:\\n\\tif i <= m:\\n\\t\\tB[i] += 1\\n\\nfor i in range(2005):\\n\\tR[i] = target - B[i]\\n\\nj = 1\\n\\nfor i in range(n):\\n\\tif A[i] > m:\\n\\t\\twhile j <= m and R[j] <= 0:\\n\\t\\t\\tj += 1\\n\\t\\tif j <= m and R[j] > 0:\\n\\t\\t\\tch += 1\\n\\t\\t\\tR[j] -= 1\\n\\t\\t\\tA[i] = j\\n\\nfor i in range(n):\\n\\tif A[i] <= m and R[A[i]] < 0:\\n\\t\\twhile j <= m and R[j] <= 0:\\n\\t\\t\\tj += 1\\n\\t\\tif j <= m and R[j] > 0:\\n\\t\\t\\tR[j] -= 1\\n\\t\\t\\tR[A[i]] += 1\\n\\t\\t\\tA[i] = j\\n\\t\\t\\tch += 1\\nprint(target, ch)\\nprint(*A)\\n\", \"n, m = list(map(int, input().split()))\\ncount=[0]*(m+1)\\nlother=[]\\nlbig=[]\\na=list(map(int, input().split()))\\nfor i in range(len(a)):\\n    if a[i]<=m:\\n        count[a[i]]+=1\\n    else:\\n        lother.append(i)\\nfor i in range(len(a)):\\n    if a[i]<=m and count[a[i]]>n//m:\\n        lbig.append(i)\\n        count[a[i]]-=1\\nans=0\\nfor i in range(1,m+1):\\n    while count[i]<n//m:\\n        ans+=1\\n        if len(lother)!=0:\\n            a[lother[0]]=i\\n            lother.pop(0)\\n        else:\\n            #print(\\\"in\\\")\\n            #print(len(a))\\n            #print(lbig[0])\\n            a[lbig[0]]=i\\n            lbig.pop(0)\\n            #print('out');\\n        count[i]+=1\\nprint(str(n//m)+' '+str(ans))\\nfor i in a:\\n    print(i,end=' ')\"]",
        "difficulty": "interview",
        "input": "6 3\n3 3 3 100 1 2\n",
        "output": "2 2\n2 3 3 1 1 2 \n",
        "halu_type": "Structural Access Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/723/C",
        "input_output": "{\"inputs\": [\"6 3\\n3 3 3 100 1 2\\n\"], \"outputs\": [\"2 2\\n2 3 3 1 1 2 \\n\"]}",
        "generated_code": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the number of songs for each band\nb = [0] * (m + 1)\n\n# Count the number of songs for each band\nfor i in range(n):\n    b[a[i]] += 1\n\n# Find the minimum number of songs for each band\nmin_b = min(b)\n\n# Find the maximum possible value of the minimum\nmax_min = max(min_b, *b[1:])\n\n# Print the answer\nprint(max_min, min_b)\n\n# Print the changed playlist\nprint(*[a[i] for i in range(n) if b[a[i]] == min_b])",
        "inout": "{\"inputs\": [\"1 1\\n381183829\\n\"], \"outputs\": [\"1 1\\n1 \\n\"]}"
    },
    "1401": {
        "id": 635,
        "task_id": 1401,
        "test_case_id": 16,
        "question": "Alyona decided to go on a diet and went to the forest to get some apples. There she unexpectedly found a magic rooted tree with root in the vertex 1, every vertex and every edge of which has a number written on.\n\nThe girl noticed that some of the tree's vertices are sad, so she decided to play with them. Let's call vertex v sad if there is a vertex u in subtree of vertex v such that dist(v, u) > a_{u}, where a_{u} is the number written on vertex u, dist(v, u) is the sum of the numbers written on the edges on the path from v to u.\n\nLeaves of a tree are vertices connected to a single vertex by a single edge, but the root of a tree is a leaf if and only if the tree consists of a single vertex\u00a0\u2014 root.\n\nThus Alyona decided to remove some of tree leaves until there will be no any sad vertex left in the tree. What is the minimum number of leaves Alyona needs to remove?\n\n\n-----Input-----\n\nIn the first line of the input integer n (1 \u2264 n \u2264 10^5) is given\u00a0\u2014 the number of vertices in the tree.\n\nIn the second line the sequence of n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) is given, where a_{i} is the number written on vertex i.\n\nThe next n - 1 lines describe tree edges: i^{th} of them consists of two integers p_{i} and c_{i} (1 \u2264 p_{i} \u2264 n,  - 10^9 \u2264 c_{i} \u2264 10^9), meaning that there is an edge connecting vertices i + 1 and p_{i} with number c_{i} written on it.\n\n\n-----Output-----\n\nPrint the only integer\u00a0\u2014 the minimum number of leaves Alyona needs to remove such that there will be no any sad vertex left in the tree.\n\n\n-----Example-----\nInput\n9\n88 22 83 14 95 91 98 53 11\n3 24\n7 -8\n1 67\n1 64\n9 65\n5 12\n6 -80\n3 8\n\nOutput\n5\n\n\n\n-----Note-----\n\nThe following image represents possible process of removing leaves from the tree:  [Image]",
        "solutions": "[\"n = int(input())\\n\\nA = list(map(int, input().split()))\\n\\nmaxDist = [0] * n\\n\\nG = [[] for _ in range(n)]\\n\\nfor v in range(1, n):\\n    u, d = tuple(map(int, input().split()))\\n    u -= 1\\n    G[v].append((u, d))\\n    G[u].append((v, d))\\n\\n\\nseen = [False] * n\\nseen[0] = True\\nq = [0]\\nto_remove = []\\n\\nwhile q:\\n    v = q.pop();\\n    for u, dist in G[v]:\\n        if not seen[u]:\\n            seen[u] = True\\n            maxDist[u] = max(dist, maxDist[v] + dist)\\n            if maxDist[u] > A[u]:\\n                to_remove.append(u)\\n            else:\\n                q.append(u)\\n\\ncount = 0\\nwhile to_remove:\\n    v = to_remove.pop()\\n    count += 1\\n    for u, _ in G[v]:\\n        if not seen[u]:\\n            seen[u] = True\\n            to_remove.append(u)\\n\\nprint(count)\", \"import sys\\n\\ndef main():\\n    u = []\\n    r = 0\\n    x = []\\n    q = []\\n\\n\\n    n = int(sys.stdin.readline())\\n    x = list(map(int, sys.stdin.readline().split()))\\n    links = [[] for i in range(n)]\\n    u = [False]*n\\n    p = [0]*n\\n    d = [False]*n\\n\\n    data = sys.stdin.readlines()\\n    for i in range(n-1):\\n        y = data[i].split()    \\n        v , c = int(y[0])-1, int(y[1])\\n        links[i+1].append((v,c))\\n        links[v].append((i+1,c))\\n\\n    u[0] = True\\n    q.append((0,0,False))\\n    while len(q)!=0:\\n        z = q.pop()\\n        i, path, al = z[0], z[1],z[2]\\n        for y in links[i]:\\n            j , c = y[0], y[1]\\n            if not u[j] :\\n                u[j] = True\\n                #print(\\\"dfs\\\", j, path, c)\\n                al2 = al\\n                np = max(path + c, c)\\n                if np>x[j]:\\n                    al2 = True\\n                if al2:\\n                    r+=1\\n                #print(j , np , x[j], al2)\\n                q.append((j, np, al2)) \\n\\n    print(r)\\n\\n\\nmain()\\n\", \"n = int(input())\\na = [int(x) for x in input().split()]\\ng = [[] for _ in range(n)]\\nfor u in range(1, n):\\n    p, c = (int(x) for x in input().split())\\n    g[p-1].append((u, c))\\n\\nstack = [(0, 0, False)]\\nr = 0\\nwhile stack:\\n    u, d, f = stack.pop()\\n    f = f or d > a[u]\\n    if f:\\n        r += 1\\n    for v, c in g[u]:\\n        stack.append((v, d + c if d + c >= 0 else 0, f))\\n\\nprint(r)\", \"from queue import deque\\n#sys.setrecursionlimit(10**6)\\n\\nn = int(input())\\na = [0] + list(map(int, input().split()))\\n\\nG = {i : [] for i in range(1, n+1)}\\n\\nfor i in range(1, n):\\n    parent, edge = list(map(int, input().split()))\\n    G[parent].append((i + 1, edge))\\n\\ncut = 0\\nstack = [(1, 0, False)]\\n\\nwhile stack:\\n    v, cur_max, to_cut = stack.pop()\\n\\n    if cur_max > a[v] and not to_cut:\\n        to_cut = True\\n        cut += 1\\n\\n    if to_cut:\\n        cut += len(G[v])\\n\\n    for u, e in G[v]:\\n        stack.append((u, max(0, cur_max + e), to_cut))\\n\\nprint(cut)\\n\\n\\n\\n\", \"\\\"\\\"\\\"\\n\\tAuthor\\t\\t: Arif Ahmad\\n\\tDate  \\t\\t: 18-06-16\\n\\tAlgo  \\t\\t: DFS\\n\\tDifficulty\\t: Medium\\n\\\"\\\"\\\"\\n\\ndef main():\\n\\tn = int(input())\\n\\ta = list(map(int, input().split()))\\n\\ta.insert(0, 0)\\n\\t\\n\\tg = [[] for x in range(n+1)]\\n\\tcost = {}\\n\\tfor i in range(2, n+1):\\n\\t\\tp, c = list(map(int, input().split()))\\n\\t\\tg[p].append((i, c))\\n\\n\\tstack = [(1, 0, False)]\\n\\tans = 0\\n\\twhile stack:\\n\\t\\tu, dist, sad = stack.pop()\\n\\t\\tsad = sad or dist > a[u]\\n\\t\\tif sad: ans += 1\\n\\t\\tfor v, c in g[u]:\\n\\t\\t\\tstack.append((v, max(0, dist+c), sad))\\n\\n\\tprint(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n    \\n\\n__starting_point()\", \"from sys import *\\nsetrecursionlimit(1000001)\\nn=int(input())\\na=[0]+list(map(int,input().split()))\\nE=[[] for _ in range(n+1)]\\nk=[1]*(n+1)\\nfor i in range(n-1):\\n    p,c=map(int,input().split())\\n    E[i+2]+=[(p,c)]\\n    E[p]+=[(i+2,c)]\\ndef bfs(nom,pre=0):\\n    ch,ii=[(nom,pre)],0\\n    while ii<len(ch):\\n        nom,pre=ch[ii]\\n        for x,c in E[nom]:\\n            if x!=pre: ch+=[(x,nom)]\\n        ii+=1\\n    for i in range(len(ch)-1,-1,-1):\\n        nom,pre=ch[i]\\n        for x,c in E[nom]:\\n            if x!=pre: k[nom]+=k[x]        \\n    \\nbfs(1)\\ndef bfs2(nom,pre=0,l=0):\\n    ch=[(nom,pre,l)]\\n    ans=0\\n    while ch!=[]:\\n        nom,pre,l=ch.pop()\\n        if l>a[nom]: ans+=k[nom]; continue\\n        for x,c in E[nom]:\\n            if x!=pre:  \\n                ch+=[(x,nom,max(l+c,c))]\\n    return ans\\nprint(bfs2(1))\", \"n=int(input())\\na=[0]+list(map(int,input().split()))\\nE=[[] for _ in range(n+1)]\\nfor i in range(n-1):\\n    p,c=map(int,input().split())\\n    E[i+2]+=[(p,c)]\\n    E[p]+=[(i+2,c)]\\n\\nans=0\\nch=[(1,0,0)]\\nwhile ch:\\n    nom,pre,l=ch.pop()\\n    if l>a[nom]: continue\\n    ans+=1\\n    for x,c in E[nom]:\\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\\nprint(n-ans)\", \"n=int(input())\\na=[0]+list(map(int,input().split()))\\nE=[[] for _ in range(n+1)]\\nfor i in range(n-1):\\n    p,c=map(int,input().split())\\n    E[i+2]+=[(p,c)]\\n    E[p]+=[(i+2,c)]\\n\\nans=0\\nch=[(1,0,0)]\\nwhile ch:\\n    nom,pre,l=ch.pop()\\n    if l>a[nom]: continue\\n    ans+=1\\n    for x,c in E[nom]:\\n        t=l+c if l>0 else c\\n        if x!=pre: ch+=[(x,nom,t)]\\nprint(n-ans)\", \"read = lambda: list(map(int, input().split()))\\nn = int(input())\\na = [0] + list(read())\\ng = [list() for i in range(n + 1)]\\nfor i in range(2, n + 1):\\n    p, c = read()\\n    g[i].append((p, c))\\n    g[p].append((i, c))\\nwas = [0] * (n + 1)\\nst = [(1, 0, 0)]\\nwhile st:\\n    v, mind, dist = st.pop()\\n    was[v] = 1\\n    for u, c in g[v]:\\n        if not was[u]:\\n            if dist + c - min(dist + c, mind) <= a[u]:\\n                st.append((u, min(mind, dist + c), dist + c))\\n\\nans = n - was.count(1)\\nprint(ans)\\n\", \"import sys\\n\\n\\ndef subtree_count():\\n    stack = [0]\\n    while len(stack):\\n        v = stack[-1]\\n\\n        size = 1\\n        for u, _ in edge[v]:\\n            if u in subtree:\\n                size += subtree[u]\\n            else:\\n                stack.append(u)\\n\\n        if stack[-1] == v:\\n            stack.pop()\\n            subtree[v] = size\\n\\n\\ndef remove_bfs():\\n    queue = [(0, 0)]\\n\\n    removed = 0\\n\\n    while len(queue):\\n        v, s = queue.pop()\\n\\n        if s > vertex[v]:\\n            removed += subtree[v]\\n        else:\\n            for u, c in edge[v]:\\n                queue.append((u, max(s + c, 0)))\\n\\n    return removed\\n\\nsys.setrecursionlimit(1000001)\\nn = int(input())\\n\\nvertex = list(map(int, input().split()))\\nedge = {}\\nsubtree = {}\\n\\nfor i in range(n):\\n    edge[i] = []\\n\\nfor i in range(n - 1):\\n    p, c = list(map(int, input().split()))\\n    edge[p - 1] += [(i + 1, c)]\\n\\nsubtree_count()\\nprint(remove_bfs())\\n\", \"def subtree_count():\\n    stack = [0]\\n    while len(stack):\\n        v = stack[-1]\\n\\n        size = 1\\n        for u, _ in edge[v]:\\n            if u in subtree:\\n                size += subtree[u]\\n            else:\\n                stack.append(u)\\n\\n        if stack[-1] is v:\\n            stack.pop()\\n            subtree[v] = size\\n\\n\\ndef remove_bfs():\\n    queue = [(0, 0)]\\n    removed = 0\\n\\n    while len(queue):\\n        v, s = queue.pop()\\n\\n        if s > vertex[v]:\\n            removed += subtree[v]\\n        else:\\n            for u, c in edge[v]:\\n                queue.append((u, max(s + c, 0)))\\n\\n    return removed\\n\\nn = int(input())\\n\\nvertex = list(map(int, input().split()))\\nedge = {}\\nsubtree = {}\\n\\nfor i in range(n):\\n    edge[i] = []\\n\\nfor i in range(n - 1):\\n    p, c = list(map(int, input().split()))\\n    edge.get(p - 1, []).append((i + 1, c))\\n\\nsubtree_count()\\nprint(remove_bfs())\\n\", \"def subtree_count():\\n    stack = [0]\\n    while len(stack):\\n        v = stack[-1]\\n\\n        size = 1\\n        for u, _ in edge[v]:\\n            if u in subtree:\\n                size += subtree[u]\\n            else:\\n                stack.append(u)\\n\\n        if stack[-1] is v:\\n            stack.pop()\\n            subtree[v] = size\\n\\n\\ndef remove_bfs():\\n    queue = [(0, 0)]\\n    removed = 0\\n\\n    while len(queue):\\n        v, s = queue.pop()\\n\\n        if s > vertex[v]:\\n            removed += subtree[v]\\n        else:\\n            for u, c in edge[v]:\\n                queue.append((u, max(s + c, 0)))\\n\\n    return removed\\n\\nn = int(input())\\n\\nvertex = list(map(int, input().split()))\\nedge = {}\\nsubtree = {}\\n\\nfor i in range(n):\\n    edge[i] = []\\n\\nfor i in range(n - 1):\\n    p, c = list(map(int, input().split()))\\n    edge[p - 1].append((i + 1, c))\\n\\nsubtree_count()\\nprint(remove_bfs())\\n\", \"nn=int(input())\\na=[0]+list(map(int,input().split()))\\nE=[[] for _ in range(nn+1)]\\nfor i in range(nn-1):\\n    p,c=list(map(int,input().split()))\\n    E[i+2]+=[(p,c)]\\n    E[p]+=[(i+2,c)]\\n\\nans=0\\nch=[(1,0,0)]\\nwhile ch:\\n    nom,pre,l=ch.pop()\\n    if l>a[nom]: continue\\n    ans+=1\\n    for x,c in E[nom]:\\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\\nprint(nn-ans)\\n\", \"n=input()\\nn=int(n)\\na=input()\\na=a.split()\\na[0:0]=[0]\\nfor i in range(1,n+1):\\n    a[i]=int(a[i])\\ne=[[]for i in range(0,n+1)]\\nfor i in range(2,n+1):\\n    x=input()\\n    x=x.split()\\n    e[i].append([int(x[0]),int(x[1])])\\n    e[int(x[0])].append([i,int(x[1])])\\nq=[1]\\ncnt=0\\nf=[0 for i in range(0,n+1)]\\ndp=[0 for i in range(0,n+1)]\\nans=1\\nwhile cnt<len(q):\\n    #print(cnt,len(q))\\n    now=q[cnt]\\n    cnt+=1\\n    for x in e[now]:\\n        if x[0]!=f[now]:\\n            f[x[0]]=now\\n            dp[x[0]]=max(x[1]+dp[now],0)\\n            if dp[x[0]]>a[x[0]]:\\n                continue\\n            q.append(x[0])\\n            ans+=1\\nprint(n-ans)\", \"from collections import deque\\nimport sys\\n\\n\\ndef bfs(n, adjList, a):\\n    q = deque()\\n    dist = [0] * (n+3)\\n    vis = [False] * (n+3)\\n\\n    q.append(1)\\n    vis[1] = True\\n    cnt = 0\\n\\n    while q:\\n        u = q.popleft()\\n\\n        if a[u] < dist[u]:\\n            continue\\n\\n        cnt += 1\\n        for (v, c) in adjList[u]:\\n            if not vis[v]:\\n                vis[v] = True\\n                dist[v] = max(dist[u]+c, 0)\\n                q.append(v)\\n\\n    return cnt\\n\\n\\ndef main():\\n    # sys.stdin = open(\\\"in.txt\\\", \\\"r\\\")\\n\\n    it = iter(map(int, sys.stdin.read().split()))\\n\\n    n = next(it)\\n\\n    a = [0] * (n+3)\\n    adjList = [[] for _ in range(n+3)]\\n\\n    for i in range(1, n+1):\\n        a[i] = next(it)\\n\\n    for i in range(1, n):\\n        p = next(it)\\n        c = next(it)\\n        adjList[i+1].append((p, c))\\n        adjList[p].append((i+1, c))\\n\\n    ans = n - bfs(n, adjList, a)\\n\\n    sys.stdout.write(str(ans) + '\\\\n')\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"from collections import deque\\nimport sys\\n\\n\\ndef bfs(n, adjList, a):\\n    q = deque()\\n    dist = [0] * (n+3)\\n    vis = [False] * (n+3)\\n\\n    q.append(1)\\n    vis[1] = True\\n    cnt = 0\\n\\n    while q:\\n        u = q.popleft()\\n\\n        if a[u] < dist[u]:\\n            continue\\n\\n        cnt += 1\\n        for (v, c) in adjList[u]:\\n            if not vis[v]:\\n                vis[v] = True\\n                dist[v] = max(dist[u]+c, 0)\\n                q.append(v)\\n\\n    return cnt\\n\\n\\ndef main():\\n    # sys.stdin = open(\\\"in.txt\\\", \\\"r\\\")\\n\\n    it = iter(map(int, sys.stdin.read().split()))\\n\\n    n = next(it)\\n\\n    a = [0] * (n+3)\\n    adjList = [[] for _ in range(n+3)]\\n\\n    for i in range(1, n+1):\\n        a[i] = next(it)\\n\\n    for i in range(1, n):\\n        p = next(it)\\n        c = next(it)\\n        adjList[i+1].append((p, c))\\n        adjList[p].append((i+1, c))\\n\\n    ans = n - bfs(n, adjList, a)\\n\\n    sys.stdout.write(str(ans) + '\\\\n')\\n\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"from collections import deque\\nimport sys\\n\\n\\ndef bfs(n, adjList, a):\\n    q = deque()\\n    dist = [0] * (n+3)\\n    vis = [False] * (n+3)\\n\\n    q.append(1)\\n    vis[1] = True\\n    cnt = 0\\n\\n    while q:\\n        u = q.popleft()\\n\\n        if a[u] < dist[u]:\\n            continue\\n\\n        cnt += 1\\n        for (v, c) in adjList[u]:\\n            if not vis[v]:\\n                vis[v] = True\\n                dist[v] = max(dist[u]+c, 0)\\n                q.append(v)\\n\\n    return cnt\\n\\n\\ndef main():\\n    # sys.stdin = open(\\\"in.txt\\\", \\\"r\\\")\\n\\n    it = iter(map(int, sys.stdin.read().split()))\\n\\n    n = next(it)\\n\\n    a = [0] * (n+3)\\n    adjList = [[] for _ in range(n+3)]\\n\\n    for i in range(1, n+1):\\n        a[i] = next(it)\\n\\n    for i in range(1, n):\\n        p = next(it)\\n        c = next(it)\\n        adjList[i+1].append((p, c))\\n        adjList[p].append((i+1, c))\\n\\n    ans = n - bfs(n, adjList, a)\\n\\n    sys.stdout.write(str(ans) + '\\\\n')\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n = int(input())\\nver = list(map(int, input().split()))\\nadj = [{} for i in range(n)]\\n\\nfor i in range(n - 1):\\n    p, c = map(int, input().split())\\n    adj[i + 1][p - 1] = c\\n    adj[p - 1][i + 1] = c\\n\\nfrom collections import deque\\nq = deque([(0, 0, 0)])\\n\\nsad = [0] * n\\nvis = [0] * n\\n\\nwhile q:\\n    v, d, md = q.popleft()\\n    vis[v] = 1\\n\\n    for nv, nvd in adj[v].items():\\n        if vis[nv] == 1 and sad[nv] == 1:\\n            sad[v] = 1\\n\\n    if d > ver[v] or d - md > ver[v]:\\n        sad[v] = 1\\n\\n    for nv, nvd in adj[v].items():\\n        if vis[nv] == 0:\\n            q.append((nv, d + nvd, min(d + nvd, md)))\\n    \\nprint(sum(sad))\", \"\\nread = lambda: map(int, input().split())\\nn = int(input())\\na = [0] + list(read())\\ng = [list() for i in range(n + 1)]\\nfor i in range(2, n + 1):\\n    p, c = read()\\n    g[i].append((p, c))\\n    g[p].append((i, c))\\nwas = [0] * (n + 1)\\nst = [(1, 0, 0)]\\nwhile st:\\n    v, mind, dist = st.pop()\\n    was[v] = 1\\n    for u, c in g[v]:\\n        if not was[u]:\\n            if dist + c - min(dist + c, mind) <= a[u]:\\n                st.append((u, min(mind, dist + c), dist + c))\\n\\nans = n - was.count(1)\\nprint(ans)\", \"nn=int(input())\\n\\na=[0]+list(map(int,input().split()))\\n\\nE=[[] for _ in range(nn+1)]\\n\\nfor i in range(nn-1):\\n\\n    p,c=list(map(int,input().split()))\\n\\n    E[i+2]+=[(p,c)]\\n\\n    E[p]+=[(i+2,c)]\\n\\n\\n\\nans=0\\n\\nch=[(1,0,0)]\\n\\nwhile ch:\\n\\n    nom,pre,l=ch.pop()\\n\\n    if l>a[nom]: continue\\n\\n    ans+=1\\n\\n    for x,c in E[nom]:\\n\\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\\n\\nprint(nn-ans)\\n\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"n = int(input())\\na = list(map(int, input().split()))\\ne = []\\nfor i in range(n):\\n    e.append([])\\nfor i in range(1, n):\\n    x, y = map(int, input().split())\\n    e[x-1].append([i, y])\\n\\nb = [0] * n\\nc = [0] * n\\nd = [(10**18)] * n\\nl = 0\\nr = 1\\ncnt = 0\\nwhile l < r:\\n    v = b[l]\\n    if c[l] - a[v] > d[l]:\\n        l += 1\\n        continue\\n    cnt += 1\\n    for x in e[v]:\\n        c[r] = c[l] + x[1]\\n        d[r] = min(d[l], c[l])\\n        b[r] = x[0]\\n        r += 1\\n    l += 1\\nprint(n-cnt)\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\n\\nclass Graph(object):\\n\\t\\\"\\\"\\\"docstring for Graph\\\"\\\"\\\"\\n\\tdef __init__(self,n,d): # Number of nodes and d is True if directed\\n\\t\\tself.n = n\\n\\t\\tself.graph = [[] for i in range(n)]\\n\\t\\tself.parent = [-1 for i in range(n)]\\n\\t\\tself.directed = d\\n\\t\\t\\n\\tdef addEdge(self,x,y):\\n\\t\\tself.graph[x].append(y)\\n\\t\\tif not self.directed:\\n\\t\\t\\tself.graph[y].append(x)\\n\\n\\tdef bfs(self, root): # NORMAL BFS\\n\\t\\tqueue = [root]\\n\\t\\tqueue = deque(queue)\\n\\t\\tvis = [0]*self.n\\n\\t\\twhile len(queue)!=0:\\n\\t\\t\\telement = queue.popleft()\\n\\t\\t\\tvis[element] = 1\\n\\t\\t\\tfor i in self.graph[element]:\\n\\t\\t\\t\\tif vis[i]==0:\\n\\t\\t\\t\\t\\tqueue.append(i)\\n\\t\\t\\t\\t\\tself.parent[i] = element\\n\\t\\t\\t\\t\\tvis[i] = 1\\n\\t\\t\\t\\t\\tdist[i] = dist[element] + w[(element,i)]\\n\\n\\n\\tdef bfs2(self, root): # NORMAL BFS\\n\\t\\tqueue = [root]\\n\\t\\tqueue = deque(queue)\\n\\t\\tvis = [0]*self.n\\n\\t\\twhile len(queue)!=0:\\n\\t\\t\\telement = queue.popleft()\\n\\t\\t\\tvis[element] = 1\\n\\t\\t\\tfor i in self.graph[element]:\\n\\t\\t\\t\\tif vis[i]==0:\\n\\t\\t\\t\\t\\tqueue.append(i)\\n\\t\\t\\t\\t\\tself.parent[i] = element\\n\\t\\t\\t\\t\\tvis[i] = 1\\n\\t\\t\\t\\t\\tminn[i] = min(minn[element], dist[i])\\n\\n\\tdef bfs3(self, root): # NORMAL BFS\\n\\t\\tqueue = [root]\\n\\t\\tqueue = deque(queue)\\n\\t\\tvis = [0]*self.n\\n\\t\\tcount = 0\\n\\t\\twhile len(queue)!=0:\\n\\t\\t\\telement = queue.popleft()\\n\\t\\t\\tvis[element] = 1\\n\\t\\t\\tcount += 1\\n\\t\\t\\tfor i in self.graph[element]:\\n\\t\\t\\t\\tif vis[i]==0 and remove[i]==0:\\n\\t\\t\\t\\t\\tqueue.append(i)\\n\\t\\t\\t\\t\\tself.parent[i] = element\\n\\t\\t\\t\\t\\tvis[i] = 1\\n\\t\\treturn count\\n\\n\\tdef dfs(self, root, ans): # Iterative DFS\\n\\t\\tstack=[root]\\n\\t\\tvis=[0]*self.n\\n\\t\\tstack2=[]\\n\\t\\twhile len(stack)!=0: # INITIAL TRAVERSAL\\n\\t\\t\\telement = stack.pop()\\n\\t\\t\\tif vis[element]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvis[element] = 1\\n\\t\\t\\tstack2.append(element)\\n\\t\\t\\tfor i in self.graph[element]:\\n\\t\\t\\t\\tif vis[i]==0:\\n\\t\\t\\t\\t\\tself.parent[i] = element\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\n\\t\\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\\n\\t\\t\\telement = stack2.pop()\\n\\t\\t\\tm = 0\\n\\t\\t\\tfor i in self.graph[element]:\\n\\t\\t\\t\\tif i!=self.parent[element]:\\n\\t\\t\\t\\t\\tm += ans[i]\\n\\t\\t\\tans[element] = m\\n\\t\\treturn ans\\n\\n\\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\\n\\t\\tself.bfs(source)\\n\\t\\tpath = [dest]\\n\\t\\twhile self.parent[path[-1]]!=-1:\\n\\t\\t\\tpath.append(parent[path[-1]])\\n\\t\\treturn path[::-1]\\n\\n\\tdef detect_cycle(self):\\n\\t\\tindeg = [0]*self.n\\n\\t\\tfor i in range(self.n):\\n\\t\\t\\tfor j in self.graph[i]:\\n\\t\\t\\t\\tindeg[j] += 1\\n\\t\\tq = deque()\\n\\t\\tvis = 0\\n\\t\\tfor i in range(self.n):\\n\\t\\t\\tif indeg[i]==0:\\n\\t\\t\\t\\tq.append(i)\\n\\t\\twhile len(q)!=0:\\n\\t\\t\\te = q.popleft()\\n\\t\\t\\tvis += 1\\n\\t\\t\\tfor i in self.graph[e]:\\n\\t\\t\\t\\tindeg[i] -= 1\\n\\t\\t\\t\\tif indeg[i]==0:\\n\\t\\t\\t\\t\\tq.append(i)\\n\\t\\tif vis!=self.n:\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\tdef reroot(self, root, ans):\\n\\t\\tstack = [root]\\n\\t\\tvis = [0]*n\\n\\t\\twhile len(stack)!=0:\\n\\t\\t\\te = stack[-1]\\n\\t\\t\\tif vis[e]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t# Reverse_The_Change()\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvis[e] = 1\\n\\t\\t\\tfor i in graph[e]:\\n\\t\\t\\t\\tif not vis[e]:\\n\\t\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\tif self.parent[e]==-1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t# Change_The_Answers()\\n\\nn = int(input())\\na = list(map(int,input().split()))\\ng = Graph(n,False)\\nw = {}\\nfor i in range(n-1):\\n\\tx,y = map(int,input().split())\\n\\tw[(i+1,x-1)] = y\\n\\tw[(x-1,i+1)] = y\\n\\tg.addEdge(i+1,x-1)\\ndist = [0]*n\\nminn = [0]*n\\ng.bfs(0)\\ng.bfs2(0)\\nremove = [0]*n\\nfor i in range(1,n):\\n\\tif dist[i]-minn[i]>a[i]:\\n\\t\\tremove[i] = 1\\n# print (dist)\\n# print (minn)\\n# print (remove)\\nprint (n-g.bfs3(0))\", \"n = int(input())\\na = [0] + list(map(int, input().split()))\\ng = [list() for i in range(n+1)]\\nfor i in range(2, n+1):\\n    u, v = map(int, input().split())\\n    g[i].append((u, v))\\n    g[u].append((i, v))\\nvis = [0] * (n+1)\\nstk = [(1, 0, 0)]\\nwhile stk:\\n    v, min_d, dist = stk.pop()\\n    vis[v] = 1\\n    for u, c in g[v]:\\n        if not vis[u]:\\n            if dist + c - min(min_d, dist+c) <= a[u]:\\n                stk.append((u, min(min_d, dist+c), dist+c))\\nprint(n - vis.count(1))\"]",
        "difficulty": "interview",
        "input": "2\n83 33\n1 67\n",
        "output": "1\n",
        "halu_type": "Structural Access Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/682/C",
        "input_output": "{\"inputs\": [\"2\\n83 33\\n1 67\\n\"], \"outputs\": [\"1\\n\"]}",
        "generated_code": "n = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    edges.append(list(map(int, input().split())))\n\n# Calculate the distance between each vertex and its parent\ndist = [0] * n\nfor i in range(1, n):\n    dist[i] = dist[edges[i - 1][0]] + a[i]\n\n# Calculate the sadness of each vertex\nsad = [False] * n\nfor i in range(1, n):\n    if dist[i] > a[i]:\n        sad[i] = True\n\n# Remove leaves until there are no sad vertices left\nleaves = []\nwhile any(sad):\n    for i in range(1, n):\n        if not sad[i] and not any(sad[j] for j in range(1, n) if j != i and dist[j] > a[j]):\n            leaves.append(i)\n            sad[i] = False\n            break\n\nprint(len(leaves))",
        "inout": "{\"inputs\": [\"5\\n91 61 4 61 35\\n5 75\\n2 13\\n2 -15\\n1 90\\n\"], \"outputs\": [\"4\\n\"]}"
    },
    "1970": {
        "id": 82,
        "task_id": 1970,
        "test_case_id": 2,
        "question": "A boy Petya loves chess very much. He even came up with a chess piece of his own, a semiknight. The semiknight can move in any of these four directions: 2 squares forward and 2 squares to the right, 2 squares forward and 2 squares to the left, 2 squares backward and 2 to the right and 2 squares backward and 2 to the left. Naturally, the semiknight cannot move beyond the limits of the chessboard.\n\nPetya put two semiknights on a standard chessboard. Petya simultaneously moves with both semiknights. The squares are rather large, so after some move the semiknights can meet, that is, they can end up in the same square. After the meeting the semiknights can move on, so it is possible that they meet again. Petya wonders if there is such sequence of moves when the semiknights meet. Petya considers some squares bad. That is, they do not suit for the meeting. The semiknights can move through these squares but their meetings in these squares don't count.\n\nPetya prepared multiple chess boards. Help Petya find out whether the semiknights can meet on some good square for each board.\n\nPlease see the test case analysis.\n\n\n-----Input-----\n\nThe first line contains number t (1 \u2264 t \u2264 50) \u2014 the number of boards. Each board is described by a matrix of characters, consisting of 8 rows and 8 columns. The matrix consists of characters \".\", \"#\", \"K\", representing an empty good square, a bad square and the semiknight's position, correspondingly. It is guaranteed that matrix contains exactly 2 semiknights. The semiknight's squares are considered good for the meeting. The tests are separated by empty line.\n\n\n-----Output-----\n\nFor each test, print on a single line the answer to the problem: \"YES\", if the semiknights can meet and \"NO\" otherwise.\n\n\n-----Examples-----\nInput\n2\n........\n........\n......#.\nK..##..#\n.......#\n...##..#\n......#.\nK.......\n\n........\n........\n..#.....\n..#..#..\n..####..\n...##...\n........\n....K#K#\n\nOutput\nYES\nNO\n\n\n\n-----Note-----\n\nConsider the first board from the sample. We will assume the rows and columns of the matrix to be numbered 1 through 8 from top to bottom and from left to right, correspondingly. The knights can meet, for example, in square (2, 7). The semiknight from square (4, 1) goes to square (2, 3) and the semiknight goes from square (8, 1) to square (6, 3). Then both semiknights go to (4, 5) but this square is bad, so they move together to square (2, 7).\n\nOn the second board the semiknights will never meet.",
        "solutions": "[\"def check(x, y):\\n    return 0 <= x < 8 and 0 <= y < 8\\n\\ndef dfs1(x, y, T=0):\\n    nonlocal first, used\\n    if not(check(x, y)) or used[x][y]:\\n        return\\n    used[x][y] = True\\n    first.add((x, y, T))\\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\\n        dfs1(x + pair[0], y + pair[1], 1 - T)\\n\\ndef dfs2(x, y, T=0):\\n    nonlocal second, used\\n    if not(check(x, y)) or used[x][y]:\\n        return\\n    used[x][y] = True\\n    second.add((x, y, T))\\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\\n        dfs2(x + pair[0], y + pair[1], 1 - T)\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    if i > 0:\\n        kuzma = input()\\n    board = [input() for i in range(8)]\\n    FoundFirst = False\\n    for i in range(8):\\n        for j in range(8):\\n            if board[i][j] == 'K':\\n                if not(FoundFirst):\\n                    First = (i, j)\\n                    FoundFirst = True\\n                else:\\n                    Second = (i, j)\\n\\n    used = [[0 for i in range(8)] for j in range(8)]\\n    first = set()\\n    dfs1(First[0], First[1])\\n    used = [[0 for i in range(8)] for j in range(8)]\\n    second = set()\\n    dfs2(Second[0], Second[1])\\n    intersection = first & second\\n    IsOk = False\\n    for x, y, t in intersection:\\n        if board[x][y] != '#':\\n            print(\\\"YES\\\")\\n            IsOk = True\\n            break\\n    if not(IsOk):\\n        print(\\\"NO\\\")\\n    board = []\\n\", \"T=int(input())\\n\\nfor t in range(T):\\n    L=[]\\n    for i in range(8):\\n        L.append(input())\\n    Moves1=[]\\n    Moves2=[]\\n    K=[]\\n    for i in range(8):\\n        Moves1.append([-1]*8)\\n        Moves2.append([-1]*8)\\n        for j in range(8):\\n            if(L[i][j]=='K'):\\n                K.append((i,j))\\n    Now=K[0]\\n    Explored=[(Now[0],Now[1],0)]\\n    Moves1[Now[0]][Now[1]]=0\\n    while(len(Explored)!=0):\\n        x=Explored[0][0]\\n        y=Explored[0][1]\\n        p=Explored[0][2]\\n        Explored.pop(0)\\n        if(x-2>=0 and y-2>=0):\\n            if(Moves1[x-2][y-2]==-1):\\n                Moves1[x-2][y-2]=1-p\\n                Explored.append((x-2,y-2,1-p))\\n        if(x+2<8 and y-2>=0):\\n            if(Moves1[x+2][y-2]==-1):\\n                Moves1[x+2][y-2]=1-p\\n                Explored.append((x+2,y-2,1-p))\\n        if(x-2>=0 and y+2<8):\\n            if(Moves1[x-2][y+2]==-1):\\n                Moves1[x-2][y+2]=1-p\\n                Explored.append((x-2,y+2,1-p))\\n        if(x+2<8 and y+2<8):\\n            if(Moves1[x+2][y+2]==-1):\\n                Moves1[x+2][y+2]=1-p\\n                Explored.append((x+2,y+2,1-p))\\n    Now=K[1]\\n    Explored=[(Now[0],Now[1],0)]\\n    Moves2[Now[0]][Now[1]]=0\\n    while(len(Explored)!=0):\\n        x=Explored[0][0]\\n        y=Explored[0][1]\\n        p=Explored[0][2]\\n        Explored.pop(0)\\n        if(x-2>=0 and y-2>=0):\\n            if(Moves2[x-2][y-2]==-1):\\n                Moves2[x-2][y-2]=1-p\\n                Explored.append((x-2,y-2,1-p))\\n        if(x+2<8 and y-2>=0):\\n            if(Moves2[x+2][y-2]==-1):\\n                Moves2[x+2][y-2]=1-p\\n                Explored.append((x+2,y-2,1-p))\\n        if(x-2>=0 and y+2<8):\\n            if(Moves2[x-2][y+2]==-1):\\n                Moves2[x-2][y+2]=1-p\\n                Explored.append((x-2,y+2,1-p))\\n        if(x+2<8 and y+2<8):\\n            if(Moves2[x+2][y+2]==-1):\\n                Moves2[x+2][y+2]=1-p\\n                Explored.append((x+2,y+2,1-p))\\n    valid=False\\n    for i in range(8):\\n        for j in range(8):\\n            if(Moves1[i][j]!=-1 and Moves1[i][j]==Moves2[i][j] and L[i][j]!=\\\"#\\\"):\\n                valid=True\\n    if(valid):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    if(t!=T-1):\\n        s=input()\\n\", \"N = int(input())\\nfor i in range(N):\\n    if i > 0:\\n        input()\\n    Pos = []\\n    for i in range(8):\\n        S = input().strip()\\n        for j in range(8):\\n            if S[j] == \\\"K\\\":\\n                Pos.append((i, j))\\n    Dx, Dy = abs(Pos[0][0] - Pos[1][0]), abs(Pos[0][1] - Pos[1][1])\\n    if (Dx == 0 or Dx == 4) and (Dy == 0 or Dy == 4):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n\", \"MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\\ndef check(a):\\n    return 0<=a<8\\nset1 = set()\\nset2 = set()\\ndic1 = dict()\\ndic2 = dict()\\ndef cango1(matrix,pos,lap):\\n    for dx,dy in MOVS:\\n        nx,ny = dx+pos[0],dy+pos[1]\\n        if not check (nx) or not check(ny):\\n            continue\\n        if (nx,ny) in set1:\\n            continue\\n        dic1[(nx,ny)]=lap%2\\n        set1.add((nx,ny))\\n        cango1(matrix,(nx,ny),lap+1)\\ndef cango2(matrix,pos,lap):\\n    for dx,dy in MOVS:\\n        nx,ny = dx+pos[0],dy+pos[1]\\n        if not check(nx) or not check(ny):\\n            continue\\n        if (nx,ny) in set2:\\n            continue\\n        dic2[(nx,ny)]=lap%2\\n        set2.add((nx,ny))\\n        cango2(matrix,(nx,ny),lap+1)\\nq = int(input())\\nfor ww in range(q):\\n    matrix = [input().strip() for i in range(8)]\\n    pos = []\\n    bad = set()\\n    for i in range(8):\\n        for j in range(8):\\n            if matrix[i][j] == 'K':\\n                pos.append((i,j))\\n            if matrix[i][j]=='#':\\n                bad.add((i,j))\\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\\n    cango1(matrix, pos[0],0)\\n    cango2(matrix,pos[1],0)\\n    if ww!=q-1:\\n        input()\\n    sec = (set1&set2) - bad\\n    for x,y in sec:\\n        if dic1[(x,y)]==dic2[(x,y)]:\\n            print(\\\"YES\\\")\\n            break\\n    else:\\n        print(\\\"NO\\\")\\n\", \"import collections\\n\\nn = list(map(int, input().split()))[0]\\ndi = ((2, 2), (-2, 2), (-2, -2), (2, -2))\\n\\ndef  bfs(graph, x,y,tx, ty):\\n    vis = set()\\n    queue = collections.deque()\\n    queue.append((x,y))\\n    vis.add((x,y))\\n    dis =  {}\\n    dis[(x,y)] = 0\\n\\n    while queue:\\n        elem = queue.popleft()\\n        #print (elem)\\n\\n        for direction in  di:\\n            new_elem =  (elem[0] + direction[0], elem[1] +direction[1])\\n            #print (new_elem)\\n            if  new_elem[0] >= 0 and  new_elem[1]>= 0 and  new_elem[0] < 8 and new_elem[1] < 8:\\n                if  new_elem not in vis:\\n                    vis.add(new_elem)\\n                    queue.append(new_elem)\\n                    dis[new_elem] = dis[elem]+ 1\\n#                    print (elem,  new_elem, dis[new_elem])\\n\\n    if  (tx,ty)  not  in   vis:\\n        return  (False,0)\\n    return (True, dis[(tx,ty)])\\n\\nfor cc in range(n):\\n    datamap = []\\n\\n    for i in range(8):\\n        datamap.append(input())\\n\\n    ans = []\\n    for i  in range(len(datamap)):\\n        for j in range(len(datamap[i])):\\n            if datamap[i][j] == 'K':\\n                ans.append(i);\\n                ans.append(j);\\n\\n    ans =   bfs(datamap, ans[0], ans[1], ans[2], ans[3])\\n    #print (ans)\\n    if ans[0] and  ans[1] % 2 == 0:\\n        print (\\\"YES\\\")\\n    else:\\n        print (\\\"NO\\\")\\n\\n    if cc !=  n - 1:\\n        input()\\n\\n\\n\", \"import sys\\nimport collections\\n\\n\\nclass GetOutOfLoop(Exception):\\n    pass\\n\\ndef __starting_point():\\n\\n    n_cases = int(sys.stdin.readline())\\n\\n    for case in range(n_cases):\\n        board = [list(sys.stdin.readline().rstrip()) for i in range(8)]\\n        knight_init_loc = [None, None]\\n        knight = 0\\n        for current_i in range(8):\\n            for current_j in range(8):\\n                if board[current_i][current_j] == 'K':\\n                    knight_init_loc[knight] = (current_i, current_j)\\n                    knight += 1\\n\\n        to_explore = collections.deque()\\n\\n        to_explore.append((knight_init_loc[0], 0))\\n        explored = set()\\n        try:\\n            while len(to_explore) > 0:\\n                ((current_i, current_j), current_step) = to_explore.popleft()\\n                explored.add((current_i, current_j))\\n                candidates = set()\\n                for inc_i in [-2, 2]:\\n                    for inc_j in [-2, 2]:\\n                        next_i, next_j = current_i + inc_i, current_j + inc_j\\n                        if 0 <= next_i < 8 and 0 <= next_j < 8 and (next_i, next_j) not in explored:\\n                            candidates.add(((next_i, next_j), current_step + 1))\\n                for (s, next_step) in candidates:\\n                    if s == knight_init_loc[1] and next_step % 2 == 0:\\n                        print('YES')\\n                        raise GetOutOfLoop\\n                    to_explore.append((s, next_step))\\n                current_step += 1\\n            print('NO')\\n        except GetOutOfLoop:\\n            pass\\n        sys.stdin.readline()\\n__starting_point()\", \"def main():\\n  n = int(input())\\n  out = \\\"\\\"\\n  \\n  for t in range(n):\\n    knights = [0 for i in range(16)]\\n    valid = [False for i in range(16)]\\n    for i in range(8):\\n      line = input()\\n      #print()\\n      for j in range(8):\\n        #print(get(i, j), end=\\\"\\\\t\\\")\\n        if line[j] != '#':\\n          valid[get(i, j)] = True\\n        if line[j] == 'K':\\n          knights[get(i, j)] += 1\\n    \\n    for i in range(16):\\n      #print(i, knights[i], valid[i])\\n      if knights[i] == 2 and valid[i]:\\n        out += \\\"YES\\\\n\\\"\\n        break\\n    else:\\n      out += \\\"NO\\\\n\\\"\\n    \\n    if t != n-1:\\n      input()\\n  \\n  print(out[:-1])\\n\\ndef get(i, j):\\n  return [[0, 1, 2, 3],[4, 5, 6, 7],[8, 9, 10, 11],[12, 13, 14, 15]][i%4][j%4]\\n\\ndef __starting_point(): main()\\n__starting_point()\", \"MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\\ndef check(a):\\n    return 0<=a<8\\nset1 = set()\\nset2 = set()\\ndic1 = dict()\\ndic2 = dict()\\ndef cango1(matrix,pos,lap):\\n    for dx,dy in MOVS:\\n        nx,ny = dx+pos[0],dy+pos[1]\\n        if not check (nx) or not check(ny):\\n            continue\\n        if (nx,ny) in set1:\\n            continue\\n        dic1[(nx,ny)]=lap%2\\n        set1.add((nx,ny))\\n        cango1(matrix,(nx,ny),lap+1)\\ndef cango2(matrix,pos,lap):\\n    for dx,dy in MOVS:\\n        nx,ny = dx+pos[0],dy+pos[1]\\n        if not check(nx) or not check(ny):\\n            continue\\n        if (nx,ny) in set2:\\n            continue\\n        dic2[(nx,ny)]=lap%2\\n        set2.add((nx,ny))\\n        cango2(matrix,(nx,ny),lap+1)\\nq = int(input())\\nfor ww in range(q):\\n    matrix = [input().strip() for i in range(8)]\\n    pos = []\\n    for i in range(8):\\n        for j in range(8):\\n            if matrix[i][j] == 'K':\\n                pos.append((i,j))\\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\\n    cango1(matrix, pos[0],0)\\n    cango2(matrix,pos[1],0)\\n    if ww!=q-1:\\n        input()\\n    sec = set1&set2\\n    for x,y in sec:\\n        if dic1[(x,y)]==dic2[(x,y)]:\\n            print(\\\"YES\\\")\\n            break\\n    else:\\n        print(\\\"NO\\\")\", \"3\\n\\nn = int(input())\\nfor _ in range(n):\\n    k = []\\n    b = []\\n    for i in range(8):\\n        s = input()\\n        for j in range(8):\\n            if s[j] == 'K':\\n                k.append((i, j))\\n    print('YES' if abs(k[0][0] - k[1][0]) % 4 == 0 and abs(k[0][1] - k[1][1]) % 4 == 0 else 'NO')\\n    if _ < n - 1:\\n        input()\\n\", \"t = int(input())\\nel = [[1,2,3,4,1,2,3,4],[5,6,7,8,5,6,7,8],[9,10,11,12,9,10,11,12],[13,14,15,16,13,14,15,16],[1,2,3,4,1,2,3,4],[5,6,7,8,5,6,7,8],[9,10,11,12,9,10,11,12],[13,14,15,16,13,14,15,16]]\\nfor x in range(t):\\n    arr = [[]for i in range(8)]\\n    for i in range(8):\\n        s = input()\\n        for j in range(len(s)):\\n            arr[i].append(s[j])\\n    l = 0\\n    for i in range(8):\\n        for j in range(8):\\n            if l == 0:\\n                if arr[i][j] == 'K':\\n                    k1 = el[i][j]\\n                    l = 1\\n            else:\\n                if arr[i][j] == 'K':\\n                    k2 = el[i][j]\\n                    break\\n    if k1 == k2:\\n        print('YES')\\n    else:\\n        print('NO')\\n    if x != t-1:\\n        y = list(map(int, input().split()))\", \"N = list(range(8))\\ntest = int (input())\\nfor i_test in range(test):\\n    if (i_test): input()\\n    x1,y1,x2,y2=0,0,0,0\\n    map = [input() for i in N]\\n    for i in N:\\n        for j in N:\\n            if (map[i][j]==\\\"K\\\"): x1,y1,x2,y2 = x2,y2,i,j\\n    if (abs(x1-x2)%4==0 and abs(y1-y2)%4==0): print (\\\"YES\\\")\\n    else: print (\\\"NO\\\")\\n\", \"def solve(m, x,y , w,z):\\n\\tfor i in range(8):\\n\\t\\tfor j in range(8):\\n\\t\\t\\tif m[i][j]:\\n\\t\\t\\t\\ta, pa = movePossible(x,y , i,j)\\n\\t\\t\\t\\tb, pb = movePossible(w,z , i,j)\\n\\t\\t\\t\\tif a and b and pa==pb:\\n\\t\\t\\t\\t\\treturn True\\n\\treturn False\\n\\t\\ndef movePossible(x,y , w,z):\\n\\ta = x-w\\n\\tb = y-z\\n\\tpos=False\\n\\tka=a//2\\n\\tkb=b//2\\n\\tif a%2==0 and b%2==0 and (ka+kb)%2==0:\\n\\t\\tpos=True\\n\\t\\n\\treturn pos, ka%2\\n\\nt = int(input())\\nfor _c in range(t):\\n\\tm = []\\n\\tprimo = True\\n\\tfor i in range(8):\\n\\t\\tm.append([])\\n\\t\\ts = input()\\n\\t\\tk=0\\n\\t\\tfor c in s:\\t\\n\\t\\t\\tif c=='#':\\n\\t\\t\\t\\tm[i].append( False )\\n\\t\\t\\telse:\\n\\t\\t\\t\\tm[i].append( True )\\n\\t\\t\\t\\n\\t\\t\\tif c=='K' and primo:\\n\\t\\t\\t\\tx=i\\n\\t\\t\\t\\ty= k\\n\\t\\t\\t\\tprimo = False\\n\\t\\t\\tif c=='K' and (not primo):\\n\\t\\t\\t\\tw=i\\n\\t\\t\\t\\tz= k\\n\\t\\t\\tk+=1\\n\\t\\n\\tif solve(m, x,y , w,z):\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")\\n\\t\\n\\tif _c!=t-1: m=input()\\n\\t\\n\\t\\n\\t\\n\", \"def f():\\n    t = []\\n    for i in range(8):\\n        p = input()\\n        for j in range(8):\\n            if p[j] == 'K': t += [i, j]\\n    if t[2] - t[0] in (0, 4) and t[1] - t[3] in (-4, 0, 4): return 'YES'\\n    return 'NO'\\nfor i in range(int(input()) - 1):\\n    print(f())\\n    input()\\nprint(f())\", \"def check():\\n    board = []\\n    for cont in range(0,8):\\n        board.append(input())\\n    l = True\\n    for cont in range(0,8):\\n        for cont2 in range(0,8):\\n            if board[cont][cont2] == 'K':\\n                if l:\\n                    xk1 = cont2\\n                    yk1 = cont\\n                    l = False\\n                else:\\n                    xk2 = cont2\\n                    yk2 = cont\\n                    break\\n    for cont in range(0,8):\\n        for cont2 in range(0,8):\\n            if cont2 %2 == xk1%2 == xk2%2:\\n                if cont%2 == yk1%2 == yk2%2:\\n                    if abs(cont2-xk1)%4 == abs(cont2-xk2)%4:\\n                        if abs(cont-yk1)%4 == abs(cont-yk2)%4:\\n                            if board[cont][cont2] != '#':\\n                                print('YES')\\n                                return\\n    print('NO')\\n    return\\n            \\nn = int(input())\\ncheck()\\nfor t in range(0,n-1):\\n    a = str(input())\\n    check()\", \"t = int(input())\\nfor k in range(t):\\n  r8 = range(8)\\n  a = [input() for i in r8]\\n  ij = [(i, j) for i in r8 for j in r8]\\n  x, y = ((i, j) for i, j in ij if a[i][j] == \\\"K\\\")\\n  def s(p):\\n    d = [(p[0] - 2, p[1] - 2), (p[0] + 2, p[1] - 2), (p[0] - 2, p[1] + 2), (p[0] + 2, p[1] + 2)]\\n    return set((i, j) for i, j in ij if (i, j) in d)\\n  print(\\\"YES\\\" if len(s(x) & s(y)) > 0 else \\\"NO\\\")\\n  if k != t - 1:\\n    input()\", \"n = int(input())\\nfor t in range(n):\\n    if t: input()\\n    board = [[c for c in input()] for i in range(8)]\\n    k1, k2 = ((i, j) for i in range(8) for j in range(8) if board[i][j] == 'K')\\n    if (k1[0] - k2[0]) % 4 == 0 and (k1[1] - k2[1]) % 4 == 0:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n\\n\\n\", \"def f():\\n    t = []\\n    for i in range(8):\\n        p = input()\\n        for j in range(8):\\n            if p[j] == 'K': t += [i, j]\\n    if t[2] - t[0] in (0, 4) and t[1] - t[3] in (-4, 0, 4): return 'YES'\\n    return 'NO'\\nfor i in range(int(input()) - 1):\\n    print(f())\\n    input()\\nprint(f())\", \"n = int(input())\\n\\nfor t in range(n):\\n\\n    if t: input()\\n\\n    board = [[c for c in input()] for i in range(8)]\\n\\n    k1, k2 = ((i, j) for i in range(8) for j in range(8) if board[i][j] == 'K')\\n\\n    if (k1[0] - k2[0]) % 4 == 0 and (k1[1] - k2[1]) % 4 == 0:\\n\\n        print('YES')\\n\\n    else:\\n\\n        print('NO')\\n\\n\\n\\n\\n\\n\\n\\n\", \"n = int (input())\\nfor i in range(n):\\n    if (i): \\n        input()\\n    x1 = y1 = x2 = y2 = 0\\n    s = [input() for i in range(8)]\\n    for i in range(8):\\n        for j in range(8):\\n            if (s[i][j] == 'K'):\\n                x1, y1, x2, y2 = x2, y2, i, j\\n    if (abs(x1-x2) % 4 == 0 and abs(y1-y2) % 4 == 0): \\n        print (\\\"YES\\\")\\n    else: \\n        print (\\\"NO\\\")\\n\", \"a = []\\n\\n\\ndef first(i, j):\\n    nonlocal a\\n    a[i][j] = 1\\n    if i - 2 >= 0 and j + 2 < 8:\\n        a[i - 2][j + 2] = 1\\n    if i - 2 >= 0 and j - 2 >= 0:\\n        a[i - 2][j - 2] = 1\\n    if i + 2 < 8 and j + 2 < 8:\\n        a[i + 2][j + 2] = 1\\n    if i + 2 < 8 and j - 2 >= 0:\\n        a[i + 2][j - 2] = 1\\n\\n\\ndef second(i, j):\\n    nonlocal a\\n    if a[i][j] == 1:\\n        return True\\n    if i - 2 >= 0 and j + 2 < 8:\\n        if a[i - 2][j + 2] == 1:\\n            return True\\n    if i - 2 >= 0 and j - 2 >= 0:\\n        if a[i - 2][j - 2] == 1:\\n            return True\\n    if i + 2 < 8 and j + 2 < 8:\\n        if a[i + 2][j + 2] == 1:\\n            return True\\n    if i + 2 < 8 and j - 2 >= 0:\\n        if a[i + 2][j - 2] == 1:\\n            return True\\n    return False\\n\\n\\nt = int(input())\\nfor i in range(t):\\n    a = []\\n    exist = False\\n    for j in range(8):\\n        a.append(list(input()))\\n    d = 0\\n    for j in range(8):\\n        for k in range(8):\\n            if a[j][k] == 'K':\\n                d += 1\\n                if d == 1:\\n                    first(j, k)\\n                elif d == 2:\\n                    if second(j, k):\\n                        exist = True\\n    if exist:\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\\n    if i != t - 1:\\n        input()\\n\", \"for i in range(int(input())):\\n    if i :\\n        input()\\n    ans = []\\n    for i in range(8):\\n        s = input()\\n        for j in range(8):\\n            if s[j] == 'K':\\n                ans.append((i, j))\\n    print(['NO' , 'YES'][abs(ans[0][0] - ans[1][0]) % 4 == 0 and abs(ans[0][1] - ans[1][1]) % 4 == 0])\\n\", \"t = int(input())\\nfor _ in range(t):\\n    s = [input() for i in range(8)]\\n    oh = True\\n    flag = True\\n    for i in range(8):\\n        for j in range(8):\\n            if(s[i][j] == 'K'):\\n                if(flag):\\n                    pos1x = i\\n                    pos1y = j\\n                    flag = False\\n                else:\\n                    pos2x = i\\n                    pos2y = j\\n    if(pos1x % 4 == pos2x % 4) and (pos1y % 4 == pos2y % 4):\\n        print('YES')\\n    else:\\n        print('NO')\\n    if( _ < t - 1):\\n        k = input()\\n\", \"t = int(input())\\nfor _ in range(t):\\n    if _:\\n        input()\\n    knights = []\\n    for i in range(8):\\n        s = input().strip()\\n        for j in range(8):\\n            if s[j] == 'K':\\n                knights.append((i,j))\\n    n1 = knights[0]\\n    n2 = knights[1]\\n    \\\"\\\"\\\"\\n    if n1[0] % 2 == n2[0] % 2 and n1[1] % 2 == n2[1] % 2:\\n        c1 = n1[0]//2 + n1[1]//2\\n        c2 = n2[1]//2 + n2[0]//2\\n        if c1 % 2 == c2 % 2:\\n            print('YES')\\n        else:\\n            print('NO')\\n    \\\"\\\"\\\"\\n    if n1[0] % 4 == n2[0] % 4 and n1[1] % 4 == n2[1] % 4:\\n        print('YES')\\n    else:\\n        print('NO')\\n\", \"t = int(input())\\n\\nfor _ in range(t):\\n    if _ != 0:\\n        tmp = input()\\n        \\n    pos = []\\n    n = 8\\n    g = []\\n    for i in range(n):\\n        g.append([i for i in input()])\\n        \\n    for i in range(n):\\n        for j in range(n):\\n            if g[i][j] == \\\"K\\\":\\n                pos.append((i, j))\\n        \\n    ok = False\\n    for i in range(n):\\n        for j in range(n):\\n            if i%2 == pos[0][0]%2 and i%2 == pos[1][0]%2 and j%2 == pos[0][1]%2 and j%2 == pos[1][1]%2:\\n                dist1 = ((i-pos[0][0]), (j-pos[0][1]))\\n                dist2 = ((i-pos[1][0]), (j-pos[1][1]))\\n                if dist1[0]-dist2[0]%4 == 0 and dist1[1]-dist2[1]%4 == 0:\\n                    ok = True\\n\\n    print(\\\"YES\\\" if ok else \\\"NO\\\")\", \"t = int(input())\\nwhile t:\\n    t += -1\\n    l = []\\n    mp = []\\n    for i in range(8):\\n        tmp = list(input())\\n        l.append(tmp)\\n        mp.append([0] * 8)\\n    i1, j1, i2, j2 = -1, -1, -1, -1\\n    for i in range(8):\\n        for j in range(8):\\n            if l[i][j] == 'K' and i1 == -1: i1, j1 = i, j\\n            if l[i][j] == 'K': i2, j2 = i, j\\n    if abs(i2 - i1) % 4 == 0 and abs(j2 - j1) % 4 == 0: print('YES')\\n    else: print('NO')\\n    if t != 0: input()\"]",
        "difficulty": "interview",
        "input": "3\n........\n........\n..#.....\n..#..#..\n..####..\n...##...\n........\n####K#K#\n\n........\nK......K\n........\n#......#\n.#....#.\n..####..\n........\n........\n\n.#..#...\n.##.##..\n..###...\n..#K###.\n..####..\n......K.\n..#####.\n..#####.\n",
        "output": "NO\nNO\nNO\n",
        "halu_type": "Structural Access Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/362/A",
        "input_output": "{\"inputs\": [\"3\\n........\\n........\\n..#.....\\n..#..#..\\n..####..\\n...##...\\n........\\n####K#K#\\n\\n........\\nK......K\\n........\\n#......#\\n.#....#.\\n..####..\\n........\\n........\\n\\n.#..#...\\n.##.##..\\n..###...\\n..#K###.\\n..####..\\n......K.\\n..#####.\\n..#####.\\n\"], \"outputs\": [\"NO\\nNO\\nNO\\n\"]}",
        "generated_code": "def can_meet(board):\n    # Initialize the positions of the semiknights\n    knight1_pos = None\n    knight2_pos = None\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'K':\n                if knight1_pos is None:\n                    knight1_pos = (i, j)\n                else:\n                    knight2_pos = (i, j)\n\n    # Check if the semiknights can meet\n    if knight1_pos is None or knight2_pos is None:\n        return False\n    else:\n        return can_meet_helper(board, knight1_pos, knight2_pos)\n\ndef can_meet_helper(board, knight1_pos, knight2_pos):\n    # Check if the semiknights are on the same square\n    if knight1_pos == knight2_pos:\n        return True\n\n    # Check if the semiknights can move to the same square\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == '.':\n                if (i, j) == knight1_pos or (i, j) == knight2_pos:\n                    continue\n                if can_move(board, knight1_pos, (i, j)) and can_move(board, knight2_pos, (i, j)):\n                    return True\n\n    return False\n\ndef can_move(board, knight_pos, new_pos):\n    # Check if the new position is on the board\n    if new_pos[0] < 0 or new_pos[0] >= 8 or new_pos[1] < 0 or new_pos[1] >= 8:\n        return False\n\n    # Check if the new position is bad\n    if board[new_pos[0]][new_pos[1]] == '#':\n        return False\n\n    # Check if the new position is the same as the current position\n    if new_pos == knight_pos:\n        return False\n\n    return True\n\n# Test cases\nboard1 = [\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#']\n]\n\nboard2 = [\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#'],\n    ['#', '#', '#', '#', '#', '#', '#', '#']\n]\n\nprint(can_meet(board1))  # Output: YES\nprint(can_meet(board2))  # Output: NO",
        "inout": "{\"inputs\": [\"2\\n....#..K\\n...#....\\n..##.#..\\n.#.#.#..\\n.#.....#\\n.#......\\n###.....\\nK#.#....\\n\\nK.#.....\\n..#...#.\\n#.....#.\\n..#.#..#\\n#.......\\n..#..#..\\n....#...\\nK..##.##\\n\"], \"outputs\": [\"NO\\nNO\\n\"]}"
    },
    "2506": {
        "id": 12,
        "task_id": 2506,
        "test_case_id": 3,
        "question": "Takahashi has come to a party as a special guest.\nThere are N ordinary guests at the party. The i-th ordinary guest has a power of A_i.\nTakahashi has decided to perform M handshakes to increase the happiness of the party (let the current happiness be 0).\nA handshake will be performed as follows:\n - Takahashi chooses one (ordinary) guest x for his left hand and another guest y for his right hand (x and y can be the same).\n - Then, he shakes the left hand of Guest x and the right hand of Guest y simultaneously to increase the happiness by A_x+A_y.\nHowever, Takahashi should not perform the same handshake more than once. Formally, the following condition must hold:\n - Assume that, in the k-th handshake, Takahashi shakes the left hand of Guest x_k and the right hand of Guest y_k. Then, there is no pair p, q (1 \\leq p < q \\leq M) such that (x_p,y_p)=(x_q,y_q).\nWhat is the maximum possible happiness after M handshakes?\n\n-----Constraints-----\n - 1 \\leq N \\leq 10^5\n - 1 \\leq M \\leq N^2\n - 1 \\leq A_i \\leq 10^5\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 A_2 ... A_N\n\n-----Output-----\nPrint the maximum possible happiness after M handshakes.\n\n-----Sample Input-----\n5 3\n10 14 19 34 33\n\n-----Sample Output-----\n202\n\nLet us say that Takahashi performs the following handshakes:\n - In the first handshake, Takahashi shakes the left hand of Guest 4 and the right hand of Guest 4.\n - In the second handshake, Takahashi shakes the left hand of Guest 4 and the right hand of Guest 5.\n - In the third handshake, Takahashi shakes the left hand of Guest 5 and the right hand of Guest 4.\nThen, we will have the happiness of (34+34)+(34+33)+(33+34)=202.\nWe cannot achieve the happiness of 203 or greater, so the answer is 202.",
        "solutions": "[\"import sys\\nimport bisect\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    n, m = list(map(int, input().split()))\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    \\n    l, r = -1, 10**6\\n    while r-l > 1:\\n        k = (r+l)//2\\n        count = 0\\n        for i in range(n):\\n            count += n-bisect.bisect_left(a, k-a[i])\\n        \\n        if count > m:\\n            l = k\\n        else:\\n            r = k\\n    ans = 0\\n    count = 0\\n    b = [0]*(n+1)\\n    for i in range(n):\\n        b[i+1] += b[i]+a[i]\\n    for i in range(n):\\n        index = bisect.bisect_left(a, r-a[i])\\n        ans += b[n]-b[index]+a[i]*(n-index)\\n        count += n-index\\n    \\n    if count < m:\\n        ans += (m-count)*l\\n    \\n    print(ans)\\n    \\n    \\n    \\n    \\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nimport numpy as np\\n\\n# \\u4fa1\\u5024 x \\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u5168\\u3066\\u884c\\u3046\\u3068\\u3059\\u308b\\n# \\u63e1\\u624b\\u56de\\u6570\\u304c\\u6c7a\\u307e\\u308b\\u3002\\u5de6\\u624b\\u3054\\u3068\\u306b\\u96c6\\u8a08\\u3067\\u304d\\u308b\\u3002\\n\\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\\nA = np.array(sys.stdin.readline().rstrip().split(), np.int64)\\n\\nA.sort()  # A \\u3092\\u6607\\u9806\\u306b\\u4e26\\u3073\\u66ff\\u3048\\u308b\\n\\n# x \\u3088\\u308a\\u4fa1\\u5024\\u304c\\u9ad8\\u304f\\u306a\\u308b\\u63e1\\u624b\\u306e\\u7dcf\\u6570\\n#  -> a \\u306b\\u5bfe\\u3057\\u3066\\u3001\\u76f8\\u624b\\u306f x - a \\u304c\\u5fc5\\u8981\\n#   -> A = [a0, a1, a2, ...] \\u306b\\u5bfe\\u3057\\u3066\\u3001[x-a0\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e, x-a1\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e, x-a2\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e,...] \\u3092\\u63a2\\u3059\\ndef shake_cnt(x):\\n    # x \\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u5168\\u3066\\u884c\\u3046\\u3068\\u3057\\u3066\\u3001\\u63e1\\u624b\\u306e\\u56de\\u6570\\u3092\\u6570\\u3048\\u308b\\u884c\\u308f\\u306a\\u3044\\u63e1\\u624b\\u3092\\u6570\\u3048\\u308b\\n    X = np.searchsorted(A, x - A)  # \\u30bd\\u30fc\\u30c8\\u3055\\u308c\\u305f\\u30ea\\u30b9\\u30c8A \\u306b\\u5bfe\\u3057\\u3066\\u3001x - A \\u304c\\u633f\\u5165\\u3055\\u308c\\u308b\\u4f4d\\u7f6e\\u3092\\u8fd4\\u3059\\n    return N * N - X.sum()  # index \\u306e\\u548c\\u306f\\u300c\\u5c0f\\u3055\\u3044\\u65b9\\u300d\\u3092\\u6307\\u3057\\u3066\\u3044\\u308b\\u306e\\u3067\\u3001\\u5f15\\u304f\\n\\n\\n# \\u4e8c\\u5206\\u63a2\\u7d22  \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304c\\nleft = 0  # \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304cM\\u4ee5\\u4e0a\\nright = 10 ** 6  # \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304cM\\u672a\\u6e80 <- \\u307e\\u3060\\u8db3\\u308a\\u306a\\u3044\\u5074\\nwhile 1 < right - left:  # left \\u3068 right \\u304c\\u96a3\\u308a\\u5408\\u3063\\u305f\\u3089\\u7d42\\u4e86\\n    x = (left + right) // 2\\n    if shake_cnt(x) >= M:\\n        left = x\\n    else:\\n        right = x\\n\\n# M\\u56de\\u306b\\u306f\\u5c4a\\u304b\\u306a\\u3044\\u3051\\u308c\\u3069\\u3001M\\u56de\\u306b\\u9650\\u308a\\u306a\\u304f\\u8fd1\\u304f\\u306a\\u308b\\u4fa1\\u5024 x = right\\nX = np.searchsorted(A, right - A)  # \\u5404a in A \\u304c\\u63e1\\u624b\\u3092\\u884c\\u308f\\u306a\\u3044\\u4eba\\u6570\\u306eArray\\nshake = N * N - X.sum()  # \\u3053\\u3053\\u307e\\u3067\\u306e\\u63e1\\u624b\\u56de\\u6570\\n\\nAcum = np.zeros(N + 1, np.int64)  # \\u4eba\\u6570 -> \\u7d2f\\u7a4d\\u548c\\n# Acum = [a0, a0+a1, a0+a1+a2, ....] \\u3092\\u8a08\\u7b97\\u3057\\u3066\\u3001ai \\u3055\\u3093\\u304c k\\u756a\\u76ee\\u4ee5\\u964d\\u3068\\u63e1\\u624b\\u3092\\u3059\\u308c\\u3070\\nAcum[1:] = np.cumsum(A)  # cumsum [1,2,3,4,5,6,...] -> [1,3,6,10,15,21,...]\\n\\n# \\u53f3\\u624b\\u306e\\u5e78\\u798f\\u5ea6\\u306f ai * ((a0+a1+...a(n-1)) - (a(k-1)+...+a(n-1))) \\u3092\\u5f97\\u3089\\u308c\\u308b\\n# \\u5de6\\u624b\\u306e\\u5e78\\u798f\\u5ea6\\u306f \\u56de\\u6570\\u3060\\u3051\\u3067\\u6c7a\\u307e\\u308b\\uff08\\u4f55\\u4eba\\u3068\\u63e1\\u624b\\u3068\\u3059\\u308b\\u304b\\uff09\\nhappy = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\\n\\nhappy += (M - shake) * left  # \\u4e0d\\u8db3\\u5206\\u30021\\u56de\\u306e\\u4fa1\\u5024\\u306f M \\u3068\\u308f\\u304b\\u3063\\u3066\\u3044\\u308b\\n\\nprint(happy)\\n\", \"n,m=map(int,input().split())\\na=list(map(int,input().split()))\\nfor i in range(n):a[i]*=-1\\na.sort()\\nfrom bisect import bisect_left,bisect_right\\ndef check(mid):\\n  mm=0\\n  for i in range(n):\\n    if -(a[i]+a[0])<mid:break\\n    mm+=bisect_right(a,-(mid+a[i]))\\n  return mm\\nok=0\\nng=10**10+7\\nwhile ng!=ok+1:\\n  mid=(ok+ng)//2\\n  if check(mid)>=m:ok=mid\\n  else:ng=mid\\nb=[0]\\nfor i in a:b.append(b[-1]+i)\\nans=0\\nfor i in range(n):\\n  if -(a[i]+a[0])<ok:break\\n  ind=bisect_right(a,-(ok+a[i]))\\n  ans+=a[i]*ind\\n  ans+=b[ind]\\nprint(-(ans+(check(ok)-m)*ok))\", \"from bisect import bisect_left, bisect_right\\nfrom itertools import accumulate\\n\\n\\ndef ge_m(x, m, n):\\n    total = 0\\n    for v in a:\\n        delta = x - v\\n        idx = bisect_left(a, delta)\\n        total += (n - idx)\\n    return total >= m\\n\\n\\nn, m = map(int, input().split())\\na = list(map(int, input().split()))\\n\\na.sort()\\ncum = [0] + list(accumulate(a))  # \\u7d2f\\u7a4d\\u548c\\n\\n# 1\\u56de\\u306e\\u63e1\\u624b\\u3067\\u3042\\u304c\\u308b\\u5e78\\u798f\\u5ea6\\u306e\\u3046\\u3061\\u3001\\u6700\\u3082\\u4f4e\\u3044\\u3082\\u306e\\u3092\\u6c42\\u3081\\u308b\\nl = 0\\nr = a[-1] * 2 + 1\\nwhile r - l > 1:\\n    mid = (l + r) // 2\\n    if ge_m(mid, m, n):\\n        l = mid\\n    else:\\n        r = mid\\n\\n# \\u6700\\u3082\\u4f4e\\u3044\\u5e78\\u798f\\u5ea6\\u3088\\u308a\\u3082\\u5927\\u304d\\u3044\\u5024\\u3092\\u8db3\\u3059\\nnum = 0  # \\u63e1\\u624b\\u306e\\u56de\\u6570\\nans = 0\\nfor v in a:\\n    idx = bisect_right(a, l - v)\\n    num += n - idx\\n    ans += v * (n - idx) + (cum[-1] - cum[idx])\\n# \\u8db3\\u308a\\u306a\\u3044\\u63e1\\u624b\\u306e\\u56de\\u6570\\u5206\\u3001\\u6700\\u3082\\u4f4e\\u3044\\u5e78\\u798f\\u5ea6\\u3092\\u8db3\\u3059\\nans += (l * (m - num))\\nprint(ans)\", \"import numpy as np\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N,M = list(map(int, input().split()))\\n    A = np.array(sorted([int(i) for i in input().split()]))\\n\\n    left = 0\\n    right = A[-1] * 2 + 5\\n    while right - left > 1:\\n        x = (left + right) // 2\\n\\n        count = N**2 - np.searchsorted(A, x-A).sum()\\n\\n        if count >= M:\\n            left = x\\n        else:\\n            right = x\\n\\n    bound = np.searchsorted(A, left-A)\\n    count = N**2 - bound.sum()\\n    diff = count - M\\n    ans = ((N - bound) * A * 2).sum() - diff * left\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import bisect\\nfrom itertools import accumulate\\n\\n\\nN, M = list(map(int, input().split()))\\nA = sorted(map(int, input().split()))\\n\\nS = [0] + list(accumulate(A))\\n\\n\\ndef calc(x):\\n    _total = 0\\n    _num = 0\\n    for i in range(N):\\n        j = bisect.bisect_left(A, x - A[i])\\n        _num += N - j\\n        _total += S[N] - S[j]\\n        _total += A[i] * (N - j)\\n    return _total, _num\\n\\n\\nleft = 0\\nright = 200005\\n\\nwhile right - left > 1:\\n    center = (left + right) // 2\\n    if calc(center)[1] >= M:\\n        left = center\\n    else:\\n        right = center\\n\\ntotal, num = calc(left)\\nans = total\\nans -= (num - M) * left\\nprint(ans)\\n\", \"import bisect\\nimport copy\\n\\nn, m = map(int,input().split())\\na = list(map(int,input().split()))\\n\\na.sort()\\nasum = [0]\\ntmp = 0\\nfor i in range(n):\\n    tmp += a[i] \\n    asum.append(tmp)\\n\\nlb = 1\\nub = 2*10**5 + 1\\nwhile ub - lb > 1:\\n    cx = (ub+lb)//2\\n    cnt = 0\\n    total = 0\\n    for ca in a:\\n        cy = cx - ca\\n        ci = bisect.bisect_left(a, cy)\\n        cnt += n - ci\\n        total += asum[n] - asum[ci] + (n - ci) * ca\\n    if cnt >= m:\\n        lb = cx\\n        ans = copy.deepcopy(total) - (cnt - m) * cx\\n    else:\\n        ub = cx\\n\\nprint(ans)\", \"from bisect import bisect_left\\n\\nN, M = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\n\\nA.sort()\\n\\ndef isOverEq(n):\\n    cnt = 0\\n    for a in A:\\n        cnt += N - bisect_left(A, n - a)\\n    return cnt >= M\\n\\noverEq = -1\\nless = 10**7\\nwhile less - overEq > 1:\\n    mid = (less + overEq) // 2\\n    if isOverEq(mid):\\n        overEq = mid\\n    else:\\n        less = mid\\n\\naccA = [0] * (N + 1)\\nfor i, a in enumerate(A, start=1):\\n    accA[i] = accA[i - 1] + a\\n\\nans = 0\\ncnt = 0\\nfor a in A:\\n    i = bisect_left(A, overEq - a)\\n    ans += accA[N] - accA[i]\\n    ans += (N - i) * a\\n    cnt += N - i\\n\\nans -= max(0, cnt - M) * overEq\\nprint(ans)\\n\", \"import sys\\nfrom bisect import bisect_right, bisect_left\\nfrom itertools import accumulate\\n\\nsys.setrecursionlimit(10 ** 7)\\ninput = sys.stdin.readline\\nf_inf = float('inf')\\nmod = 10 ** 9 + 7\\n\\n\\ndef resolve():\\n    def meguru_bisect(ok, ng):\\n        while abs(ok - ng) > 1:\\n            mid = (ok + ng) // 2\\n            if is_ok(mid):\\n                ok = mid\\n            else:\\n                ng = mid\\n        return ok\\n\\n    def is_ok(x):\\n        cnt = 0\\n        for a in A:\\n            t = x - a\\n            idx = bisect_right(A, t)\\n            cnt += n - idx\\n        return cnt < m\\n\\n    n, m = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    A.sort()\\n    ng, ok = 0, 10 ** 15 + 1\\n    mth = meguru_bisect(ok, ng)\\n    R = [0] + list(accumulate(A))\\n\\n    res = 0\\n    cnt = 0\\n    for a in A:\\n        s = mth - a\\n        left = bisect_left(A, s)\\n        res += (n - left) * a + R[-1] - R[left]\\n        cnt += n - left\\n    print((res - mth * (cnt - m)))\\n\\n\\ndef __starting_point():\\n    resolve()\\n\\n__starting_point()\", \"\\n8\\n9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\nfrom bisect import bisect_left\\nfrom itertools import accumulate\\n \\nN,M = map(int,input().split())\\nA = sorted(list(map(int,input().split())))\\nA_r = list(reversed(A))\\nB = [0] + list(accumulate(A_r))\\n \\ndef func(x):\\n    count = 0\\n    for Ai in A:\\n        idx = bisect_left(A,x-Ai)\\n        count += N-idx\\n    if count >= M:\\n        return True\\n    else:\\n        return False\\n \\nMIN = 0\\nMAX = 2*10**5+1\\nwhile MAX-MIN > 1:\\n    MID = (MIN+MAX)//2\\n    if func(MID):\\n        MIN = MID\\n    else:\\n        MAX = MID\\n \\nans = 0\\ncount = 0\\n \\nfor Ai in A_r:\\n    idx = bisect_left(A,MIN-Ai)\\n    ans += Ai*(N-idx) + B[N-idx]\\n    count += N-idx\\nprint(ans-(count-M)*MIN)\", \"def main():\\n    import bisect\\n    import numpy as np\\n    n,k = map(int,input().split())\\n    l = list(map(int,input().split()))\\n    l.sort()\\n    l1 = np.array(l)\\n    def bise(x):\\n        y = np.searchsorted(l1,x-l1)\\n        return n*n-y.sum()\\n\\n    left = -1\\n    right = l[-1]*2+1\\n\\n    while right > left+1:\\n        mid = (right+left)//2\\n        \\n        if bise(mid) >= k:\\n            left = mid\\n        else:\\n            right = mid\\n    ans = 0\\n    count = 0\\n    acc = [0]\\n    for i in l:\\n        acc.append(acc[-1]+i)\\n    for i in l:\\n        index = bisect.bisect_left(l,right-i)\\n        ans += i*(n-index) + acc[n]-acc[index]\\n        count += n-index\\n\\n    print(ans-(count-k)*left)\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"def main():\\n    N, M = list(map(int, input().split()))\\n    A = sorted(list(map(int, input().split())), reverse=True)\\n    def helper(x):\\n        p = len(A) - 1\\n        t = 0\\n        for a in A:\\n            while p >= 0 and A[p] + a < x:\\n                p -= 1\\n            t += p + 1\\n        return t\\n    l, r = 0, A[0] * 2 + 1\\n    while r - l > 1:\\n        m = (l + r) // 2\\n        if helper(m) > M:\\n            l = m\\n        else:\\n            r = m\\n    k = sum(A)\\n    p = len(A) - 1\\n    t = (M - helper(l)) * l\\n    for a in A:\\n        while p >= 0 and A[p] + a < l:\\n            k -= A[p]\\n            p -= 1\\n        t += a * (p + 1) + k\\n    print(t)\\n\\nmain()\\n\", \"import numpy as np\\nfrom numpy.fft import rfft,irfft\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\ndef mi(): return map(int,input().split())\\ndef ii(): return int(input())\\ndef isp(): return input().split()\\ndef deb(text): print(\\\"-------\\\\n{}\\\\n-------\\\".format(text))\\n\\nINF=10**20\\nclass Counter:\\n    def __init__(self):\\n        self.dict = {}\\n\\n    def add(self,x):\\n        if x in self.dict: self.dict[x] += 1\\n        else: self.dict[x] = 1\\n\\n    def decrement(self,x):\\n        self.dict[x] -= 1\\n        if self.dict[x] <= 0:\\n            del self.dict[x]\\n\\n    def get_dict(self):\\n        return self.dict\\n\\n\\n\\n\\ndef fft(A,B,fft_len=2*10**5):\\n    x = irfft(rfft(A,fft_len) * rfft(B,fft_len))+0.5\\n    return x.astype(int)\\n\\n\\ndef main():\\n    N,M=mi()\\n    A=list(mi())\\n\\n    counter = Counter()\\n    for a in A: \\n        counter.add(a)\\n    \\n    count_map = counter.get_dict()\\n    F=[0]*2*10**5\\n    for a,count in count_map.items():\\n        F[a] = count\\n    \\n    G = fft(F,F,fft_len=1<<18)\\n\\n    ans = 0\\n    handshake = M\\n    for x in range(len(G)-1,1,-1):\\n        if G[x] <= 0: continue\\n        count = G[x]\\n        if count > handshake:\\n            ans += handshake * x\\n        else:\\n            ans += count * x\\n\\n        handshake = max(handshake-count,0)\\n        if handshake == 0:\\n            break\\n\\n    print(ans)\\n\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"#python3\\nfrom bisect import bisect_left\\nINF = int(1e9)\\n\\ndef main():\\n    n, m = list(map(int, input().split()))\\n    a = [int(i) for i in input().split()]\\n    a.sort()\\n    ac = [0]\\n    for i in range(n):\\n        ac.append(ac[i]+a[i])\\n\\n    def chk(x):\\n        cnt = 0\\n        for i in range(n):\\n            pos = bisect_left(a, x - a[i])\\n            cnt += (n-pos)\\n        return (cnt < m)\\n\\n    l = 0\\n    r = INF\\n    while r-l > 1: \\n        mid = (l + r)//2\\n        if chk(mid):\\n            r = mid\\n        else:\\n            l = mid\\n\\n    cnt = 0\\n    sgm = 0\\n    for i in range(n):\\n        pos = bisect_left(a, r - a[i])\\n        cnt += (n-pos) \\n        sgm += a[i] * (n-pos) + (ac[n] - ac[pos]) \\n\\n    print((sgm+(m-cnt)*l))\\nmain()\\n\", \"import numpy as np\\n\\nn, m = map(int,input().split())\\na = list(map(int,input().split()))\\n\\na.sort()\\nna = np.zeros(2**18)\\nfor i in a:\\n    na[i] += 1\\n\\nfa = np.fft.fft(na)\\n\\nc = np.round(np.fft.ifft(fa*fa)).astype(int)\\n\\nans = 0\\ncm = 0\\nfor i in range(2**18 - 1, 1, -1):\\n    cm += c[i]\\n    ans += i*c[i]\\n    if cm > m:\\n        ans -= i * (cm - m)\\n    if cm >= m:\\n        break\\n\\nprint(ans)\", \"import sys\\nreadline = sys.stdin.readline\\n\\nN,M = list(map(int,readline().split()))\\nA = sorted(list(map(int,readline().split())))\\n\\nsumA = [0] + A.copy()\\nfor i in range(1,len(sumA)):\\n  sumA[i] += sumA[i - 1]\\n  \\n# \\u5de6\\u624b34,33,19,14,10\\n# \\u53f3\\u624b34,33,19,14,10\\n# X\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u3067\\u304d\\u308b\\u7d44\\u3060\\u3051\\u63a1\\u7528\\u3059\\u308b\\n# \\u4f8b\\uff1a50\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u3067\\u304d\\u308b\\u306e\\u306f\\u3001\\n# \\u5de6\\u624b34\\u306b\\u5bfe\\u3057\\u3066\\u306f34,33,19\\n# \\u53f3\\u624b33\\u306b\\u5bfe\\u3057\\u3066\\u306f34,33,19\\n# \\u3053\\u306e\\u5408\\u8a08\\u304cM\\u56de\\u3092\\u8d8a\\u3048\\u308b\\u3068\\u63a1\\u7528\\u3067\\u304d\\u306a\\u3044\\u3002\\n# M\\u56de\\u3092\\u4e0b\\u56de\\u308b\\u5834\\u5408\\u306f\\u3001\\u3059\\u3079\\u3066\\u306e\\u63e1\\u624b\\u306e\\u5408\\u8a08\\u3067\\u6700\\u5927\\u5024\\u3092\\u66f4\\u65b0\\n\\nok = -1\\nng = 10 ** 5 * 2 + 1\\n\\nimport bisect\\ndef isOk(x):\\n  # x\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3060\\u3051\\u63a1\\u7528\\u3059\\u308b\\u3068\\u304d\\u3001\\u63a1\\u7528\\u3067\\u304d\\u308b\\u5834\\u5408\\u306b\\u5168\\u4f53\\u306e\\u5408\\u8a08\\u70b9\\u306f\\u3044\\u304f\\u3064\\u306b\\u306a\\u308b\\u304b\\n  cnt = 0\\n  for left in A:\\n    right = x - left\\n    ind = bisect.bisect_left(A, right)\\n    cnt += N - ind\\n  if cnt > M:\\n    return True\\n  else:\\n    return False\\n\\nwhile abs(ng - ok) > 1:\\n  mid = abs(ng + ok) // 2\\n  if isOk(mid):\\n    ok = mid\\n  else:\\n    ng = mid\\n    \\n# ok\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3060\\u3051\\u8a31\\u5bb9\\u3059\\u308b\\u5834\\u5408\\u306e\\u70b9\\u6570\\u3092\\u7b97\\u51fa\\nans = 0\\nnum = 0\\nfor left in A:\\n  right = ok - left\\n  ind = bisect.bisect_left(A, right)\\n  ans += sumA[-1] - sumA[ind] + (N - ind) * left\\n  num += N - ind\\n\\nif num > M:\\n  ans -= (num - M) * ok\\n\\nprint(ans)\\n\", \"N, M = (int(i) for i in input().split())\\nA = [int(i) for i in input().split()]\\nA.sort(reverse=True)\\nAs = [0]*(N+1)\\nfor i in range(N):\\n    As[i+1] = As[i] + A[i]\\nA.reverse()\\n\\nimport bisect\\n\\ndef flag(x):\\n    ans = 0\\n    for i in range(N):\\n        a = x - A[i]\\n        res = bisect.bisect_left(A, a)\\n        ans += (N-res)\\n    return bool(ans >= M)\\n\\ndef an(x):\\n    ans = 0\\n    m = 0\\n    for i in range(N):\\n        a = x - A[i]\\n        res = bisect.bisect_left(A, a)\\n        m += (N-res)\\n        ans += As[N-res]\\n        ans += A[i] * (N-res)\\n    ans -= (m - M) * x\\n    return ans\\n\\n\\nlow = 0\\nhigh = 10**6\\n\\nwhile low <= high:\\n    mid = (low + high) // 2\\n    if flag(mid):\\n        if not flag(mid+1):\\n            ans = mid\\n            break\\n        else:\\n            low = mid + 1\\n    else:\\n        high = mid - 1\\n\\nprint(an(ans))\", \"import sys,collections as cl,bisect as bs\\nsys.setrecursionlimit(100000)\\ninput = sys.stdin.readline\\nmod = 10**9+7\\nMax = sys.maxsize\\ndef l(): #int\\u306elist\\n    return list(map(int,input().split()))\\ndef m(): #\\u8907\\u6570\\u6587\\u5b57\\n    return list(map(int,input().split()))\\ndef onem(): #N\\u3068\\u304b\\u306e\\u53d6\\u5f97\\n    return int(input())\\ndef s(x): #\\u5727\\u7e2e\\n    a = []\\n    if len(x) == 0:\\n        return []\\n    aa = x[0]\\n    su = 1\\n    for i in range(len(x)-1):\\n        if aa != x[i+1]:\\n            a.append([aa,su])\\n            aa = x[i+1]\\n            su = 1\\n        else:\\n            su += 1\\n    a.append([aa,su])\\n    return a\\ndef jo(x): #list\\u3092\\u30b9\\u30da\\u30fc\\u30b9\\u3054\\u3068\\u306b\\u5206\\u3051\\u308b\\n    return \\\" \\\".join(map(str,x))\\ndef max2(x): #\\u4ed6\\u306e\\u3068\\u304d\\u3082\\u3069\\u3046\\u3088\\u3046\\u306b\\u4f5c\\u6210\\u53ef\\u80fd\\n    return max(list(map(max,x)))\\ndef In(x,a): #a\\u304c\\u30ea\\u30b9\\u30c8(sorted)\\n    k = bs.bisect_left(a,x)\\n    if k != len(a) and a[k] ==  x:\\n        return True\\n    else:\\n        return False\\n\\ndef pow_k(x, n):\\n    ans = 1\\n    while n:\\n        if n % 2:\\n            ans *= x\\n        x *= x\\n        n >>= 1\\n    return ans\\n\\n\\n\\n\\n\\n\\nN,M = m()\\n\\na = l()\\n\\na.sort()\\n\\naaa = s(a)\\n\\n\\n\\npo = [0 for i in range(10**5+1)]\\nans = 0\\nfor i in range(N):\\n    po[a[i]] += 1\\nfor i in range(10**5-1,-1,-1):\\n    po[i] += po[i+1]\\nll = 0\\nrr = 10**5 * 2\\n\\nwhile True:\\n    mid = (ll+rr)//2\\n    if mid == ll:\\n        co = 0\\n        for i in range(N):\\n            ui = a[i]\\n            if mid > ui + 10**5:\\n                continue\\n            elif ui >= mid:\\n                co += N\\n            else:\\n                co += po[mid-ui]\\n        cco = 0\\n        mid = rr\\n\\n        for i in range(N):\\n            ui = a[i]\\n            if mid > ui + 10**5:\\n                continue\\n            elif ui >= mid:\\n                cco += N\\n            else:\\n                cco += po[mid-ui]\\n        \\n        \\n\\n        if co == cco:\\n            mid = rr\\n\\n        elif cco == M:\\n            mid = rr\\n            co=cco\\n\\n        else:\\n            mid = ll\\n\\n        break\\n\\n    co = 0\\n    for i in range(N):\\n        ui = a[i]\\n        if mid > ui + 10**5:\\n            continue\\n        elif ui >= mid:\\n            co += N\\n        else:\\n            co += po[mid-ui]\\n    \\n    if co < M:\\n        rr = mid                 \\n    else:\\n        ll = mid\\n\\n\\na.sort(reverse = True)\\ndp = [0]\\n\\nans -= mid * (co - M)\\n\\n\\n\\nfor i in range(N):\\n    dp.append(dp[-1]+a[i])\\n\\nfor i in range(N):\\n    pl = a[i]\\n    if pl >= mid:\\n        ans += pl*N + dp[-1]\\n        \\n    elif pl + 10**5 < mid:\\n        continue\\n    else:\\n        ans += pl*po[mid-pl] + dp[po[mid-pl]]\\nprint(ans)\\n\\n\\n\\n\", \"from itertools import accumulate\\nfrom bisect import bisect_left\\n\\nn, m = list(map(int, input().split()))\\na = sorted(map(int, input().split()))\\ncs = [0] + list(accumulate(a))\\nc = 0\\ns = 0\\n\\n\\ndef f(x):\\n    nonlocal c, s\\n    c = 0\\n    s = 0\\n    for i in range(n):\\n        left = bisect_left(a, x - a[i])\\n        c += n - left\\n        s += cs[n] - cs[left] + (n - left) * a[i]\\n    return c\\n\\n\\nok = 0\\nng = 2 * 10 ** 5 + 1\\nwhile abs(ok - ng) > 1:\\n    x = (ok + ng) // 2\\n    if f(x) >= m:\\n        ok = x\\n    else:\\n        ng = x\\n\\nprint((s - (c - m) * ok))\\n\", \"from bisect import bisect_left\\nn, m = map(int, input().split())\\nimport math\\nimport numpy as np\\nimport decimal\\nimport collections\\nimport itertools\\nimport sys\\ndef find(x):\\n    if par[x] < 0:\\n        return x\\n    else:\\n        par[x] = find(par[x])\\n        return par[x]\\ndef unite(x, y):\\n    p = find(x)\\n    q = find(y)\\n    if p == q:\\n        return None\\n    if p > q:\\n        p,q = q,p\\n    par[p] += par[q]\\n    par[q] = p\\ndef same(x, y):\\n    return find(x) == find(y)\\ndef size(x):\\n    return -par[find(x)]\\npar = [-1 for i in range(n)]\\ndef prime_numbers(x):\\n    if x < 2:\\n        return []\\n    prime_numbers = [i for i in range(x)]\\n    prime_numbers[1] = 0\\n    for prime_number in prime_numbers:\\n        if prime_number > math.sqrt(x):\\n            break\\n        if prime_number == 0:\\n            continue\\n        for composite_number in range(2 * prime_number, x, prime_number):\\n            prime_numbers[composite_number] = 0\\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\\ndef is_prime(x):\\n    if x < 2:\\n        return False\\n    if x == 2 or x == 3 or x == 5:\\n        return True\\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\\n        return False\\n    prime_number = 7\\n    difference = 4\\n    while prime_number <= math.sqrt(x):\\n        if x % prime_number == 0:\\n            return False\\n        prime_number += difference\\n        difference = 6 - difference\\n    return True\\nBIT = [0] * (n + 1)\\ndef add(i, x):\\n    while i <= n:\\n        BIT[i] += x\\n        i += i & -i\\ndef query(i):\\n    s = 0\\n    while i > 0:\\n        s += BIT[i]\\n        i -= i & -i\\n    return s\\na = list(map(int, input().split()))\\na.sort(reverse=True)\\nl, r = 0, 10 ** 6\\nwhile r - l > 1:\\n    m2 = (l + r) // 2\\n    cnt = 0\\n    ind = n - 1\\n    for i in a:\\n        while ind >= 0 and a[ind] + i < m2:\\n            ind -= 1\\n        cnt += ind + 1\\n    if cnt >= m:\\n        l = m2\\n    else:\\n        r = m2\\ncum = [0]\\nfor i in a:\\n    cum.append(cum[-1] + i)\\nans = 0\\ncnt2 = 0\\nind2 = n - 1\\nb = l\\nfor i in a:\\n    while ind2 >= 0 and a[ind2] + i < b:\\n        ind2 -= 1\\n    cnt2 += ind2 + 1\\n    ans += (ind2 + 1) * i + cum[ind2 + 1]\\nprint(ans - (cnt2 - m) * b)\", \"import sys\\ninput = sys.stdin.readline\\n\\nN, M = map(int, input().split())\\nA = list(map(int, input().split()))\\n\\nA.sort(reverse=True)\\nl = 0\\nr = 3*10**5\\nwhile r - l > 1:\\n    m = (r + l)//2 # \\u548c\\u304cm\\u4ee5\\u4e0a\\u306b\\u306a\\u308b\\u30da\\u30a2\\u306f\\u3044\\u304f\\u3064\\uff1f\\n    ind = N-1\\n    cnt = 0\\n    for a in A:\\n        while ind >= 0 and A[ind] + a < m:\\n            ind -= 1\\n        cnt += ind+1\\n    if cnt >= M:\\n        l = m\\n    else:\\n        r = m\\n\\nB = [0]\\nfor a in A:\\n    B.append(B[-1]+a)\\n\\nans = 0\\nborder = l\\nind = N-1\\ncnt = 0\\nfor a in A:\\n    while ind >= 0 and A[ind] + a < border:\\n        ind -= 1\\n    cnt += (ind+1)\\n    ans += a*(ind+1) + B[ind+1]\\n\\nans -= (cnt-M)*border\\n\\nprint(ans)\", \"def main():\\n    import numpy as np\\n    n,m=map(int,input().split())\\n    A=list(map(int,input().split()))\\n    A.sort()\\n    A=np.array(A)\\n\\n    def cnt_shake(x): #\\u63e1\\u624b\\u306e\\u7d44\\u3067\\u3042\\u3063\\u3066\\u5408\\u8a08\\u30d1\\u30ef\\u30fc\\u304cx\\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u7d44\\u307f\\u306e\\u6570\\n        return n**2-np.searchsorted(A,x-A).sum()\\n  \\n    right=2*(10**5)+1\\n    left=-1\\n    while right-left>1:\\n        mid=(left+right)//2\\n        if cnt_shake(mid)<m:\\n            right=mid\\n        else:\\n            left=mid\\n    \\n    C=n-np.searchsorted(A,right-A)\\n    B=np.cumsum(A[::-1])\\n    cnt=C.sum()\\n    print(np.sum(A*C)+left*(m-cnt)+B[C[np.where(C>0)]-1].sum())\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\nfrom itertools import accumulate\\nfrom bisect import bisect_left\\n\\nn, m, *a = list(map(int, sys.stdin.read().split()))\\na.sort()\\n\\n\\ndef f(x):\\n    # \\u5e78\\u798f\\u5ea6\\u304cx\\u672a\\u6e80\\u3068\\u306a\\u308b\\u7d44\\u307f\\u5408\\u308f\\u305b\\u306e\\u500b\\u6570\\u3092\\u6570\\u3048\\u308b\\n    cnt = 0\\n    for ai in a:\\n        cnt += bisect_left(a, x-ai)\\n    # \\u5e78\\u798f\\u5ea6\\u304cx\\u4ee5\\u4e0a\\u306e\\u7d44\\u307f\\u5408\\u308f\\u305b\\u306e\\u500b\\u6570\\u304cm\\u672a\\u6e80\\u304b\\u3069\\u3046\\u304b\\n    return n * n - cnt < m\\n\\n\\nleft = a[0] * 2\\nright = a[-1] * 2\\nwhile right - left > 1:\\n    mid = (right + left) // 2\\n    if f(mid):\\n        right = mid\\n    else:\\n        left = mid\\nans = 0\\ncumsum = [0] + list(accumulate(a))\\nj = 0\\nfor ai in a:\\n    i = bisect_left(a, left-ai)\\n    j += n - i\\n    ans += ai * (n - i) + cumsum[-1] - cumsum[i]\\nans += (m - j) * left\\nprint(ans)\\n\", \"# \\u904e\\u53bb\\u306e\\u63d0\\u51fa\\u3092\\u898b\\u306a\\u304c\\u3089\\u89e3\\u3044\\u305f\\n\\ndef main():\\n    N, M = list(map(int, input().split()))\\n    *a, = list(map(int, input().split()))\\n    a.sort()\\n\\n    def count(mid) -> int:\\n        cnt = 0  # (i,j)>=mid \\u306e\\u500b\\u6570\\n        j = N  # j: i\\u3068\\u7d44\\u3093\\u3067\\u30da\\u30a2\\u548c>=mid\\u3092\\u6e80\\u305f\\u3059j\\u306e\\u4e0b\\u9650, \\u521d\\u671f\\u5024\\u306f\\u7bc4\\u56f2\\u5916=\\u6761\\u4ef6\\u3092\\u6e80\\u305f\\u3059j\\u306f\\u306a\\u3044\\n        for i in range(N):\\n            while j > 0 and a[i] + a[j - 1] >= mid:\\n                j -= 1\\n            # j==0 or a[i]+a[j]>=mid\\n            # j==0\\n            # \\u73fe\\u5728\\u306ei\\u306b\\u5bfe\\u3057\\u3059\\u3079\\u3066\\u306ea\\u306e\\u8981\\u7d20\\u304c\\u76f8\\u65b9\\u306b\\u306a\\u308b\\u3002\\n            # \\u4e00\\u5ea6\\u305d\\u306e\\u3088\\u3046\\u306ai\\u306b\\u9054\\u3057\\u305f\\u3089\\u3001\\u305d\\u308c\\u4ee5\\u964d\\u306ei\\u306f\\u3059\\u3079\\u3066\\u3053\\u306e\\u6761\\u4ef6\\u3092\\u6e80\\u305f\\u3059\\u3002\\n            cnt += N - j  # i\\u306b\\u5bfe\\u3057[j,N)\\u304c\\u76f8\\u65b9\\u306b\\u306a\\u308b\\n        return cnt\\n\\n    def binary_search(*, ok: int, ng: int, is_ok: 'function') -> int:\\n        \\\"\\\"\\\"\\u3042\\u308b\\u30da\\u30a2\\u548c\\u4ee5\\u4e0a\\u306e\\u307f\\u63a1\\u7528\\u3059\\u308b\\u5834\\u5408\\u306b\\n        M\\u56de\\u4ee5\\u4e0a\\u63e1\\u624b\\u3067\\u304d\\u306a\\u3044\\u3088\\u3046\\u306a\\u30da\\u30a2\\u548c\\u306e\\u4e0a\\u9650\\\"\\\"\\\"\\n        while abs(ok - ng) > 1:\\n            mid = (ok + ng) // 2\\n            if is_ok(mid):\\n                ok = mid\\n            else:\\n                ng = mid\\n        return ok\\n\\n    ma = binary_search(ok=2 * 10 ** 5 + 1, ng=0, is_ok=lambda mid: count(mid) < M)\\n\\n    def accumulate(a):\\n        s = 0\\n        yield s\\n        for x in a:\\n            s += x\\n            yield s\\n\\n    *acc, = accumulate(a)\\n\\n    ans = 0\\n    j = N  # j: i\\u3068\\u7d44\\u3093\\u3067\\u30da\\u30a2\\u548c>=mid\\u3092\\u6e80\\u305f\\u3059j\\u306e\\u4e0b\\u9650, \\u521d\\u671f\\u5024\\u306f\\u7bc4\\u56f2\\u5916=\\u6761\\u4ef6\\u3092\\u6e80\\u305f\\u3059j\\u306f\\u306a\\u3044\\n    for i in range(N):\\n        while j > 0 and a[i] + a[j - 1] >= ma:\\n            j -= 1\\n        ans += a[i] * (N - j) + acc[N] - acc[j]  # i\\u5074\\u306e\\u5bc4\\u4e0e=\\u30da\\u30a2\\u6570,j\\u5074\\u306e\\u5bc4\\u4e0e=acc\\n    ans += (ma - 1) * (M - count(ma))  # \\u30da\\u30a2\\u548cma\\u3067\\u306fM\\u30da\\u30a2\\u7d44\\u3081\\u306a\\u3044\\u304c\\u3001ma-1\\u3067\\u57cb\\u3081\\u3089\\u308c\\u308b\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nimport numpy as np\\n\\n# \\u4fa1\\u5024 x \\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u5168\\u3066\\u884c\\u3046\\u3068\\u3059\\u308b\\n# \\u63e1\\u624b\\u56de\\u6570\\u304c\\u6c7a\\u307e\\u308b\\u3002\\u5de6\\u624b\\u3054\\u3068\\u306b\\u96c6\\u8a08\\u3067\\u304d\\u308b\\u3002\\n\\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\\nA = np.array(sys.stdin.readline().rstrip().split(), np.int64)\\n\\nA.sort()  # A \\u3092\\u6607\\u9806\\u306b\\u4e26\\u3073\\u66ff\\u3048\\u308b\\n\\n# x \\u3088\\u308a\\u4fa1\\u5024\\u304c\\u9ad8\\u304f\\u306a\\u308b\\u63e1\\u624b\\u306e\\u7dcf\\u6570\\n#  -> a \\u306b\\u5bfe\\u3057\\u3066\\u3001\\u76f8\\u624b\\u306f x - a \\u304c\\u5fc5\\u8981\\n#   -> A = [a0, a1, a2, ...] \\u306b\\u5bfe\\u3057\\u3066\\u3001[x-a0\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e, x-a1\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e, x-a2\\u306e\\u958b\\u59cb\\u4f4d\\u7f6e,...] \\u3092\\u63a2\\u3059\\ndef shake_cnt(x):\\n    # x \\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u5168\\u3066\\u884c\\u3046\\u3068\\u3057\\u3066\\u3001\\u63e1\\u624b\\u306e\\u56de\\u6570\\u3092\\u6570\\u3048\\u308b\\u884c\\u308f\\u306a\\u3044\\u63e1\\u624b\\u3092\\u6570\\u3048\\u308b\\n    X = np.searchsorted(A, x - A)  # \\u30bd\\u30fc\\u30c8\\u3055\\u308c\\u305f\\u30ea\\u30b9\\u30c8A \\u306b\\u5bfe\\u3057\\u3066\\u3001x - A \\u304c\\u633f\\u5165\\u3055\\u308c\\u308b\\u4f4d\\u7f6e\\u3092\\u8fd4\\u3059\\n    return N * N - X.sum()  # index \\u306e\\u548c\\u306f\\u300c\\u5c0f\\u3055\\u3044\\u65b9\\u300d\\u3092\\u6307\\u3057\\u3066\\u3044\\u308b\\u306e\\u3067\\u3001\\u5f15\\u304f\\n\\n\\n# \\u4e8c\\u5206\\u63a2\\u7d22  \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304c\\nleft = 0  # \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304cM\\u4ee5\\u4e0a\\nright = 10 ** 6  # \\u63e1\\u624b\\u306e\\u56de\\u6570\\u304cM\\u672a\\u6e80 <- \\u307e\\u3060\\u8db3\\u308a\\u306a\\u3044\\u5074\\nwhile 1 < right - left:  # left \\u3068 right \\u304c\\u96a3\\u308a\\u5408\\u3063\\u305f\\u3089\\u7d42\\u4e86\\n    x = (left + right) // 2\\n    if shake_cnt(x) >= M:\\n        left = x\\n    else:\\n        right = x\\n\\n# M\\u56de\\u306b\\u306f\\u5c4a\\u304b\\u306a\\u3044\\u3051\\u308c\\u3069\\u3001M\\u56de\\u306b\\u9650\\u308a\\u306a\\u304f\\u8fd1\\u304f\\u306a\\u308b\\u4fa1\\u5024 x = right\\nX = np.searchsorted(A, right - A)  # \\u5404a in A \\u304c\\u63e1\\u624b\\u3092\\u884c\\u308f\\u306a\\u3044\\u4eba\\u6570\\u306eArray\\nshake = N * N - X.sum()  # \\u3053\\u3053\\u307e\\u3067\\u306e\\u63e1\\u624b\\u56de\\u6570\\n\\nAcum = np.zeros(N + 1, np.int64)  # \\u4eba\\u6570 -> \\u7d2f\\u7a4d\\u548c\\n# Acum = [a0, a0+a1, a0+a1+a2, ....] \\u3092\\u8a08\\u7b97\\u3057\\u3066\\u3001ai \\u3055\\u3093\\u304c k\\u756a\\u76ee\\u4ee5\\u964d\\u3068\\u63e1\\u624b\\u3092\\u3059\\u308c\\u3070\\nAcum[1:] = np.cumsum(A)  # cumsum [1,2,3,4,5,6,...] -> [1,3,6,10,15,21,...]\\n\\n# \\u53f3\\u624b\\u306e\\u5e78\\u798f\\u5ea6\\u306f ai * ((a0+a1+...a(n-1)) - (a(k-1)+...+a(n-1))) \\u3092\\u5f97\\u3089\\u308c\\u308b\\n# \\u5de6\\u624b\\u306e\\u5e78\\u798f\\u5ea6\\u306f \\u56de\\u6570\\u3060\\u3051\\u3067\\u6c7a\\u307e\\u308b\\uff08\\u4f55\\u4eba\\u3068\\u63e1\\u624b\\u3068\\u3059\\u308b\\u304b\\uff09\\nhappy = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\\n\\nhappy += (M - shake) * left  # \\u4e0d\\u8db3\\u5206\\u30021\\u56de\\u306e\\u4fa1\\u5024\\u306f M \\u3068\\u308f\\u304b\\u3063\\u3066\\u3044\\u308b\\n\\nprint(happy)\\n\", \"import bisect\\n\\n\\ndef is_ok(a, target, m):\\n    num = 0\\n    for val in a:\\n        index = bisect.bisect_left(a, target - val)\\n        num += len(a) - index\\n    if num <= m:\\n        return True\\n    else:\\n        return False\\n\\n\\nn, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\na.sort()\\n\\nok, ng = 10 ** 10, -1\\nwhile ok - ng > 1:\\n    mid = (ok + ng) // 2\\n    if is_ok(a, mid, m):\\n        ok = mid\\n    else:\\n        ng = mid\\n\\nrui = [0] * (n + 1)\\n\\nfor i in range(n):\\n    rui[i+1] = rui[i] + a[i]\\n\\ncnt = 0\\nret = 0\\n\\nfor val in a:\\n    index = bisect.bisect_left(a, ok - val)\\n    num = len(a) - index\\n    cnt += num\\n    ret += (num * val) + (rui[-1] - rui[index])\\n\\nret += (m - cnt) * ng\\n\\nprint(ret)\\n\", \"from itertools import accumulate\\nfrom bisect import bisect_left, bisect_right\\nN, M = list(map(int, input().split()))\\n*A, = list(map(int, input().split()))\\nA.sort()\\nacc = list(accumulate(A[::-1]))[::-1]+[0]\\n\\n\\ndef isok(x):\\n    cnt = 0\\n    for a in A:\\n        cnt += N - bisect_left(A, x-a)\\n    return cnt >= M\\n\\n\\nl = 0\\nr = 202020\\nwhile l+1 < r:\\n    m = (l+r)//2\\n    if isok(m):\\n        l = m\\n    else:\\n        r = m\\n\\nans = 0\\ncnt = 0\\nfor a in A:\\n    i = bisect_left(A, l-a)\\n    ans += a*(N-i) + acc[i]\\n    cnt += N-i\\nif cnt > M:\\n    ans -= l * (cnt-M)\\nprint(ans)\\n\", \"import numpy as np\\ndef convolve(A, B):\\n    # \\u7573\\u307f\\u8fbc\\u307f  # \\u8981\\u7d20\\u306f\\u6574\\u6570\\n    # 3 \\u3064\\u4ee5\\u4e0a\\u306e\\u5834\\u5408\\u306f\\u4e00\\u5ea6\\u306b\\u3084\\u3063\\u305f\\u65b9\\u304c\\u3044\\u3044\\n    dtype = np.int64\\n    fft, ifft = np.fft.rfft, np.fft.irfft\\n    a, b = len(A), len(B)\\n    if a == b == 1:\\n        return np.array([A[0]*B[0]])\\n    n = a+b-1  # \\u8fd4\\u308a\\u5024\\u306e\\u30ea\\u30b9\\u30c8\\u306e\\u9577\\u3055\\n    k = 1 << (n-1).bit_length()\\n    AB = np.zeros((2, k), dtype=dtype)\\n    AB[0, :a] = A\\n    AB[1, :b] = B\\n    return np.rint(ifft(fft(AB[0]) * fft(AB[1]))).astype(np.int64)[:n]\\n\\nimport sys\\ninput = sys.stdin.readline\\nn,m = map(int, input().split())\\na = list(map(int, input().split()))\\n \\ncnt = np.zeros(100001)\\nfor i in a:\\n    cnt[i] += 1 \\n\\nc = convolve(cnt,cnt)\\nans = 0\\nfor i in range(len(c))[::-1]:\\n    if c[i] > 0:\\n      p = min(m,c[i])\\n      m -= p\\n      ans += i*p\\n      if m == 0:\\n        break\\nprint(ans)\", \"# https://atcoder.jp/contests/abc149/tasks/abc149_e\\n\\n# \\u3059\\u3079\\u3066\\u306e\\u63e1\\u624b\\u306e\\u7d44\\u307f\\u5408\\u308f\\u305bN**2\\u3092\\u5217\\u6319\\u3057\\u30bd\\u30fc\\u30c8\\u3057M\\u756a\\u76ee\\u307e\\u3067\\u3092\\u8db3\\u3057\\u5408\\u308f\\u305b\\u308c\\u3070OK\\n# \\u3060\\u3051\\u3069\\u5236\\u7d04\\u304b\\u3089\\u3053\\u308c\\u3092\\u884c\\u3046\\u3053\\u3068\\u306f\\u56f0\\u96e3\\n# \\u3059\\u3079\\u3066\\u3092\\u5217\\u6319\\u3057\\u306a\\u304f\\u3068\\u3082M\\u756a\\u76ee\\u306e\\u5024\\u3092\\u77e5\\u308b\\u3053\\u3068\\u306f\\u4e8c\\u5206\\u63a2\\u7d22\\u3067\\u53ef\\u80fd(\\u53c2\\u8003:\\u5104\\u30de\\u30b9\\u8a08\\u7b97)\\n# A\\u306e\\u7d2f\\u7a4d\\u548c\\u3092\\u4fdd\\u6301\\u3057\\u3066\\u304a\\u3051\\u3070\\u3001M\\u756a\\u76ee\\u306e\\u5024\\u306e\\u63a2\\u7d22\\u4e2d\\u306bM\\u307e\\u3067\\u306e\\u5024\\u306e\\u5408\\u8a08\\u3082\\u3064\\u3044\\u3067\\u306b\\u8a08\\u7b97\\u3067\\u304d\\u308b\\n# \\u4ee5\\u4e0breverse\\u3067\\u30bd\\u30fc\\u30c8\\u6e08\\u307f\\u3060\\u3068\\u4eee\\u5b9a\\n# X\\u304cM\\u756a\\u76ee\\u306e\\u6570\\u2192X\\u4ee5\\u4e0a\\u3067\\u3042\\u308b\\u6570\\u306fM\\u500b\\u4ee5\\u4e0a(cnt\\u3068\\u3059\\u308b)\\u2192cnt\\u304cM\\u500b\\u4ee5\\u4e0a\\u306e\\u6761\\u4ef6\\u3092\\u6e80\\u305f\\u3059\\u3046\\u3061\\u306e\\u6700\\u5927\\u3068\\u306a\\u308bX\\u304cM\\u756a\\u76ee\\u306e\\u5024\\n# \\u305d\\u306e\\u3042\\u3068\\u4f59\\u5206\\u306a\\u5206\\u3092\\u5f15\\u304f\\u51e6\\u7406\\u3068\\u304b\\u5fc5\\u8981\\n\\nfrom bisect import bisect_right, bisect_left\\nimport sys\\nread = sys.stdin.readline\\n\\n\\ndef read_ints():\\n    return list(map(int, read().split()))\\n\\n\\nclass cumsum1d:\\n    def __init__(self, ls: list):\\n        '''\\n        1\\u6b21\\u5143\\u30ea\\u30b9\\u30c8\\u3092\\u53d7\\u3051\\u53d6\\u308b\\n        '''\\n        from itertools import accumulate\\n        self.ls_accum = [0] + list(accumulate(ls))\\n\\n    def total(self, i, j):\\n        # \\u3082\\u3068\\u306e\\u914d\\u5217ls\\u306b\\u304a\\u3051\\u308b[i,j)\\u306e\\u4e2d\\u5408\\u8a08\\n        return self.ls_accum[j] - self.ls_accum[i]\\n\\n\\nN, M = read_ints()\\nA = read_ints()\\nA.sort()  # bisect\\u3092\\u4f7f\\u3046\\u90fd\\u5408\\u4e0a reverse\\u306f\\u629c\\u304d\\nA_reversed = list(reversed(A))\\nA_rev_acc = cumsum1d(A_reversed)\\n\\n\\ndef is_ok(X):\\n    # M\\u756a\\u76ee\\u306e\\u6570\\u306fX\\u3067\\u3042\\u308b\\u2192X\\u4ee5\\u4e0a\\u306e\\u500b\\u6570>=M \\u3068\\u306a\\u308b\\u3046\\u3061\\u3067\\u6700\\u5927\\u306eX(\\u3082\\u3063\\u3068\\u3082\\u5de6\\u306e\\u65b9\\u306eX)\\n    # X\\u4ee5\\u4e0a\\u306e\\u500b\\u6570>=M\\u3092\\u8fd4\\u3059\\n    # X\\u4ee5\\u4e0b\\u306e\\u500b\\u6570\\u306fai+aj>=X\\u3092\\u6e80\\u305f\\u3059\\u500b\\u6570\\n    cnt = 0\\n    ans = 0\\n    for a in A:\\n        aa = X - a\\n        idx_reverse = N - bisect_left(A, aa)  # \\u5927\\u304d\\u3044\\u65b9\\u304b\\u3089\\u3060\\u3068\\u4f55\\u756a\\u76ee\\u304b\\n        # \\u3053\\u308c\\u306fbisect_right(A_reversed,aa)\\u306b\\u7b49\\u3057\\u3044\\n        cnt += idx_reverse\\n        ans += A_rev_acc.total(0, idx_reverse) + idx_reverse * a\\n    return cnt >= M, ans, cnt\\n\\n\\ndef meguru_bisect(ng, ok):\\n    '''\\n    define is_ok\\u3068\\n    \\u521d\\u671f\\u5024\\u306eng,ok\\u3092\\u53d7\\u3051\\u53d6\\u308a,is_ok\\u3092\\u6e80\\u305f\\u3059\\u6700\\u5c0f(\\u6700\\u5927)\\u306eok\\u3092\\u8fd4\\u3059\\n    ng ok \\u306f  \\u3068\\u308a\\u5f97\\u308b\\u6700\\u5c0f\\u306e\\u5024-1 \\u3068\\u308a\\u5f97\\u308b\\u6700\\u5927\\u306e\\u5024+1\\n    \\u6700\\u5927\\u6700\\u5c0f\\u304c\\u9006\\u306e\\u5834\\u5408\\u306f\\u3088\\u3057\\u306a\\u306b\\u3072\\u3063\\u304f\\u308a\\u8fd4\\u3059\\n    '''\\n    while (abs(ok - ng) > 1):\\n        mid = (ok + ng) // 2\\n        flg, ans, cnt = is_ok(mid)\\n        if flg:\\n            ok = mid\\n            ans_true = ans  # \\u3055\\u3044\\u3054\\u306bok\\u3068\\u306a\\u308b\\u72b6\\u614b\\u304cans\\n            cnt_true = cnt\\n        else:\\n            ng = mid\\n    return ans_true, ok, cnt_true\\n\\n\\nans_tmp, M_th_num, M_plus_alpha_th = \\\\\\n    meguru_bisect(2 * 10 ** 5 + 1, 0)\\n# print(ans_tmp, M_th_num, M_plus_alpha_th)\\nprint((ans_tmp - (M_plus_alpha_th - M) * M_th_num))\\n\", \"import bisect\\nn,m=list(map(int,input().split()))\\nl=list(map(int,input().split()))\\nl.sort()\\nr=[0]*(10**5+2)\\nfor i in range(n):\\n    r[l[i]]+=1\\nfor i in range(10**5+1):\\n    r[i+1]+=r[i]\\nok=10**6\\nng=0\\nwhile ok-ng>1:\\n    x=(ok+ng)//2\\n    k=0\\n    for i in range(n):\\n        if x-l[i]<0:\\n            k+=n\\n        elif x-l[i]>10**5+1:\\n            k+=0\\n        else:\\n            k+=n-r[x-l[i]]\\n    if k>=m:\\n        ng=x\\n    else:\\n        ok=x\\n#print(ok)\\np=[0]*(n+1)\\nfor i in range(n):\\n    p[i+1]=p[i]+l[i]\\nans=0\\nmi=0\\nfor i in range(n):\\n    li=bisect.bisect_left(l,ok-l[i])\\n    ans+=l[i]*(n-li)+p[n]-p[li]\\n    mi+=n-li\\nprint((ans-(mi-m)*ok))\\n\", \"import numpy as np\\nfrom numpy.fft import rfft, irfft\\n\\nN, M = list(map(int, input().split()))\\n*A, = list(map(int, input().split()))\\nB = np.zeros(5*10**5)\\nfor a in A:\\n    B[a] += 1\\n\\nL = 5*10**5\\nFB = rfft(B, L)\\nC = np.rint(irfft(FB*FB)).astype(int)\\n\\nans = 0\\nfor i in range(2*10**5, -1, -1):\\n    c = C[i]\\n    if not c:\\n        continue\\n    if M - c > 0:\\n        ans += i*c\\n        M -= c\\n    else:\\n        ans += i*M\\n        break\\nprint(ans)\\n\", \"import sys,collections as cl,bisect as bs\\nsys.setrecursionlimit(100000)\\ninput = sys.stdin.readline\\nmod = 10**9+7\\nMax = sys.maxsize\\ndef l(): #int\\u306elist\\n    return list(map(int,input().split()))\\ndef m(): #\\u8907\\u6570\\u6587\\u5b57\\n    return list(map(int,input().split()))\\ndef onem(): #N\\u3068\\u304b\\u306e\\u53d6\\u5f97\\n    return int(input())\\ndef s(x): #\\u5727\\u7e2e\\n    a = []\\n    if len(x) == 0:\\n        return []\\n    aa = x[0]\\n    su = 1\\n    for i in range(len(x)-1):\\n        if aa != x[i+1]:\\n            a.append([aa,su])\\n            aa = x[i+1]\\n            su = 1\\n        else:\\n            su += 1\\n    a.append([aa,su])\\n    return a\\ndef jo(x): #list\\u3092\\u30b9\\u30da\\u30fc\\u30b9\\u3054\\u3068\\u306b\\u5206\\u3051\\u308b\\n    return \\\" \\\".join(map(str,x))\\ndef max2(x): #\\u4ed6\\u306e\\u3068\\u304d\\u3082\\u3069\\u3046\\u3088\\u3046\\u306b\\u4f5c\\u6210\\u53ef\\u80fd\\n    return max(list(map(max,x)))\\ndef In(x,a): #a\\u304c\\u30ea\\u30b9\\u30c8(sorted)\\n    k = bs.bisect_left(a,x)\\n    if k != len(a) and a[k] ==  x:\\n        return True\\n    else:\\n        return False\\n\\ndef pow_k(x, n):\\n    ans = 1\\n    while n:\\n        if n % 2:\\n            ans *= x\\n        x *= x\\n        n >>= 1\\n    return ans\\n\\n\\n\\n\\n\\n\\nN,M = m()\\n\\na = l()\\n\\na.sort()\\n\\naaa = s(a)\\n\\n\\n\\npo = [0 for i in range(10**5+2)]\\nans = 0\\nfor i in range(N):\\n    po[a[i]] += 1\\nfor i in range(10**5,-1,-1):\\n    po[i] += po[i+1]\\nll = 0\\nrr = 10**5 * 2 + 1\\n\\nwhile True:\\n    mid = (ll+rr)//2\\n    if mid == ll:\\n        co = 0\\n        for i in range(N):\\n            ui = a[i]\\n            if mid > ui + 10**5:\\n                continue\\n            elif ui >= mid:\\n                co += N\\n            else:\\n                co += po[mid-ui]\\n        cco = 0\\n        mid = rr\\n\\n        for i in range(N):\\n            ui = a[i]\\n            if mid > ui + 10**5:\\n                continue\\n            elif ui >= mid:\\n                cco += N\\n            else:\\n                cco += po[mid-ui]\\n\\n        if cco == M:\\n            mid = rr\\n            co=cco\\n\\n        else:\\n            mid = ll\\n\\n        break\\n\\n    co = 0\\n    for i in range(N):\\n        ui = a[i]\\n        if mid > ui + 10**5:\\n            continue\\n        elif ui >= mid:\\n            co += N\\n        else:\\n            co += po[mid-ui]\\n    \\n    if co < M:\\n        rr = mid                 \\n    else:\\n        ll = mid\\n\\n\\na.sort(reverse = True)\\ndp = [0]\\n\\nans -= mid * (co - M)\\n\\n\\n\\nfor i in range(N):\\n    dp.append(dp[-1]+a[i])\\n\\nfor i in range(N):\\n    pl = a[i]\\n    if pl >= mid:\\n        ans += pl*N + dp[-1]\\n        \\n    elif pl + 10**5 < mid:\\n        continue\\n    else:\\n        ans += pl*po[mid-pl] + dp[po[mid-pl]]\\nprint(ans)\\n\\n\\n\\n\", \"#!/usr/bin/env python3\\n\\nimport sys, heapq, bisect\\nsys.setrecursionlimit(300000)\\n\\ndef _count(A, n, v):\\n    ret = 0\\n    for a in A:\\n        target = v - a\\n        idx = bisect.bisect_left(A, target)\\n        ret += n - idx\\n    return ret\\n\\ndef _sum(A, n, v, sums):\\n    ss = 0\\n    for a in A:\\n        target = v - a\\n        idx = bisect.bisect_left(A, target)\\n        ss += sums[n] - sums[idx]\\n        ss += (n - idx) * a\\n    #print(mins)\\n    return ss\\n\\ndef solve(N: int, M: int, A: \\\"List[int]\\\"):\\n    A.sort()\\n    sums = [0]\\n    for a in A:\\n        sums.append(sums[-1] + a)\\n    l = -1\\n    r = max(A) * 2 + 1\\n    while r - l > 1:\\n        m = (r + l) // 2\\n        cnt = _count(A, N, m)\\n        if cnt >= M:\\n            l = m\\n        else:\\n            r = m\\n    cnt = _count(A, N, l)\\n    ret = _sum(A, N, l, sums)\\n    ret -= (cnt - M) * l\\n    print(ret)\\n    return ret\\n\\n\\ndef solve_(N: int, M: int, A: \\\"List[int]\\\"):\\n    A.sort(reverse=True)\\n    q = [(-A[0] * 2, 0, 0)]\\n    ret = 0\\n    cnt = 0\\n    while cnt < M:\\n        s, i, j = heapq.heappop(q)\\n        ret += -s\\n        cnt += 1\\n        print((i, j))\\n        if i == j and i < N - 1:\\n            heapq.heappush(q, (-A[i] + -A[i + 1], i, i + 1))\\n        else:\\n            if cnt < M:\\n                ret += -s\\n                cnt += 1\\n                print((j, i))\\n            heapq.heappush(q, (-A[i + 1] + -A[j], i + 1, j))\\n            if j < N - 1:\\n                heapq.heappush(q, (-A[i] + -A[j + 1], i, j + 1))\\n    print(ret)\\n    return\\n\\ndef main():\\n    def iterate_tokens():\\n        for line in sys.stdin:\\n            for word in line.split():\\n                yield word\\n    tokens = iterate_tokens()\\n    N = int(next(tokens))  # type: int\\n    M = int(next(tokens))  # type: int\\n    A = [int(next(tokens)) for _ in range(N)]  # type: \\\"List[int]\\\"\\n    solve(N, M, A)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import bisect\\nimport itertools\\nimport numpy as np\\n\\ndef search_cut(N, M, A):\\n    high_cut = A[-1] * 2\\n    low_cut = A[0] * 2\\n\\n    while high_cut > low_cut + 1:\\n        mid = (high_cut + low_cut) // 2\\n        count = (N  - np.searchsorted(A, mid - A, side = 'left')).sum()\\n\\n        if count > M:\\n            low_cut = mid\\n        else:\\n            high_cut = mid\\n\\n    return low_cut, high_cut\\n\\ndef happiness(N, M, A, low_cut, high_cut):\\n    A_sum = np.zeros(N + 1)\\n    A_sum[1:] = np.cumsum(A)\\n    X = np.searchsorted(A, high_cut - A, side = 'left')\\n    happiness = (A_sum[-1] - A_sum[X]).sum()\\n    happiness += ((N - X) * A).sum()\\n    happiness += (M - (N - X).sum()) * low_cut\\n\\n    return int(happiness)\\n\\n\\nN, M = list(map(int, input().split()))\\nA = np.array(list(map(int, input().split())))\\nA = np.sort(A)\\n\\nlow_cut, high_cut = search_cut(N, M, A)\\nans = happiness(N, M, A, low_cut, high_cut)\\nprint(ans)\\n\", \"ii = lambda : int(input())\\nmi = lambda : list(map(int,input().split()))\\nli = lambda : list(map(int,input().split()))\\n\\nn,m = mi()\\nalis = li()\\n\\nalis.sort()\\nok = 0\\nng = alis[n-1] * 2 +1\\nfrom bisect import bisect_left as bl\\nwhile ng - ok >1:\\n    mid = (ok + ng)//2\\n    ima = 0\\n    for i in range(n):\\n        ima += n - bl(alis,mid-alis[i])\\n    if ima >= m:\\n        ok = mid\\n        outrange = ima - m\\n    else:\\n        ng = mid\\n\\nacu_alis = [0]*n\\nima = 0\\nfor i in range(n):\\n    acu_alis[i] = alis[i] + ima\\n    ima = alis[i] + ima\\n\\nans = 0\\nfor i in range(n):\\n    tmp = bl(alis,ok-alis[i]) \\n    if tmp ==0:\\n        ans += n*alis[i] + acu_alis[n-1]\\n    else:\\n        ans += (n-tmp)*alis[i] + acu_alis[n-1] - acu_alis[tmp-1]\\nans -= outrange*ok\\nprint(ans)\\n\\n\\n\", \"n,m=map(int,input().split())\\narr=list(map(int,input().split()))\\narr=sorted(arr,reverse=True)\\nacum=[arr[0]]\\nfor i in range(1,n):\\n  acum.append(acum[-1]+arr[i])\\nl=0\\nr=2*10**5+1\\nwhile r-l!=1:\\n  mid=(l+r)//2\\n  tmp=0\\n  cnt=0\\n  pos=n-1\\n  for i in range(n):\\n    while pos!=-1:\\n      if arr[i]+arr[pos]>=mid:\\n        cnt+=pos+1\\n        tmp+=arr[i]*(pos+1)+acum[pos]\\n        break\\n      else:\\n        pos-=1\\n        if pos==-1:\\n          break\\n  if cnt<=m:\\n    r=mid\\n  else:\\n    l=mid\\ntmp+=(m-cnt)*l\\nprint(tmp)\", \"from bisect import bisect_left\\n\\nN, M = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nA.sort()\\n\\ndef count(x):\\n    ret = 0\\n    for a in A:\\n        ret += N - bisect_left(A, x - a)\\n    return ret\\n\\noverEq = 0\\nless = 10**7\\nwhile less - overEq > 1:\\n    mid = (less + overEq) // 2\\n    if count(mid) >= M:\\n        overEq = mid\\n    else:\\n        less = mid\\n\\nans = 0\\ncnt = [0] * N\\nfor a in A:\\n    i = (N - bisect_left(A, overEq - a))\\n    ans += i * a\\n    if i > 0:\\n        cnt[-i] += 1\\nfor i in range(1, N):\\n    cnt[i] += cnt[i - 1]\\nfor a, c in zip(A, cnt):\\n    ans += a * c\\n\\nans -= overEq * (count(overEq) - M)\\n\\nprint(ans)\\n\", \"def main():\\n    from bisect import bisect_left as bl\\n    from itertools import accumulate as ac\\n\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    aa = [0]+list(ac(a))\\n    an = aa[n]\\n\\n    ok = 0\\n    ng = 10**10\\n    while abs(ok-ng) > 1:\\n        mid = (ok+ng)//2\\n        if sum([n-bl(a, mid-a[i]) for i in range(n)]) >= m:\\n            ok = mid\\n        else:\\n            ng = mid\\n\\n    c = -m+sum([n-bl(a, ok-a[i]) for i in range(n)])\\n    ans = -c*ok\\n    for i in range(n):\\n        d = bl(a, ok-a[i])\\n        ans += an-aa[d]+(n-d)*a[i]\\n    print(ans)\\n\\n\\nmain()\", \"def e_handshake():\\n    import numpy as np\\n    N, M = [int(i) for i in input().split()]\\n    A = np.array(input().split(), np.int64)\\n    A.sort()\\n\\n    def shake_cnt(x):\\n        # \\u5e78\\u798f\\u5ea6\\u304c x \\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u3088\\u3046\\u306a\\u63e1\\u624b\\u3092\\u5168\\u3066\\u884c\\u3046\\u3068\\u304d\\u306e\\u63e1\\u624b\\u306e\\u56de\\u6570\\n        # \\u5168\\u4f53\\u304b\\u3089\\u884c\\u308f\\u306a\\u3044\\u63e1\\u624b\\u56de\\u6570\\u3092\\u5f15\\u304f\\n        return N**2 - np.searchsorted(A, x - A).sum()\\n\\n    # \\u5e78\\u798f\\u5ea6\\u306e\\u4e0a\\u6607\\u304c right \\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u3088\\u3046\\u306a\\u63e1\\u624b\\u306f\\u3059\\u3079\\u3066\\u884c\\u3044\\u3001\\n    # left \\u3068\\u306a\\u308b\\u3088\\u3046\\u306a\\u63e1\\u624b\\u306f\\u3044\\u304f\\u3064\\u304b\\u884c\\u3063\\u3066\\u63e1\\u624b\\u56de\\u6570\\u304c M \\u56de\\u306b\\u306a\\u308b\\u3088\\u3046\\u306b\\u3059\\u308b\\n    left = 0\\n    right = 10 ** 6\\n    while right - left > 1:\\n        mid = (left + right) // 2\\n        if shake_cnt(mid) >= M:\\n            left = mid\\n        else:\\n            right = mid\\n\\n    # \\u5e78\\u798f\\u5ea6\\u304c right \\u4ee5\\u4e0a\\u4e0a\\u304c\\u308b\\u3088\\u3046\\u306a\\u63e1\\u624b\\u3092\\u3059\\u3079\\u3066\\u884c\\u3063\\u305f\\u3068\\u3057\\u3066\\u3001\\u56de\\u6570\\u3068\\u7dcf\\u548c\\u3092\\u8a08\\u7b97\\n    X = np.searchsorted(A, right - A)  # \\u884c\\u308f\\u306a\\u3044\\u4eba\\u6570\\n    Acum = np.zeros(N + 1, np.int64)  # \\u7d2f\\u7a4d\\u548c\\u3067\\u7ba1\\u7406\\u3059\\u308b\\n    Acum[1:] = np.cumsum(A)\\n    happiness = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\\n\\n    # \\u5e78\\u798f\\u5ea6\\u304c right \\u672a\\u6e80\\u306e\\u4e0a\\u6607\\u3068\\u306a\\u308b\\u63e1\\u624b\\u3092\\u3001\\u63e1\\u624b\\u56de\\u6570\\u304c M \\u306b\\u306a\\u308b\\u307e\\u3067\\u8ffd\\u52a0\\u3067\\u884c\\u3046\\n    shake = N * N - X.sum()\\n    happiness += (M - shake) * left\\n    return happiness\\n\\nprint(e_handshake())\", \"import numpy as np\\nfrom numpy.fft import rfft,irfft\\nN,M = map(int,input().split())\\nA = list(map(int,input().split()))\\na = np.zeros(10**5+1)\\nfor i in range(N):\\n    a[A[i]] += 1\\nb = rfft(a,2*10**5+1)\\nb = irfft(b*b,2*10**5+1)\\nb = np.rint(b).astype(np.int64)\\nc = 0\\nans = 0\\nfor n in range(2*10**5,1,-1):\\n    if c+b[n]<M:\\n        c += b[n]\\n        ans += b[n]*n\\n    else:\\n        ans += (M-c)*n\\n        c = M\\n        break\\nprint(ans)\", \"\\nimport numpy as np\\nN, M = list(map(int, input().split()))\\nA = np.array(input().split(), dtype=np.int32)\\n\\nx = np.bincount(A)\\nfft_size = 1 << (2 * x.size + 10).bit_length()\\n\\nfx = np.fft.rfft(x, fft_size)\\nconv = np.fft.irfft(fx * fx, fft_size)\\nconv = (conv + 0.5).astype(int)\\n\\ntmp = np.arange(conv.size, dtype=int)\\nhappy = tmp[np.nonzero(conv)].tolist()\\ncnt = conv[np.nonzero(conv)].tolist()\\n\\n\\nans = 0\\nwhile M > 0:\\n    h = happy.pop()\\n    num = cnt.pop()\\n    num = min(M, num)\\n\\n    M -= num\\n    ans += num * h\\n\\nprint(ans)\\n\", \"\\nfrom bisect import bisect_left\\nfrom itertools import accumulate\\n\\ndef resolve():\\n    def getCount(x):\\n        cnt = 0\\n        for a in A:\\n            # X\\u672a\\u6e80\\u306e\\u500b\\u6570\\n            idx = bisect_left(A, x - a)\\n            # X\\u4ee5\\u4e0a\\u306e\\u500b\\u6570\\n            cnt += N - idx\\n        # X\\u4ee5\\u4e0a\\u3092\\u4f7f\\u3046\\uff01\\u3068\\u6c7a\\u3081\\u305f\\u6642\\u3001M\\u500b\\u4ee5\\u4e0a\\u306b\\u306a\\u308b\\u304b\\n        return cnt >= M\\n\\n    N, M = list(map(int, input().split()))\\n    A = sorted(map(int, input().split()))\\n\\n    ng = 10 ** 9\\n    ok = 0\\n    # X\\u4ee5\\u4e0a\\u3092\\u4f7f\\u3046\\uff01\\u3068\\u6c7a\\u3081\\u308b\\u3068X\\u4ee5\\u4e0a\\u306e\\u500b\\u6570\\u304c\\u81ea\\u660e\\u306b\\u308f\\u304b\\u308b\\u3002\\n    while ng - ok > 1:\\n        mid = (ok + ng) // 2\\n        if getCount(mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n\\n    # M\\u500b\\u4ee5\\u4e0a\\u3042\\u308b\\u3053\\u3068\\u304c\\u308f\\u304b\\u308c\\u3070\\u3001M\\u3088\\u308a\\u3082\\u4f59\\u5206\\u306a\\u6570(\\u540c\\u3058\\u5024\\u304c\\u8907\\u6570\\u3042\\u308b\\u5834\\u5408)\\n    # \\u306f\\u3059\\u3079\\u3066X\\u3067\\u3042\\u308b\\u4e8b\\u304c\\u308f\\u304b\\u308b\\u305f\\u3081\\u3001\\u5dee\\u5206\\u3060\\u3051\\u5f15\\u3051\\u3070\\u826f\\u3044\\u3002\\n    B = [0] + list(accumulate(A))\\n    ans = 0\\n    cnt = 0\\n    for i in range(N):\\n        idx = bisect_left(A, ok - A[i])\\n        ans += B[N] - B[idx] + A[i] * (N - idx)\\n        cnt += N - idx\\n\\n    rest = (cnt - M) * ok\\n    print((ans - rest))\\n\\n\\ndef __starting_point():\\n    resolve()\\n\\n__starting_point()\", \"from bisect import bisect_left\\n\\nN, M = list(map(int, input().split()))\\nA = sorted(list(map(int, input().split())))\\nl = 0\\nr = 2*10**5+5\\n\\n\\nwhile l+1 < r:\\n    mid = (l+r) // 2\\n    \\n    m = 0\\n    for a in A:\\n        idx = bisect_left(A, mid-a)\\n        m += N-idx\\n        \\n    if m >= M: l = mid\\n    else: r = mid\\n\\ns = [0] * (N+1)\\nfor i in range(N):\\n    s[i+1] = s[i] + A[i]\\n    \\nans = 0\\nm = 0\\nfor a in A:\\n    idx = bisect_left(A, l-a)\\n    m += N-idx\\n    \\n    ans += s[N]-s[idx]\\n    ans += a*(N-idx)\\n    \\nans -= (m-M)*l\\n\\nprint(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nimport bisect\\nfrom itertools import accumulate\\n\\nN, M = [int(x) for x in input().split()]\\nA = [int(x) for x in input().split()]\\nA.sort()\\n\\nleft = -1\\nright = 1 + 2 * 10 ** 5\\n\\ndef shake(x):\\n    cnt = 0\\n    for i in A:\\n        cnt += N - bisect.bisect_left(A, x - i)\\n    if cnt >= M:\\n        return 1\\n    else:\\n        return 0\\n\\nwhile True:\\n    mid = (left + right) // 2\\n    if shake(mid):\\n        if not shake(mid + 1):\\n            X = mid\\n            break\\n        else:\\n            left = mid\\n    else:\\n        if shake(mid - 1):\\n            X = mid - 1\\n            break\\n        else:\\n            right = mid\\n\\nhappy = 0\\ncumsum_A = list(accumulate(A))\\n\\nfor j in A:\\n    idx = bisect.bisect_right(A, X - j)\\n    cnt = N - idx\\n    if cnt == N:\\n        happy += cumsum_A[-1] + cnt * j\\n    else:\\n        happy += cumsum_A[-1] - cumsum_A[idx - 1] + cnt * j\\n    M -= cnt\\n\\nhappy += M * X\\n\\nprint(happy)\\n\", \"from bisect import bisect_left, bisect_right\\nfrom itertools import accumulate\\n\\ndef solve():\\n    N, M = list(map(int, input().split()))\\n    As = list(map(int, input().split()))\\n\\n    As.sort()\\n\\n    def isOK(x):\\n        num = 0\\n        for k, A in enumerate(As, start=1):\\n            i = bisect_left(As, x-A)\\n            num += N-i\\n            if num >= M:\\n                return True\\n            elif num + (N-k)*N < M:\\n                return False\\n        return num >= M\\n\\n    ng, ok = 2*10**5+1, 0\\n    while abs(ok-ng) > 1:\\n        mid = (ng+ok) // 2\\n        if isOK(mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n#    print('ok:', ok)\\n\\n    score = 0\\n    num = 0\\n    accAs = list(accumulate([0]+As))\\n    for A in As:\\n        i = bisect_right(As, ok-A)\\n        score += A*(N-i) + accAs[N] - accAs[i]\\n        num += N-i\\n#    print('score:', score, '/ num:', num)\\n\\n    ans = score + ok*(M-num)\\n    print(ans)\\n\\n\\nsolve()\\n\", \"def binary_search(*, ok, ng, is_ok):\\n    while abs(ok - ng) > 1:\\n        mid = (ng + ok) // 2\\n        if is_ok(mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n    return ok\\n\\n\\ndef main():\\n    from itertools import accumulate\\n\\n    N, M = list(map(int, input().split()))\\n    *A, = sorted(map(int, input().split()))\\n\\n    acc = [0]\\n    for x in accumulate(A):\\n        acc.append(x)\\n\\n    def count(h):\\n        ret = 0\\n\\n        j = N\\n        for i in range(N):\\n            while j - 1 >= 0 and A[i] + A[j - 1] >= h:\\n                j -= 1\\n            ret += N - j\\n            # [j,N)\\u306e\\u8981\\u7d20\\u6570\\n\\n        return ret\\n\\n    x = binary_search(ok=A[-1] * 2 + 1, ng=0, is_ok=lambda x: count(x) < M)\\n    # \\u5e78\\u798f\\u5ea6\\u306e\\u7dcf\\u548c\\u304cX\\u4ee5\\u4e0a\\u306e\\u30da\\u30a2\\u6570\\u304cM\\u672a\\u6e80\\u3068\\u306a\\u308b\\u6700\\u5927\\u306eX\\n\\n    s = 0\\n    j = N\\n    for i in range(N):\\n        while j - 1 >= 0 and A[i] + A[j - 1] >= x:\\n            j -= 1\\n        s += A[i] * (N - j) + acc[N] - acc[j]\\n    s += (M - count(x)) * (x - 1)\\n\\n    print(s)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from bisect import bisect_left\\nn, m = map(int, input().split())\\nA = list(map(int, input().split()))\\nA.sort()\\nmaxA = max(A)\\ncnt = [0] * (maxA * 2 + 2)\\nrui = [n] * (maxA * 2 + 2)\\n\\nfor a in A:\\n  cnt[a] += 1\\n\\naccum = 0  \\nfor i in range(maxA * 2 + 1):\\n  accum += cnt[i]\\n  rui[i + 1] -= accum \\n  \\n# \\u5de6\\u624b\\u3092\\u6c7a\\u3081\\u305f\\u6642(left)\\u306b\\u3001\\u5e78\\u798f\\u5ea6\\u304cx \\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u7d44\\u307f\\u5408\\u308f\\u305b\\u306e\\u6570\\u3092\\u8fd4\\u3059\\ndef f(x):\\n  ret = 0\\n  for left in A:\\n    ret += rui[max(x - left, 0)]\\n  return ret\\n  \\nlo = 0\\nhi = maxA * 2 + 1\\nwhile hi - lo > 1:\\n  md = (lo + hi) // 2\\n  if f(md) >= m:\\n    lo = md\\n  else:\\n    hi = md \\n# \\u3082\\u3068\\u307e\\u308b lo \\u304c m \\u901a\\u308a\\u4ee5\\u4e0a\\u63e1\\u624b\\u304c\\u3067\\u304d\\u308b\\u6700\\u5c0f\\u306e\\u6570\\u3002\\n    \\nruiA = [0] * (n + 1)\\nfor i in range(n):\\n  ruiA[i + 1] = ruiA[i] + A[i]\\n\\nans = 0\\ncnt = 0\\nfor i in range(n):\\n  pos = bisect_left(A, lo - A[i])\\n  cnt += n - pos\\n  ans += ruiA[-1] - ruiA[pos] + A[i] * (n - pos)\\nif cnt == m:\\n  print(ans)\\nelse: # m\\u500b\\u3088\\u308a\\u3082\\u591a\\u3044\\u5206\\u3092\\u5f15\\u304f\\n  rem = cnt - m\\n  print(ans - rem * lo)\", \"import numpy as np\\nn, k = list(map(int, input().split()))\\na = np.array(list(map(int, input().split())))\\na.sort()\\nl, r = 0, 10000000000\\nwhile r - l > 1:\\n    m = (l + r) // 2\\n    res = n * n - a.searchsorted(m - a).sum()\\n    if res >= k:\\n        l = m\\n    else:\\n        r = m\\nb = np.array([0] * (n + 1))\\nfor i in range(1, n + 1):\\n    b[i] = b[i - 1] + a[n - i]\\ncnt = 0\\nans = 0\\nfor x in a:\\n    t = n - a.searchsorted(l - x)\\n    ans += b[t] + x * t\\n    cnt += t\\nprint((ans - (cnt - k) * l))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nmm = 10**10\\nk = mm.bit_length()\\nK = 1<<k\\nnu = lambda L: int(\\\"\\\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\\nst = lambda n: bin(n)[2:] + \\\"0\\\"\\nli = lambda s: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(200001)]]\\n\\nn,m = map(int, input().split())\\na = [int(i) for i in input().split()]\\nb = [0]*100001\\n\\nfor i in a:\\n    b[i] += 1\\n    \\nc = li(st(nu(b)*nu(b)))\\nans = 0\\nfor i in range(200001)[::-1]:\\n    if c[i] > 0:\\n      p = min(m,c[i])\\n      m -= p\\n      ans += i*p\\n      if m == 0:\\n        break\\nprint(ans)\", \"import sys\\nimport numpy as np\\n\\nsr = lambda: sys.stdin.readline().rstrip()\\nir = lambda: int(sr())\\nlr = lambda: list(map(int, sr().split()))\\n\\n\\\"\\\"\\\" \\u3069\\u306e\\u30d1\\u30ef\\u30fc\\u4ee5\\u4e0a\\u306e\\u7d44\\u307f\\u5408\\u308f\\u305b\\u307e\\u3067\\u63e1\\u624b\\u3059\\u308b\\u306e\\u304b\\u4e8c\\u5206\\u63a2\\u7d22\\u3067\\u8abf\\u3079\\u308b\\n    \\u540c\\u3058\\u30d1\\u30ef\\u30fc\\u3068\\u306a\\u308b\\u7d44\\u307f\\u5408\\u308f\\u305b\\u306b\\u6ce8\\u610f \\\"\\\"\\\"\\nN, M = lr()\\nA = np.array(lr())\\nA.sort()\\n\\ndef check(x):\\n    # x\\u4ee5\\u4e0a\\u306e\\u5e78\\u798f\\u5ea6\\u3067\\u63e1\\u624b\\u3057\\u305f\\u6642\\u3001M\\u56de\\u4ee5\\u4e0b\\u3060\\u3068True\\u3092\\u8fd4\\u3059\\n    Y = np.searchsorted(A, x - A)\\n    return N*N - Y.sum() <= M\\n\\nok = 10 ** 6; ng = 0\\nwhile abs(ng-ok) > 1:\\n    mid = (ok+ng) // 2\\n    if check(mid):\\n        ok = mid\\n    else:\\n        ng = mid\\n\\nAcum = np.zeros(N+1, np.int64)\\nAcum[1:] = A.cumsum()\\nY = np.searchsorted(A, ok-A)\\nanswer = (Acum[-1] - Acum[Y]).sum() + (A * (N-Y)).sum()\\nanswer += ng * (M - (N-Y).sum())\\nprint(answer)\\n# 24\\n\", \"def judge(k, N, A):\\n    p = N - 1\\n    t = 0\\n    for i in A:\\n        while p >= 0 and A[p] + i < k:\\n            p -= 1\\n        t += (p + 1)\\n    return t\\ndef main():\\n    N, M = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    A.sort(reverse=True)\\n    t = A[0] * 2\\n    b = 0\\n    X = None\\n    while t - b > 1:\\n        m = (t + b)//2\\n        i = judge(m, N, A)\\n        if i == M:\\n            X = m\\n            break\\n        if i > M:\\n            ip = judge(m + 1, N, A)\\n            if ip == M:\\n                X = m + 1\\n                break\\n            if ip < M:\\n                X = m\\n                break\\n            b = m + 1\\n        if i < M:\\n            im = judge(m - 1, N, A)\\n            if im >= M:\\n                X = m - 1\\n                break\\n            t = m - 1\\n    if X is None:\\n        X = b\\n    r = 0\\n    p = N - 1\\n    k = sum(A)\\n    for i in A:\\n        while p >= 0 and A[p] + i < X :\\n            k -= A[p]\\n            p -= 1\\n        r += i * (p + 1) + k\\n    return r - (judge(X, N, A) - M) * X\\nprint((main()))\\n\", \"from bisect import bisect_left\\n\\nN, M = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\n\\nA.sort()\\n\\ndef isOverEq(n):\\n    cnt = 0\\n    for a in A:\\n        cnt += N - bisect_left(A, n - a)\\n    return cnt >= M\\n\\noverEq = -1\\nless = A[-1] * 2 + 100\\nwhile less - overEq > 1:\\n    mid = (less + overEq) // 2\\n    if isOverEq(mid):\\n        overEq = mid\\n    else:\\n        less = mid\\n\\naccA = [0] * (N + 1)\\nfor i, a in enumerate(A, start=1):\\n    accA[i] = accA[i - 1] + a\\n\\nans = 0\\ncnt = 0\\nfor a in A:\\n    i = bisect_left(A, overEq - a)\\n    ans += accA[N] - accA[i]\\n    ans += (N - i) * a\\n    cnt += N - i\\n\\nans -= max(0, cnt - M) * overEq\\nprint(ans)\\n\", \"from bisect import bisect_left\\nfrom itertools import accumulate\\nN,M,*A = map(int, open(0).read().split())\\nA.sort()\\nB = list(accumulate(A[::-1]))\\nl = -1\\nr = 10**9\\nwhile l+1<r:\\n  s = (l+r)//2\\n  cnt = 0\\n  for c in A:\\n    i = bisect_left(A,s-c)\\n    cnt += N-i\\n  if cnt>=M:\\n    l = s\\n  else:\\n    r = s\\nans = 0\\nfor c in A:\\n  i = bisect_left(A,r-c)\\n  M -= N-i\\n  if i<N:\\n    ans += B[N-1-i]+c*(N-i)\\nans += M*l\\nprint(ans)\", \"import numpy as np\\n\\nn, m = list(map(int, input().split()))\\nA = np.array(input().split(), np.int64)\\nA = np.sort(A)\\n\\ndef is_ok(x):\\n    cnt = n**2-np.searchsorted(A, x-A, side='left').sum()\\n    if cnt >= m:\\n        return True\\n    else:\\n        return False\\n\\nl = 0\\nr = 2*10**5+1\\nwhile l+1 < r:\\n    c = (l+r)//2\\n    if is_ok(c):\\n        l = c\\n    else:\\n        r = c\\n\\nfrom itertools import accumulate\\nB = [0]+list(A)\\nB = list(accumulate(B))\\nans = 0\\ncnt = 0\\nfor a in A:\\n    j = np.searchsorted(A, l-a, side='left').sum()\\n    cnt += n-j\\n    ans += B[-1]-B[j]+a*(n-j)\\nans -= (cnt-m)*l\\nprint(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\nfrom bisect import bisect_left\\nfrom itertools import accumulate\\n\\ndef func(A, N, M, x):\\n    count = 0\\n    for Ai in A:\\n        idx = bisect_left(A, x - Ai)\\n        count += N - idx\\n    if count >= M:\\n        return True\\n    else:\\n        return False\\n\\ndef main():\\n    N, M = map(int, input().split())\\n    A = sorted(list(map(int, input().split())))\\n    A_rev = list(reversed(A))\\n    B = [0] + list(accumulate(A_rev))\\n \\n    min_ = 0\\n    max_ = 2 * 10 ** 5 + 1\\n    while max_ - min_ > 1:\\n        mid = (min_ + max_) // 2\\n        if func(A, N, M, mid):\\n            min_ = mid\\n        else:\\n            max_ = mid\\n    \\n    ans = 0\\n    count = 0\\n    for Ai in A_rev:\\n        idx = bisect_left(A, min_-Ai)\\n        ans += Ai * (N - idx) + B[N-idx]\\n        count += N - idx\\n    print(ans-(count-M)*min_)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import numpy as np\\nN,M,*A = list(map(int, open(0).read().split()))\\nA = np.sort(A)\\nB = np.cumsum(np.concatenate([[0],A[::-1]]))\\nl = -1\\nr = 10**6\\nwhile l+1<r:\\n  s = (l+r)//2\\n  cnt = np.sum(N-np.searchsorted(A,s-A))\\n  if cnt>=M:\\n    l = s\\n  else:\\n    r = s\\nind = np.searchsorted(A,r-A)\\nM -= np.sum(N-ind)\\nans = np.sum(B[N-ind]+A*(N-ind))+M*l\\nprint(ans)\\n\", \"def main():\\n    import bisect\\n    import numpy as np\\n    n,k = map(int,input().split())\\n    l = list(map(int,input().split()))\\n    l.sort()\\n    l = np.array(l)\\n    def bise(x):\\n        y = np.searchsorted(l,x-l)\\n        return n*n-y.sum()\\n\\n    left = -1\\n    right = l[-1]*2+1\\n\\n    while right > left+1:\\n        mid = (right+left)//2\\n        \\n        if bise(mid) >= k:\\n            left = mid\\n        else:\\n            right = mid\\n    ans = 0\\n    \\n    acc = np.zeros(n+1,np.int64)\\n    acc[1:] = l.cumsum()\\n    x = np.searchsorted(l,right-l)\\n    count = n*n-x.sum()\\n    ans = (acc[-1]-acc[x]).sum() + (l*(n-x)).sum()\\n\\n    print(ans-(count-k)*left)\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\nreadline = sys.stdin.readline\\n\\nN,M = map(int,readline().split())\\nA = sorted(list(map(int,readline().split())))\\n\\nok = -1\\nng = (10 ** 5) * 2 + 1\\n\\n# x\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u30da\\u30a2\\u3092M\\u56de\\u4ee5\\u4e0a\\u4f5c\\u308c\\u308b\\u304b\\u3001\\u3067x\\u306e\\u6700\\u5927\\u5024\\u3092\\u4e8c\\u5206\\u63a2\\u7d22\\nimport bisect\\ndef isOk(x):\\n  cnt = 0\\n  for left in A:\\n    right = x - left\\n    ind = bisect.bisect_left(A, right)\\n    cnt += N - ind\\n  return cnt >= M\\n  \\nwhile abs(ng - ok) > 1:\\n  mid = abs(ng + ok) // 2\\n  if isOk(mid):\\n    ok = mid\\n  else:\\n    ng = mid\\n\\n# ok\\u304c\\u57fa\\u6e96\\u3068\\u3059\\u3079\\u304dx\\u306e\\u5024\\u3067\\u3042\\u308b\\n\\nsumA = [0] + A.copy()\\nfor i in range(1, len(sumA)):\\n  sumA[i] += sumA[i - 1]\\n\\nans = 0\\nnum = 0\\nfor left in A:\\n  right = ok - left\\n  ind = bisect.bisect_left(A, right)\\n  num += N - ind\\n  ans += (N - ind) * left + sumA[-1] - sumA[ind]\\n  \\nif num > M:\\n  ans -= (num - M) * ok\\n  \\nprint(ans)  \", \"\\nfrom bisect import bisect_left, bisect_right\\nfrom itertools import accumulate\\ndef resolve():\\n    def shake_cnt(x):\\n        cnt = 0\\n        pos = 0\\n        for i in range(N):\\n            pos = bisect_left(A, x - A[i])\\n            cnt += N - pos\\n        return cnt < M # X\\u4ee5\\u4e0a\\u306e\\u548c\\u304cM\\u500b\\u672a\\u6e80\\u304b\\u3069\\u3046\\u304b\\n\\n    N, M = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    A.sort()\\n\\n    # \\u7d42\\u4e86\\u6642\\u306bng\\u306bX-1,ok\\u306bX\\u304c\\u5165\\u3063\\u3066\\u3044\\u308b\\u3002\\n    ng = 0\\n    ok = 10 ** 6\\n    while abs(ok - ng) > 1:\\n        mid = (ok + ng)//2\\n        if shake_cnt(mid):\\n            ok = mid\\n        else:\\n            ng = mid\\n\\n    acc = [0] + list(accumulate(A))\\n    ans = 0\\n    for i in range(N):\\n        pos = bisect_right(A, ng - A[i])\\n        cnt = N - pos\\n        ans += cnt * A[i] + (acc[N] - acc[pos])\\n        M -= cnt\\n    ans += M * ng\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    resolve()\\n\\n__starting_point()\", \"import sys\\nimport numpy as np\\n\\nsys.setrecursionlimit(10 ** 8)\\nini = lambda: int(sys.stdin.readline())\\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\\nins = lambda: sys.stdin.readline().rstrip()\\ndebug = lambda *a, **kw: print(\\\"\\\\033[33m\\\", *a, \\\"\\\\033[0m\\\", **dict(file=sys.stderr, **kw))\\n\\n\\ndef convolve(f, g):\\n    \\\"\\\"\\\"\\u591a\\u9805\\u5f0f f, g \\u306e\\u7a4d\\u3092\\u8a08\\u7b97\\u3059\\u308b\\u3002\\n\\n    Parameters\\n    ----------\\n    f : np.ndarray (int64)\\n        f[i] \\u306b\\u3001x^i \\u306e\\u4fc2\\u6570\\u304c\\u5165\\u3063\\u3066\\u3044\\u308b\\n\\n    g : np.ndarray (int64)\\n        g[i] \\u306b\\u3001x^i \\u306e\\u4fc2\\u6570\\u304c\\u5165\\u3063\\u3066\\u3044\\u308b\\n\\n\\n    Returns\\n    -------\\n    h : np.ndarray\\n        f,g \\u306e\\u7a4d\\n    \\\"\\\"\\\"\\n    # h \\u306e\\u9577\\u3055\\u4ee5\\u4e0a\\u306e n=2^k \\u3092\\u8a08\\u7b97\\n    fft_len = 1\\n    while 2 * fft_len < len(f) + len(g) - 1:\\n        fft_len *= 2\\n    fft_len *= 2\\n\\n    # \\u30d5\\u30fc\\u30ea\\u30a8\\u5909\\u63db\\n    Ff = np.fft.rfft(f, fft_len)\\n    Fg = np.fft.rfft(g, fft_len)\\n\\n    # \\u5404\\u70b9\\u7a4d\\n    Fh = Ff * Fg\\n\\n    # \\u30d5\\u30fc\\u30ea\\u30a8\\u9006\\u5909\\u63db\\n    h = np.fft.irfft(Fh, fft_len)\\n\\n    # \\u5c0f\\u6570\\u306b\\u306a\\u3063\\u3066\\u3044\\u308b\\u306e\\u3067\\u3001\\u6574\\u6570\\u306b\\u307e\\u308b\\u3081\\u308b\\n    h = np.rint(h).astype(np.int64)\\n\\n    return h\\n\\n\\nN, M = inl()\\nA = inl()\\n\\npower = np.zeros(10 ** 5 + 1, dtype=np.int64)\\nfor i in range(N):\\n    power[A[i]] += 1\\n\\nP = convolve(power, power)\\n\\nr = M\\nans = 0\\nfor k in range(len(P) - 1, -1, -1):\\n    c = min(P[k], r)\\n    ans += k * c\\n    r -= c\\n    if r <= 0:\\n        break\\n\\nprint(ans)\\n\", \"import numpy as np\\nfrom numpy.fft import rfft,irfft\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\ndef mi(): return list(map(int,input().split()))\\ndef ii(): return int(input())\\ndef isp(): return input().split()\\ndef deb(text): print((\\\"-------\\\\n{}\\\\n-------\\\".format(text)))\\n\\nINF=10**20\\nclass Polynomial:\\n    def __init__(self,dim=0,const=1):\\n        self.values = [(dim,const)]\\n    def __add__(self,other):\\n        return self.values + other.values\\n\\n\\nclass PolySolver:\\n    def __init__(self,size,init_val=1):\\n        self.size = size\\n        self.f = np.zeros(size, np.int64)\\n        self.f[0] = init_val\\n\\n\\n    def multiple(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \\u3092f\\u306b\\u304b\\u3051\\u5408\\u308f\\u305b\\u308b\\n        new_F = np.zeros(self.size, np.int64)\\n        for dim,const in polynomial:\\n            if dim != 0:\\n                g = np.zeros(self.size, np.int64)\\n                g[dim:] += self.f[:-dim] # dim\\u5206\\u4fc2\\u6570\\u60c5\\u5831\\u3092\\u305a\\u3089\\u3059\\n            else:\\n                g = const * self.f.copy()\\n\\n            new_F += g\\n\\n        self.f = new_F\\n        \\n    \\n    def add(self,polynomial): # const1 * x^dim1 + const2 * x^dim2 + ... \\u3092f\\u306b\\u8db3\\u3059\\n        for dim,const in polynomial:\\n            self.f[dim] += const\\n            \\n\\n    def get_coefficient(self,dim):\\n        return self.f[dim]\\n\\n    def fft(self,A,B,fft_len=1<<18):\\n        x = irfft(rfft(A,fft_len) * rfft(B,fft_len))\\n        return np.rint(x).astype(np.int64)\\n\\n    def convolve(self,g):\\n        h = self.fft(self.f,g)[:len(self.f) + len(g) - 1]\\n        self.f = h\\n    \\n\\n\\ndef main():\\n    N,M=mi()\\n    A=list(mi())\\n    \\n    mx = 2*10**5+10\\n    F = PolySolver(mx,init_val=0)\\n    for a in A:\\n        F.add(Polynomial(dim=a).values)\\n    \\n    g = F.f\\n    F.convolve(g)\\n\\n    ans = 0\\n    handshake = M\\n    for x in range(mx-1,1,-1):\\n        count = F.get_coefficient(x)\\n        if count <= 0: continue\\n\\n        if count > handshake:\\n            ans += handshake * x\\n        else:\\n            ans += count * x\\n \\n        handshake = max(handshake-count,0)\\n        if handshake == 0:\\n            break\\n\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import sys\\nimport  math\\nimport fractions\\nfrom collections import defaultdict\\nimport bisect\\nstdin = sys.stdin\\n     \\nns = lambda: stdin.readline().rstrip()\\nni = lambda: int(stdin.readline().rstrip())\\nnm = lambda: list(map(int, stdin.readline().split()))\\nnl = lambda: list(map(int, stdin.readline().split()))\\n\\nN,M=nm()\\nA=nl()\\nA.sort()\\nS=[0]\\nS[0]=A[0]\\n\\nfor i in range(1,N):\\n    S.append(S[i-1]+A[i])\\n\\ndef clc_shake(x):#x\\u4ee5\\u4e0a\\u306e\\u548c\\n    tot=0\\n    for i in range(N):\\n        th=x-A[i]\\n        inds=bisect.bisect_left(A,th)\\n        tot+=(N-inds)\\n    return tot\\n\\nl=0\\nr=2*(10**6)\\nc=0\\n\\nwhile (l+1<r):\\n    c=(l+r)//2\\n    if(clc_shake(c)<M):\\n        r=c\\n    else:\\n        l=c\\n\\n\\nans=0\\nfor i in range(N):\\n        th=r-A[i]\\n        inds=bisect.bisect_left(A,th)\\n        if(inds!=0):\\n            ans+=((N-inds)*A[i]+(S[N-1]-S[inds-1]))\\n        else:\\n            ans+=((N-inds)*A[i]+(S[N-1]))\\n\\n\\nM2=M-clc_shake(r)\\nans+=M2*(l)\\nprint(ans)\\n\\n\\n\\n\", \"import bisect\\nn,m = list(map(int,input().split()))\\nA = list(map(int,input().split()))\\nA.sort()\\nS = [0]*(n+1)\\nfor i in range(n):\\n    S[i+1] = S[i] + A[i]\\n\\ndef cnt(x,A,S):\\n    res = 0\\n    for i,a in enumerate(A):\\n        res += bisect.bisect_left(A,x - a)\\n    return res\\n\\ndef ans(x,A,S):\\n    res = 0\\n    for i,a in enumerate(A):\\n        res += a*bisect.bisect_left(A,x-a) + S[bisect.bisect_left(A,x-a)]\\n    return res\\n\\ntop = A[-1]*2+1\\nbottom = 0\\n# mid\\u4ee5\\u4e0a\\u304c\\u4f55\\u500b\\u3042\\u308b\\u304b\\nwhile top - bottom > 1:\\n    mid = (top + bottom)//2\\n    if n*n - cnt(mid,A,S) > m:\\n        bottom = mid\\n    else:\\n        top = mid\\n\\nprint((S[-1]*2*n - ans(top,A,S) + bottom*(m - (n*n - cnt(top,A,S)))))\\n\", \"from bisect import bisect_left\\ndef check(x):\\n  cnt=0\\n  l=n\\n  r=n\\n  for i in range(n):\\n    while True:\\n      if l==0:\\n        break\\n      if a[l-1]<x-a[i]:\\n        break\\n      l-=1\\n    cnt+=(r-l)\\n  return cnt>=m\\n\\nn,m=list(map(int,input().split()))\\na=list(map(int,input().split()))\\na.sort()\\nok=0\\nng=2*10**5+10\\n# \\u5e78\\u798f\\u5ea6\\u304c\\u4e0a\\u4f4dm\\u500b\\u306b\\u5165\\u308b\\u6700\\u5c0f\\u306eAx+Ay\\u3092\\u4e8c\\u5206\\u63a2\\u7d22\\u3059\\u308b\\u3002\\nwhile abs(ok-ng)>1:\\n  mid=(ok+ng)//2\\n  if check(mid):\\n    ok=mid\\n  else:\\n    ng=mid\\n\\nru=[0]*(n+1)\\nfor i in range(n):\\n  ru[i+1]=ru[i]+a[i]\\n\\nans=0\\ncnt=0\\nr=n\\n# \\u5e78\\u798f\\u5ea6\\u304c\\u4e0a\\u4f4dm\\u500b\\u306b\\u5165\\u308bAx+Ay\\u306e\\u6700\\u5c0f\\u5024\\u306e\\u307fm\\u500b\\u306e\\u500b\\u6570\\u5236\\u9650\\u304b\\u3089\\u6ea2\\u308c\\u3066\\u3057\\u307e\\u3046\\u5834\\u5408\\u304c\\u3042\\u308b\\u306e\\u3067\\u5225\\u306b\\u8003\\u3048\\u308b\\nok=ok+1 # Ax+Ay\\u306e\\u6700\\u5c0f\\u5024\\u3088\\u308a\\u5927\\u304d\\u306a\\u5024\\u3092\\u5148\\u306b\\u51e6\\u7406\\u3059\\u308b\\u305f\\u3081\\u306b\\u6700\\u5c0f\\u5024+1\\u3092\\u3059\\u308b\\u3002\\nfor i in range(n):\\n  # \\u6700\\u5c0f\\u5024\\u4ee5\\u5916\\u306e\\u51e6\\u7406\\n  l=bisect_left(a,ok-a[i])\\n  cnt+=r-l\\n  ans+=(r-l)*a[i]+(ru[r]-ru[l])\\nans+=(ok-1)*(m-cnt) # \\u6700\\u5c0f\\u5024\\u306e\\u51e6\\u7406\\nprint(ans)\\n\", \"from bisect import bisect_left\\n\\nN,M=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\n\\nA.sort()\\n\\nl=1\\nr=200000+1\\n\\ndef chk(x):\\n    c=0\\n    for la in A:\\n        y=bisect_left(A,x-la)\\n        c+=N-y\\n    if c>=M:\\n        return True\\n    else:\\n        return False\\n\\n\\n\\nwhile l+1<r:\\n    mid=(l+r)//2\\n    if chk(mid):\\n        l=mid\\n    else:\\n        r=mid\\n\\nAN=l\\n\\nS=[0]*(N+1)\\n\\nfor i in range(N):\\n    S[i+1]=S[i]+A[i]\\n\\nans1=0\\nc=0\\nfor la in A:\\n    ll = -1\\n    rr = N\\n    while ll + 1 < rr:\\n        mi = (ll + rr) // 2\\n        if A[mi] > AN - la:\\n            rr = mi\\n        else:\\n            ll = mi\\n    c+=N-rr\\n    ans1=ans1+la*(N-rr)+S[N]-S[rr]\\n\\nans=ans1+(M-c)*AN\\nprint(ans)\\n\\n\\n\", \"def main():\\n    import numpy as np\\n    n,m=list(map(int,input().split()))\\n    A=list(map(int,input().split()))\\n    A.sort()\\n    A=np.array(A)\\n\\n    def cnt_shake(x): #\\u63e1\\u624b\\u306e\\u7d44\\u3067\\u3042\\u3063\\u3066\\u5408\\u8a08\\u30d1\\u30ef\\u30fc\\u304cx\\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u7d44\\u307f\\u306e\\u6570\\n        return n**2-np.searchsorted(A,x-A).sum()\\n  \\n    right=2*10**5+1\\n    left=-1\\n    while right-left>1:\\n        mid=(left+right)//2\\n        if cnt_shake(mid)<m:\\n            right=mid\\n        else:\\n            left=mid\\n    \\n    border=left  #border\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u3059\\u308b\\n    C=n-np.searchsorted(A,border+1-A)\\n    B=np.cumsum(A[::-1])\\n    cnt=C.sum()\\n    s=np.sum(A*C)+border*(m-cnt)+B[C[np.where(C>0)]-1].sum()\\n    print(s)\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def main():\\n    import numpy as np\\n    n,m=list(map(int,input().split()))\\n    A=list(map(int,input().split()))\\n    A.sort()\\n    A=np.array(A)\\n\\n    def cnt_shake(x): #\\u63e1\\u624b\\u306e\\u7d44\\u3067\\u3042\\u3063\\u3066\\u5408\\u8a08\\u30d1\\u30ef\\u30fc\\u304cx\\u4ee5\\u4e0a\\u3068\\u306a\\u308b\\u7d44\\u307f\\u306e\\u6570\\n        return n**2-np.searchsorted(A,x-A).sum()\\n  \\n    right=10**10*1\\n    left=-10**10-1\\n    while right-left>1:\\n        mid=(left+right)//2\\n        if cnt_shake(mid)<m:\\n            right=mid\\n        else:\\n            left=mid\\n    \\n    border=left  #border\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u3092\\u3059\\u308b\\n    C=n-np.searchsorted(A,border+1-A)\\n    B=np.cumsum(A[::-1])\\n    #print(border,A,B,C)\\n\\n    s,cnt=0,0\\n    for i in range(n):\\n        if C[i]>0:\\n          cnt+=C[i]\\n          s+=B[C[i]-1]+A[i]*C[i]\\n    s+=border*(m-cnt)\\n\\n    print(s)\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"#!/usr/bin/env python3\\n#import sys; sys.stdin=open('input_file.txt')\\n#------------------------------------------\\nimport numpy as np\\n\\nN,M = list(map(int,input().split()))\\nA = np.array(input().split(),np.int64)\\n\\nA = np.sort(A)\\nS = np.zeros(N+1,np.int64)\\nS[1:]= np.cumsum(A)\\n\\nhi = 200001\\nlo = -1\\n\\nwhile hi-lo > 1:\\n    mid = (hi+lo)//2\\n    above_mid = (N-np.searchsorted(A,mid-A,side='left')).sum()\\n    if above_mid >= M:\\n        lo = mid\\n    else:\\n        hi = mid\\n\\nX = np.searchsorted(A,hi-A,side='left')\\n\\nabove_hi = (N-X).sum()\\nhappiness = (S[-1]-S[X]).sum()\\nhappiness += (A*(N-X)).sum()\\nhappiness += (M-above_hi)*lo\\n\\nprint(happiness)\\n\", \"import numpy as np\\nfrom numpy.fft import rfft,irfft\\nimport sys\\nsys.setrecursionlimit(10**9)\\n\\ndef mi(): return list(map(int,input().split()))\\ndef ii(): return int(input())\\ndef isp(): return input().split()\\ndef deb(text): print((\\\"-------\\\\n{}\\\\n-------\\\".format(text)))\\n\\nINF=10**20\\nclass Polynomial:\\n    def __init__(self,coefficient=None,dim=0,const=1):\\n        if coefficient == None:\\n            self.coefficient = np.zeros(dim+1, np.int64)\\n            self.coefficient[dim] = const\\n        else:\\n            self.coefficient = coefficient\\n\\n    def __add__(self,other): # +\\n        f,g = self.coefficient, other.coefficient\\n        if len(f) > len(g): f,g = g,f\\n\\n        h = Polynomial(dim=len(g)-1,const=0)\\n        h.coefficient[len(f):] += g[len(f):]\\n        h.coefficient[:len(f)] += f + g[:len(f)]\\n        return h\\n    \\n    def __iadd__(self,other): # +=\\n        h = self.__add__(other)\\n        self.coefficient = h.coefficient\\n        return self\\n\\n    def __mul__(self,other): # *\\n        f = self.coefficient\\n        g = other.coefficient\\n        h = Polynomial()\\n        h.coefficient = self.fft(f,g)[:len(f)+len(g)-1]\\n        return h\\n    \\n    def __len__(self):\\n        return len(self.coefficient)\\n\\n    def __getitem__(self,key):\\n        return self.coefficient[key]\\n\\n    def get_coefficient(self,x):\\n        return self.coefficient[x]\\n\\n\\n    def fft(self,A,B,fft_len=1<<18):\\n        x = irfft(rfft(A,fft_len) * rfft(B,fft_len))\\n        return np.rint(x).astype(np.int64)\\n\\n\\n\\ndef main():\\n    N,M=mi()\\n    A=list(mi())\\n    \\n    coefficient = [0] * (2*10**5+10)\\n    for a in A:\\n        coefficient[a] += 1\\n    \\n    f = Polynomial(coefficient=coefficient)\\n            \\n    g = f * f\\n    ans = 0\\n    handshake = M\\n    for x in range(len(g)-1,1,-1):\\n        count = g[x]\\n        if count <= 0: continue\\n\\n        if count > handshake:\\n            ans += handshake * x\\n        else:\\n            ans += count * x\\n \\n        handshake = max(handshake-count,0)\\n        if handshake == 0:\\n            break\\n\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from bisect import bisect_left\\n\\ndef main():\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    L, R = 0, 2 * 10**5 + 1\\n    while L+1 < R:\\n        P = (L+R)//2\\n        cnt = 0\\n        for v in a:\\n            x = P - v\\n            cnt += n - bisect_left(a, x)\\n        if cnt >= m:\\n            L = P\\n        else:\\n            R = P\\n    csum = [0]\\n    for v in a:\\n        csum.append(v)\\n    for i in range(n):\\n        csum[i+1] += csum[i]\\n    ans = 0\\n    cnt = 0\\n    for v in a:\\n        x = L - v\\n        idx = bisect_left(a, x)\\n        cnt += n-idx\\n        ans += csum[-1] - csum[idx]\\n        ans += v * (n - idx)\\n    ans -= (cnt - m) * L\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"from bisect import bisect_right as br\\nn,m=map(int,input().split())\\na=list(map(int,input().split()))\\nfor i in range(n):a[i]*=-1\\na.sort()\\nb=[0]\\nfor i in a:b.append(b[-1]+i)\\nng=2*10**5+7\\nok=-1\\nwhile ok+1!=ng:\\n  mid=(ng+ok)//2\\n  co=0\\n  for i in a:co+=br(a,-(mid+i))\\n  if co<m:ng=mid\\n  else:ok=mid\\nans=0\\nco=0\\nfor i in a:\\n  ind=br(a,-(ok+i)-1)\\n  co+=ind\\n  ans+=-b[ind]-i*ind\\nans+=(m-co)*ok\\nprint(ans)\", \"import numpy as np\\nfrom numpy.fft import rfft,irfft\\n\\ndef main():\\n    n,m=map(int,input().split())\\n    A=np.array(list(map(int,input().split())))\\n    F=np.bincount(A)\\n    fft_len=2*10**5+1\\n    Ff=rfft(F,fft_len)\\n    G=np.rint(irfft(Ff*Ff,fft_len)).astype(np.int64)\\n    G_acc=G.cumsum()\\n    remove_cnt=n**2-m\\n    border=np.searchsorted(G_acc,n**2-m)\\n    x=n**2-m-G_acc[border-1]\\n    remove_sum=(G[:border]*np.arange(border)).sum()+border*x\\n    ans=A.sum()*2*n-remove_sum\\n    print(ans)\\n    \\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import bisect\\ndef judge(k, N, A):\\n    t = 0\\n    for i in A:\\n        j = bisect.bisect_left(A, k - i)\\n        t += N - j\\n    return t\\ndef main():\\n    N, M = list(map(int, input().split()))\\n    A = list(map(int, input().split()))\\n    A.sort()\\n    t = A[-1] * 2\\n    b = 0\\n    X = None\\n    while t - b > 1:\\n        m = (t + b)//2\\n        i = judge(m, N, A)\\n        if i == M:\\n            X = m\\n            break\\n        if i > M:\\n            ip = judge(m + 1, N, A)\\n            if ip == M:\\n                X = m + 1\\n                break\\n            if ip < M:\\n                X = m\\n                break\\n            b = m + 1\\n        if i < M:\\n            im = judge(m - 1, N, A)\\n            if im >= M:\\n                X = m - 1\\n                break\\n            t = m - 1\\n    if X is None:\\n        X = b\\n    B = []\\n    tmp = 0\\n    for i in reversed(list(range(N))):\\n        tmp += A[i]\\n        B.append(tmp)\\n    B.reverse()\\n    r = 0\\n    tot = 0\\n    for i in reversed(list(range(N))):\\n        j = bisect.bisect_left(A, X - A[i])\\n        tot += N - j\\n        if j == N:\\n            break\\n        r += A[i] * (N - j) + B[j]\\n    return r - (tot - M) * X\\nprint((main()))\\n\", \"n, m = map(int, input().split())\\na = list(map(int, input().split()))\\na.sort(reverse=True)\\n\\n# l[i] = (a[j] >= i \\u3092\\u6e80\\u305f\\u3059j\\u306e\\u500b\\u6570)\\nl = [n for i in range(a[0]+1)]\\nfor i in range(2, n+1):\\n    for j in range(a[-i], a[-i+1], -1):\\n        l[j] = n - i + 1\\n\\n# \\u4e8c\\u5206\\u63a2\\u7d22\\n# a[i] + a[j] >= x \\u3092\\u6e80\\u305f\\u3059(i, j)\\u304cm\\u7d44\\u4ee5\\u4e0a\\u5b58\\u5728\\u3059\\u308b\\u6700\\u5c0f\\u306ex\\u3092\\u6c42\\u3081\\u308b\\nstart = 2 * a[-1]\\nstop = 2 * a[0]\\nwhile start < stop:\\n    i = (start + stop + 1) // 2\\n    num = 0\\n    for j in a:\\n        if i - j < 0:\\n            num += n\\n        elif i - j <= a[0]:\\n            num += l[i - j]\\n        else:\\n            break\\n\\n    if num >= m:\\n        start = i\\n    else:\\n        stop = i - 1\\n\\nnum = 0\\nfor i in a:\\n    if start - i < 0:\\n        num += n\\n    elif 0 <= start - i <= a[0]:\\n        num += l[start - i]\\n    else:\\n        break\\n\\n# start <= a[i]+a[j] \\u3092\\u6e80\\u305f\\u3059 a[i]+a[j] \\u3092\\u5168\\u3066\\u8db3\\u3059\\nans = 0\\nfor i in a:\\n    if start - i < 0:\\n        ans += 2 * i * n\\n    elif start - i <= a[0]:\\n        ans += 2 * i * l[start - i]\\n    else:\\n        break\\nans -= (num - m) * start\\nprint(ans)\", \"from bisect import bisect_left,bisect_right\\nfrom itertools import accumulate\\n\\nn,m=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\nA.sort()\\n\\ndef isOK(x):\\n    num=0\\n    for k,a in enumerate(A,start=1):\\n        i=bisect_left(A,x-a)\\n        num+=n-i\\n    return num>=m\\n\\n\\n\\nl=0\\nr=2*10**5+1\\nwhile l+1<r:\\n    mid=(l+r)//2\\n    if isOK(mid):\\n        l=mid\\n    else:\\n        r=mid\\n\\ns=0\\nnum=0\\n\\nacc=list(accumulate([0]+A))\\n\\nfor a in A:\\n    i=bisect_right(A,l-a)\\n    s+=a*(n-i)+acc[n]-acc[i]\\n    num+=n-i\\n\\nans=s+l*(m-num)\\n\\nprint(ans)\\n\", \"from bisect import bisect_left\\ndef main():\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split()))\\n    a.sort()\\n    b = [0]*(n+1)\\n    for i in range(n):\\n        b[i+1] = a[i] + b[i]\\n    ok = 0; ng = 2 * 10**5 + 5\\n    while ok+1 < ng:\\n        mid = (ok + 1 + ng) // 2\\n        buf = 0\\n        for i in range(n):\\n            p = mid - a[i]\\n            buf += n - bisect_left(a, p)\\n        if buf >= m:\\n            ok = mid\\n        else:\\n            ng = mid\\n    ans = 0\\n    num = 0\\n    tot = 0\\n    for i in range(n):\\n        p = ok - a[i]\\n        index = bisect_left(a, p)\\n        num += n - index\\n        tot += b[n] - b[index]\\n        tot += a[i] * (n-index)\\n    ans = tot - (num - m) * ok\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import bisect\\nfrom itertools import accumulate\\nN,M = map(int,input().split())\\nA = sorted(list(map(int,input().split())))\\nA2 = [0]+list(accumulate(A))\\ndef judge(mid):\\n    count = 0\\n    for i in range(N):\\n        border = mid - A[i]\\n        ind = bisect.bisect_left(A,border)\\n        count += N-ind\\n    if count < M:\\n        return True\\n    else:\\n        return False\\nmina = 0\\nmaxa = 2*(10**5) + 1\\nwhile maxa-mina > 1:\\n    mid = (maxa+mina)//2\\n    if judge(mid):\\n        maxa = mid\\n    else:\\n        mina = mid\\ncount = 0\\nans = 0\\nfor i in range(N):\\n    border = maxa - A[i]\\n    ind = bisect.bisect_left(A,border)\\n    count += N-ind\\n    ans += A[i]*(N-ind) + A2[N]-A2[ind]\\nif count == M:\\n    print(ans)\\nelse:\\n    rem = M-count\\n    print(ans+rem*mina)\", \"######################\\n# AC: ms(PyPy)\\n# AC: ms(Python3)\\n######################\\n\\nfrom bisect import bisect_left\\nimport sys\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N,M = list(map(int, input().split()))\\n    A = [int(i) for i in input().split()]\\n\\n    A.sort()\\n\\n    left = 0\\n    right = A[-1] * 2 + 5\\n    while right - left > 1:\\n        X = (left + right) // 2\\n\\n        count = 0\\n        for a in A:\\n            i = bisect_left(A, X-a)\\n            count += (N - i)\\n\\n        if count >= M:\\n            left = X\\n        else:\\n            right = X\\n\\n    count = 0\\n    num = []\\n    append = num.append\\n    for a in A:\\n        i = bisect_left(A, left-a)\\n        count += (N - i)\\n        append(N - i)\\n\\n    diff = count - M\\n    ans = 0\\n    for i, a in zip(num, A):\\n        ans += i * a\\n\\n    print((ans * 2 - diff * left))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from bisect import bisect_left\\nfrom itertools import accumulate\\nN,M,*A = list(map(int, open(0).read().split()))\\nA.sort()\\nB = list(accumulate(A[::-1]))\\nl = -1\\nr = 10**6\\nwhile l+1<r:\\n  s = (l+r)//2\\n  cnt = 0\\n  for c in A:\\n    i = bisect_left(A,s-c)\\n    cnt += N-i\\n  if cnt>=M:\\n    l = s\\n  else:\\n    r = s\\nans = 0\\nfor c in A:\\n  i = bisect_left(A,r-c)\\n  M -= N-i\\n  if i<N:\\n    ans += B[N-1-i]+c*(N-i)\\nans += M*l\\nprint(ans)\\n\", \"\\nfrom bisect import bisect_left\\nfrom itertools import accumulate\\ndef resolve():\\n    def getCount(x):\\n        count = 0\\n        for Ai in A:\\n            idx = bisect_left(A, x - Ai)\\n            count += N - idx\\n        return count >= M\\n\\n\\n    N, M = list(map(int, input().split()))\\n    A = sorted(map(int, input().split()))\\n    A_r = A[::-1]\\n    B = [0] + list(accumulate(A_r))\\n\\n    MIN = 0\\n    MAX = 2 * 10 ** 5 + 1\\n    while MAX - MIN > 1:\\n        MID = (MIN + MAX) // 2\\n        if getCount(MID):\\n            MIN = MID\\n        else:\\n            MAX = MID\\n\\n    ans = 0\\n    count = 0\\n\\n    for Ai in A_r:\\n        idx = bisect_left(A, MIN - Ai)\\n        ans += Ai * (N - idx) + B[N - idx]\\n        count += N - idx\\n    print((ans - (count - M) * MIN))\\n\\n\\ndef __starting_point():\\n    resolve()\\n\\n__starting_point()\", \"from itertools import accumulate\\n\\nn, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nMAX = 10 ** 5\\n\\nscores = [0] * (2 * MAX + 1)\\nfor e in a:\\n    scores[e] += 1\\n\\nacc = list(accumulate(scores))\\n\\n\\ndef f(x):\\n    cnt = 0\\n    for e in a:\\n        cnt += n - acc[max(0, x - e - 1)]\\n\\n    return cnt\\n\\n\\nl = 0\\nr = 2 * MAX + 1\\nwhile r - l > 1:\\n    mid = (l + r) // 2\\n    if f(mid) >= m:\\n        l = mid\\n    else:\\n        r = mid\\n\\nscores_sum = [i * e for i, e in enumerate(scores)]\\nacc_sum = list(accumulate(scores_sum))\\nsm = sum(a)\\nans = 0\\ncnt_sum = 0\\nfor e in a:\\n    i = max(0, l - e - 1)\\n    cnt = n - acc[i]\\n    ans += e * cnt + sm - acc_sum[i]\\n    cnt_sum += cnt\\n\\nans -= (cnt_sum - m) * l\\n\\nprint(ans)\\n\", \"N, M = map(int, input().split())\\nA = [int(c) for c in input().split()]\\nA.sort(reverse=True)\\nB = A[::-1]\\nl = 0\\nr = 10**6\\ndef f(m):\\n  cnt = 0\\n  j = 0\\n  for i in range(N):\\n    while j<N:\\n      if A[i]+B[j]>=m:\\n        cnt += N-j\\n        break\\n      j += 1\\n  return cnt>=M\\nwhile l+1<r:\\n  n = (l+r)//2\\n  if f(n):\\n    l = n\\n  else:\\n    r = n\\nC = [0]\\nfor i in range(N):\\n  C += [C[-1]+B[i]]\\nans = 0\\nj = 0\\nm = 0\\nflag = False\\nfor i in range(N):\\n  while j<N:\\n    if A[i]+B[j]>l:\\n      ans += C[-1]-C[j]+A[i]*(N-j)\\n      m += N-j\\n      break\\n    j += 1\\nans += (M-m)*l\\nprint(ans)\", \"import sys\\nreadline = sys.stdin.readline\\n\\nN,M = map(int,readline().split())\\nA = list(map(int,readline().split()))\\n\\nMAX_VAL = 10 ** 5 + 1\\nhand = [0] * MAX_VAL\\nfor a in A:\\n  hand[a] += 1\\n  \\nimport numpy as np\\ndef convolve(f, g):\\n    fft_len = 1\\n    while 2 * fft_len < len(f) + len(g) - 1:\\n        fft_len *= 2\\n    fft_len *= 2\\n    \\n    Ff = np.fft.rfft(f, fft_len)\\n    Fg = np.fft.rfft(g, fft_len)\\n\\n    Fh = Ff * Fg\\n\\n    h = np.fft.irfft(Fh, fft_len)\\n    h = np.rint(h).astype(np.int64)\\n\\n    return h[:len(f) + len(g) - 1]\\n\\nright_hand = np.array(hand, dtype = int)\\nleft_hand = np.array(hand, dtype = int)\\n\\nH = convolve(left_hand, right_hand)\\n# H\\u3092\\u5927\\u304d\\u3044\\u307b\\u3046\\u304b\\u3089\\u898b\\u3066\\u3044\\u304f\\u3068\\u3001\\n# \\u5e78\\u798f\\u5ea6i\\u306e\\u63e1\\u624b\\u3092H[i]\\u7a2e\\u985e\\u3067\\u304d\\u308b\\u3053\\u3068\\u304c\\u5206\\u304b\\u308b\\n# \\u4e0a\\u304b\\u3089\\u9806\\u306b\\u8db3\\u3057\\u3066\\u3044\\u3063\\u3066\\u3001\\u6700\\u5f8cH[i]\\u7a2e\\u985e\\u306e\\u63e1\\u624b\\u3092\\u8db3\\u305b\\u306a\\u3044\\u3068\\u304d\\u306f\\u3001\\u6b8b\\u308a\\u306e\\u63e1\\u624b\\u56de\\u6570\\u3060\\u3051\\u8db3\\u3059\\n\\nans = 0\\nfor i in range(len(H) - 1, -1, -1):\\n  if H[i] == 0:\\n    continue\\n  if H[i] <= M: # H[i]\\u56de\\u306e\\u63e1\\u624b\\u304c\\u3067\\u304d\\u308b\\n    ans += i * H[i]\\n    M -= H[i]\\n  else: # H[i]\\u56de\\u306e\\u63e1\\u624b\\u304c\\u3067\\u304d\\u306a\\u3044\\u306e\\u3067\\u3001\\u6b8b\\u3063\\u305f\\u56de\\u6570\\u3060\\u3051\\u63e1\\u624b\\u3059\\u308b\\n    ans += M * i\\n    break\\n\\nprint(ans)\", \"from bisect import bisect_left\\n\\n\\ndef solve(m):\\n    r = N - 1\\n    l = 0\\n    cnt = 0\\n    while 0 <= r and l < N:\\n        if A[r] + A[l] < m:\\n            l += 1\\n        else:\\n            cnt += N - l\\n            r -= 1\\n    return cnt\\n\\n\\nN, M = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nA.sort()\\nS = [0] * (N + 1)\\nfor i in range(N):\\n    S[i + 1] = S[i] + A[i]\\n\\n# [ok, ng) - Maximum\\n# (ng, ok] - Minimum\\n# ok \\u304c \\u6700\\u7d42\\u7684\\u306a\\u7b54\\u3048\\nok = 0\\nng = 10 ** 21\\nwhile abs(ok - ng) > 1:\\n    mid = (ok + ng) // 2\\n    cnt = solve(mid)\\n    if cnt >= M:\\n        ok = mid\\n    else:\\n        ng = mid\\n\\nX = ok\\namari = float('inf')\\ncnt = 0\\nscore = 0\\nfor i, Ai in enumerate(A):\\n    Aj = X - Ai\\n    j = bisect_left(A, Aj)\\n    score += S[N] - S[j] + Ai * (N - j)\\n    cnt += N - j\\n    if j < N:\\n        amari = min(amari, A[i] + A[j])\\n\\nprint((score - (cnt - M) * amari))\\n\", \"\\nimport sys\\ninput = sys.stdin.readline\\n# \\u6587\\u5b57\\u5217\\u3092input()\\u3057\\u305f\\u5834\\u5408\\u3001\\u672b\\u5c3e\\u306b\\u6539\\u884c\\u304c\\u5165\\u308b\\u306e\\u3067\\u6ce8\\u610f\\ndef main():\\n  n,m=list(map(int,input().split()))\\n  a=sorted(list(map(int,input().split())))\\n  import bisect\\n  # \\u89e3\\u8aac\\u306e\\u4e8c\\u5206\\u63a2\\u7d22\\n  # \\u3042\\u308bX\\u3092\\u5b9a\\u3081\\u3001X\\u4ee5\\u4e0a\\u306b\\u306a\\u308b\\u63e1\\u624b\\u306e\\u7d44\\u307f\\u5408\\u308f\\u305b\\u304c\\u4f55\\u901a\\u308a\\u3042\\u308b\\u304b\\u8a08\\u7b97\\u3002M\\u500b\\u4ee5\\u4e0a\\u306b\\u306a\\u308b\\u6700\\u5927\\u306eX\\u3092\\u63a2\\u3059\\n  # [l,r)\\u534a\\u958b\\u533a\\u9593\\n  l,r=0,a[-1]*2+1\\n  while r-l>1:\\n    x=(l+r)//2\\n    cnt=0\\n    for ai in a:\\n      cnt+=n-bisect.bisect_left(a,x-ai)\\n    # x\\u4ee5\\u4e0a\\u304cm\\u500b\\u4ee5\\u4e0a\\u3042\\u308b->x~r-1\\u306b\\u6c42\\u3081\\u308b\\u3082\\u306e\\u304c\\u3042\\u308b\\n    if cnt>=m:\\n      l=x\\n    else:# x\\u4ee5\\u4e0a\\u304cm\\u500b\\u672a\\u6e80\\u3042\\u308b->l~x-1\\u306b\\u6c42\\u3081\\u308b\\u3082\\u306e\\u304c\\u3042\\u308b\\n      r=x\\n  x=(l+r)//2\\n  ans=0\\n  cnt=0\\n  a_=0\\n  cs_a=[0]\\n  for ai in a:\\n    a_+=ai\\n    cs_a.append(a_)\\n  for ai in a:\\n    bi=bisect.bisect_right(a,x-ai)\\n    cnt+=n-bi\\n    ans+=cs_a[-1]-cs_a[bi]+(n-bi)*ai\\n  print((ans+(m-cnt)*x))\\n\\ndef __starting_point():\\n  #import datetime\\n  #print(datetime.datetime.now())\\n  main()\\n  #print(datetime.datetime.now())\\n\\n__starting_point()\", \"n, m = map(int, input().split())\\na = sorted(list(map(int, input().split())), reverse=True)\\na_rev = a[::-1]\\n\\nok, ng = 1, 200001\\nwhile ng-ok > 1:\\n\\tx = (ok+ng)//2\\n\\tnum = 0\\n\\tcur = 0\\n\\tfor i in range(n-1, -1, -1):\\n\\t\\twhile cur < n and a[i] + a[cur] >= x:\\n\\t\\t\\tcur += 1\\n\\t\\tnum += cur\\n\\tif num < m:\\n\\t\\tng = x\\n\\telse:\\n\\t\\tok = x\\njust = ok\\n\\nans = 0\\nlarger_cnt = 0\\ncur = 0\\n\\na_cum = [0]\\nfor i in range(n):\\n\\ta_cum.append(a_cum[-1] + a[i])\\n\\nfor i in range(n):\\n\\twhile cur < n and a[i] + a_rev[cur] <= just:\\n\\t\\tcur += 1\\n\\tlarger_cnt += n - cur\\n\\tans += (n - cur) * a[i] + a_cum[n - cur]\\n\\nans += just * (m - larger_cnt)\\nprint(ans)\", \"from bisect import bisect_left\\nN, M = list(map(int, input().split()))\\nA = list(map(int, input().split()))\\nA.sort()\\n\\n\\ndef get_count(tot):\\n    '''\\n    tot\\u4ee5\\u4e0a\\u3092\\u6e80\\u305f\\u3059\\u5e78\\u798f\\u5ea6\\u306e\\u63e1\\u624b\\u306e\\u500b\\u6570\\u3092\\u6570\\u3048\\u308b\\n    '''\\n    ret = 0\\n    for i in range(N):\\n        cnt = bisect_left(A, tot-A[i])\\n        ret += N - cnt\\n    return ret\\n\\n\\n# \\u53f3\\u304b\\u3089\\u306e\\u7d2f\\u7a4d\\u548c\\nAsum = A[:]\\nfor i in range(N-2, -1, -1):\\n    Asum[i] += Asum[i+1]\\n\\n\\ndef get_sum(tot):\\n    '''\\n    \\u5de6\\u7aef\\u3092\\u56fa\\u5b9a\\u3057\\u305f\\u6642\\u306e\\u53f3\\u7aef\\u306e\\u500b\\u6570\\u5206\\u3060\\u3051\\u5de6\\u7aef\\u3092\\u8db3\\u3057\\u3001\\u53f3\\u7aef\\u306e\\u533a\\u9593\\u548c\\uff08\\u7d2f\\u7a4d\\u548c\\uff09\\u3082\\u8db3\\u3059\\u3002\\n    '''\\n    ret = 0\\n    for i in range(N):\\n        idx = bisect_left(A, tot-A[i])\\n        cnt = N - idx\\n        ret += A[i]*cnt\\n        # print(idx)\\n        if idx == N:\\n            continue\\n        ret += Asum[idx]\\n        # print(f'ret = {ret}')\\n    return ret\\n\\n\\n# M\\u56de\\u63e1\\u624b\\u3067\\u304d\\u308b\\u4e0a\\u9650\\u3092\\u6c42\\u3081\\u308b\\nok = 0\\nng = 10**12\\nwhile ok + 1 != ng:\\n    md = (ok + ng)//2\\n    if M <= get_count(md):\\n        ok = md\\n    else:\\n        ng = md\\n# print(ok)\\n# print(get_sum(ok+1))\\n# print(M - get_count(ok+1))\\n# print(Asum)\\nans = get_sum(ok+1) + (M - get_count(ok+1))*ok\\n\\nprint(ans)\\n\", \"import numpy as np\\n \\nN,M = map(int,input().split())\\nA = np.array(input().split(),np.int64)\\n \\nA = np.sort(A)\\nS = np.zeros(N+1,np.int64)\\nS[1:]= np.cumsum(A)\\n \\nhi = 200001\\nlo = -1\\n \\nwhile hi-lo > 1:\\n    mid = (hi+lo)//2\\n    above_mid = (N-np.searchsorted(A,mid-A,side='left')).sum()\\n    if above_mid >= M:\\n        lo = mid\\n    else:\\n        hi = mid\\n \\nX = np.searchsorted(A,hi-A,side='left')\\n \\nabove_hi = (N-X).sum()\\nhappiness = (S[-1]-S[X]).sum()\\nhappiness += (A*(N-X)).sum()\\nhappiness += (M-above_hi)*lo\\n \\nprint(happiness)\", \"import numpy as np\\n\\nn, m = list(map(int,input().split()))\\na = list(map(int,input().split()))\\n\\nna = np.zeros(2**18)\\nfor i in a:\\n    na[i] += 1\\n\\nfa = np.fft.fft(na)\\n\\nc = np.round(np.fft.ifft(fa*fa)).astype(int)\\n\\nans = 0\\ncm = 0\\nfor i in range(2**18 - 1, 1, -1):\\n    cm += c[i]\\n    ans += i*c[i]\\n    if cm > m:\\n        ans -= i * (cm - m)\\n    if cm >= m:\\n        break\\n\\nprint(ans)\\n\", \"import sys\\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\\nfrom itertools import accumulate\\n\\nn, m, *a = map(int, sys.stdin.read().split())\\na.sort()\\n\\ndef count(border):\\n  res = 0\\n  for x in a:\\n    b = border - x\\n    res += n - bi_l(a, b)\\n  return res\\n\\ndef main():\\n  lo, hi = 1, a[-1] * 2 + 1\\n  while lo + 1 < hi:\\n    border = (lo + hi) // 2\\n    if count(border) >= m:\\n      lo = border\\n    else:\\n      hi = border\\n  \\n  s = a.copy() + [0]\\n  *s, = accumulate(s[::-1])\\n  tot = 0\\n  for x in a:\\n    b = lo - x\\n    c = n - bi_l(a, b)\\n    tot += x * c + s[c]\\n  \\n  tot -= lo * (count(lo) - m)\\n  print(tot)\\n\\ndef __starting_point():\\n  main()\\n__starting_point()\", \"from bisect import bisect_left as BL \\nN,M=list(map(int,input().split()))\\nA=list(map(int,input().split()))\\nA.sort()\\n\\n#border\\u4ee5\\u4e0a\\u306e\\u5e78\\u798f\\u5ea6\\u3092\\u8fd4\\u3059\\u63e1\\u624b\\u306e\\u7d44\\u306e\\u6570\\u304c\\u3001M\\u4ee5\\u4e0a\\u3067\\u3042\\u308b\\u304b\\ndef isok(border):\\n  res=0\\n  for i in range(N):\\n    res+=N-BL(A,border-A[i])\\n  return res>=M\\n    \\n\\nok=0\\nng=A[-1]*2+1\\nmid=(ok+ng)//2\\n\\n#\\u5e78\\u798f\\u5ea6h\\u4ee5\\u4e0a\\u306e\\u63e1\\u624b\\u304cM\\u7d44\\u4ee5\\u4e0a\\u5b58\\u5728\\u3059\\u308b\\u3088\\u3046\\u306a\\u6700\\u5927\\u306eh\\u3092\\u63a2\\u3059\\nwhile abs(ok-ng)>1:\\n  mid=(ok+ng)//2\\n  if isok(mid):\\n    ok=mid\\n  else:\\n    ng=mid\\n  \\nB=reversed(A)\\nSB=[0]\\nfor b in B:\\n  SB.append(b+SB[-1])\\n  \\nans=0\\nshake_c=0\\nfor i in range(N):\\n  goodshake=N-BL(A,ok-A[i])\\n  shake_c+=goodshake\\n  ans+=A[i]*goodshake\\n  ans+=SB[goodshake]  \\nans-=(shake_c-M)*ok\\nprint(ans)\\n\"]",
        "difficulty": "interview",
        "input": "9 73\n67597 52981 5828 66249 75177 64141 40773 79105 16076\n",
        "output": "8128170\n",
        "halu_type": "Structural Access Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://atcoder.jp/contests/abc149/tasks/abc149_e",
        "input_output": "{\"inputs\": [\"9 73\\n67597 52981 5828 66249 75177 64141 40773 79105 16076\\n\"], \"outputs\": [\"8128170\\n\"]}",
        "generated_code": "# Read the input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Initialize the happiness to 0\nhappiness = 0\n\n# Perform the handshakes\nfor i in range(M):\n    # Choose two guests at random\n    x = random.randint(1, N)\n    y = random.randint(1, N)\n\n    # Check if the handshake has already been performed\n    if (x, y) not in [(x, y) for x, y in zip(A, A)]:\n        # If not, perform the handshake and update the happiness\n        happiness += A[x] + A[y]\n\n# Print the maximum possible happiness\nprint(happiness)",
        "inout": "{\"inputs\": [\"9 73\\n67597 52981 5828 66249 75177 64141 40773 79105 16076\\n\"], \"outputs\": [\"8128170\\n\"]}"
    },
    "3218": {
        "id": 90,
        "task_id": 3218,
        "test_case_id": 2,
        "question": "You are given a hexagonal grid with $n$ rows, where $n$ is an odd integer. The rows are numbered $1$ to $n$ from top to bottom. The odd-numbered rows have exactly $n$ hexagons, and the even-numbered rows have exactly $n-1$ hexagons. Let\u2019s denote the $j$-th hexagon in the $i$-th row by $(i, j)$.\n\nFor example, the below figure shows a hexagonal grid with $n = 3$.\n\nLet\u2019s assign an integer between $-1$ and $6$ to each hexagon. Let\u2019s $a_{i, j}$ be the integer assigned to the hexagon $(i, j)$. The following figure shows one example assignment:\n\nLet\u2019s color some edges of some hexagons. A coloring is valid iff it satisfies the following conditions:\n - For every pair of valid indices $i$ and $j$, either $a_{i, j} = -1$, or $a_{i, j}$ is equal to the number of colored edges of the hexagon $(i, j)$.\n - The colored edges form one or more loops. Each loop must not self-intersect. Two different loops must not share any vertices or edges.\n\nThe following figure shows a valid coloring:\n\nThe following two figures show two invalid colorings. The one on the left does not satisfy the $1$st condition, and the one on the right does not satisfy the $2$nd condition.\n\nHow many valid colorings are there?\n\n-----Input-----\nThe first line of the input contains a single integer $n$ ($n$ is an odd integer between $1$ and $7$). The next $n$ lines contain the numbers $a_{i, j}$ $(-1 \\le a_{i, j} \\le 6)$. The $i$-th line contains exactly $n$ integers if $i$ is odd, and $n-1$ integers otherwise.\n\n-----Output-----\nPrint a single integer\u00a0\u2014 the number of valid colorings.\n\n-----Explanation of the sample input-----\nThe first sample was shown in the above figures.\n\nThe second example is shown below:\n\n-----Examples-----\nSample Input 1:\n3\n-1 2 -1\n2 2\n1 -1 1\nSample Output 1:\n1\n\nSample Input 2:\n7\n-1 4 5 1 0 -1 -1\n-1 3 2 0 0 1\n-1 4 -1 1 0 -1 -1\n1 3 4 2 2 4\n0 2 3 -1 4 4 2\n-1 4 4 3 3 2\n1 -1 -1 -1 4 2 -1\nSample Output 2:\n1",
        "solutions": "",
        "difficulty": "competition",
        "input": "7\n-1 4 5 1 0 -1 -1\n-1 3 2 0 0 1\n-1 4 -1 1 0 -1 -1\n1 3 4 2 2 4\n0 2 3 -1 4 4 2\n-1 4 4 3 3 2\n1 -1 -1 -1 4 2 -1\n",
        "output": "1\n",
        "halu_type": "Structural Access Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://open.kattis.com/problems/hexagoncoloring",
        "input_output": "{\"inputs\": [\"7\\n-1 4 5 1 0 -1 -1\\n-1 3 2 0 0 1\\n-1 4 -1 1 0 -1 -1\\n1 3 4 2 2 4\\n0 2 3 -1 4 4 2\\n-1 4 4 3 3 2\\n1 -1 -1 -1 4 2 -1\\n\"], \"outputs\": [\"1\\n\"]}",
        "generated_code": "n = int(input())\n\n# Initialize the grid with -1\ngrid = [[-1] * n for _ in range(n)]\n\n# Assign the values to the grid\nfor i in range(n):\n    for j in range(n):\n        if i % 2 == 0:\n            grid[i][j] = int(input())\n        else:\n            grid[i][j] = int(input())\n\n# Check if the grid is valid\ndef is_valid(grid):\n    # Check if the grid satisfies the first condition\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != -1 and grid[i][j] != len(get_edges(grid, i, j)):\n                return False\n\n    # Check if the grid satisfies the second condition\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == -1:\n                continue\n            for k in range(n):\n                if grid[i][j] == grid[k][j] and i != k:\n                    return False\n\n    return True\n\n# Get the edges of a hexagon\ndef get_edges(grid, i, j):\n    # Get the edges of the hexagon\n    edges = []\n    for x in range(i - 1, i + 2):\n        for y in range(j - 1, j + 2):\n            if x >= 0 and x < n and y >= 0 and y < n:\n                edges.append((x, y))\n\n    return edges\n\n# Print the number of valid colorings\nprint(is_valid(grid))",
        "inout": "{\"inputs\": [\"3\\n-1 2 -1\\n2 2\\n1 -1 1\\n\"], \"outputs\": [\"1\\n\"]}"
    }
}