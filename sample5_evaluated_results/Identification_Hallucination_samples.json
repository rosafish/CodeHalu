{
    "473": {
        "id": 47,
        "task_id": 473,
        "test_case_id": 47,
        "question": "George woke up and saw the current time s on the digital clock. Besides, George knows that he has slept for time t. \n\nHelp George! Write a program that will, given time s and t, determine the time p when George went to bed. Note that George could have gone to bed yesterday relatively to the current time (see the second test sample). \n\n\n-----Input-----\n\nThe first line contains current time s as a string in the format \"hh:mm\". The second line contains time t in the format \"hh:mm\" \u2014 the duration of George's sleep. It is guaranteed that the input contains the correct time in the 24-hour format, that is, 00 \u2264 hh \u2264 23, 00 \u2264 mm \u2264 59.\n\n\n-----Output-----\n\nIn the single line print time p \u2014 the time George went to bed in the format similar to the format of the time in the input.\n\n\n-----Examples-----\nInput\n05:50\n05:44\n\nOutput\n00:06\n\nInput\n00:00\n01:00\n\nOutput\n23:00\n\nInput\n00:01\n00:00\n\nOutput\n00:01\n\n\n\n-----Note-----\n\nIn the first sample George went to bed at \"00:06\". Note that you should print the time only in the format \"00:06\". That's why answers \"0:06\", \"00:6\" and others will be considered incorrect. \n\nIn the second sample, George went to bed yesterday.\n\nIn the third sample, George didn't do to bed at all.",
        "solutions": "[\"s = input()\\nt = input()\\na, b = int(s[:2]), int(s[3:])\\nc, d = int(t[:2]), int(t[3:])\\na -= c\\nb -= d\\nif b < 0:\\n    a -= 1\\n    b = 60 + b\\nif a < 0:\\n    a = 24 + a\\nif a < 10:\\n    print(0, end = '')\\nprint(a, ':', end = '', sep = '')\\nif b < 10:\\n    print(0, end = '')\\nprint(b)\\n\", \"a, b = list(map(int, input().split(':')))\\nc, d = list(map(int, input().split(':')))\\nt = a * 60 + b - c * 60 - d\\n\\nif t < 0:\\n    t += 60 * 24\\na, b = t // 60, t % 60\\n\\nprint(str(a // 10) + str(a % 10) + ':' + str(b // 10) + str(b % 10))\\n\", \"h2, m2 = list(map(int, input().split(':')))\\nh_sleep, m_sleep = list(map(int, input().split(':')))\\n\\nt2 = m2 + h2 * 60\\nt_sleep = m_sleep + h_sleep * 60\\n\\nt2 -= t_sleep\\nif t2 < 0:\\n    t2 += 60 * 24\\n\\nprint('0' * (2 - len(str(t2 // 60))) + str(t2 // 60) + ':' + '0' * (2 - len(str(t2 % 60))) + str(t2 % 60))\\n\", \"def ui(a):\\n    a = str(a)\\n    return '0'*(2-len(a))+a\\na,b = map(int,input().split(':'))\\nc,d = map(int,input().split(':'))\\nt1 = 60*a+b\\nt2 = 60*c+d\\nif t1>=t2:\\n    dt = t1-t2\\nelse:\\n    dt = 1440-t2+t1\\nprint(ui(dt//60),':',ui(dt%60),sep='')\", \"s=input()\\n\\nwh=int(s[0]+s[1])\\nwm=int(s[3]+s[4])\\n\\ns=input()\\n\\nth=int(s[0]+s[1])\\ntm=int(s[3]+s[4])\\n\\ntm+=th*60\\n\\nwm+=wh*60\\n\\nwm-=tm\\nif(wm<0):\\n    wm=1440+wm\\nansh=str(wm//60)\\nansm=str(wm%60)\\nif(len(ansh)<2):\\n    ansh='0'+ansh\\nif(len(ansm)<2):\\n    ansm='0'+ansm\\nprint(ansh+\\\":\\\"+ansm)\\n\", \"def conv(s):\\n\\th = str(s // 60)\\n\\tm = str(s % 60)\\n\\tif len(h) < 2:\\n\\t\\th = '0' + h\\n\\tif len(m) < 2:\\n\\t\\tm = '0' + m\\n\\treturn h + ':' + m\\n\\ns = list(map(int, input().split(':')))\\nt = list(map(int, input().split(':')))\\ns = s[0] * 60 + s[1]\\nt = t[0] * 60 + t[1]\\np = s - t\\nif p < 0:\\n\\tp += 24 * 60\\nprint(conv(p))\\n\", \"h1, m1 = list(map(int, input().split(':')))\\nh2, m2 = list(map(int, input().split(':')))\\nif (m2 > m1):\\n\\tm1 += 60\\n\\th1 -= 1\\nh1 -= h2\\nm1 -= m2\\nif (h1 < 0):\\n\\th1 += 24\\nh = ''\\nm = ''\\nif (h1 < 10):\\n\\th = '0'\\nh += str(h1)\\nif (m1 < 10):\\n\\tm = '0'\\nm += str(m1)\\nprint(h, m, sep = ':', end = '\\\\n')\\n\", \"s = input()\\np = input()\\nt1 = int(s[len(s) - 2:len(s)]) - int(p[len(p) - 2:len(p)])\\nk = 0\\nif t1 < 0:\\n    t1 += 60\\n    k = 1\\nt0 = int(s[:2]) - int(p[:2]) - k\\nwhile t0 < 0:\\n    t0 += 24\\nt0 %= 24\\nres = str(t0) + ':'\\nif len(res) < 3:\\n    res = '0' + res\\nss = '0' + str(t1)\\nss = ss[-2:]\\nres += ss\\nprint(res)\", \"s=input().strip()\\np=input().strip()\\nans=int(s[:2])*60+int(s[3:])-int(p[:2])*60-int(p[3:])\\nans=ans%1440\\nt=('0' if ans//60<10 else '') + str(ans//60) + ':' + ('0' if ans%60<10 else '')+str(ans%60)\\nprint(t)\", \"s = input()\\nt1 = (10 * int(s[0]) + int(s[1])) * 60 + (10 * int(s[3]) + int(s[4]))\\ns = input()\\nt2 = (10 * int(s[0]) + int(s[1])) * 60 + (10 * int(s[3]) + int(s[4]))\\nt1 = (t1 - t2 + 24 * 60) % (24 * 60)\\nx1 = t1 // 60\\nx2 = t1 % 60\\nprint(x1 // 10, end = '')\\nprint(x1 % 10, end = '')\\nprint(':', end = '')\\nprint(x2 // 10, end = '')\\nprint(x2 % 10)\\n\", \"s = input().split(\\\":\\\")\\nt = input().split(\\\":\\\")\\n\\nh = int(s[0]) - int(t[0])\\n\\nm = int(s[1]) - int(t[1])\\nwhile m < 0:\\n    m += 60\\n    h -= 1\\nwhile h < 0:\\n    h += 24\\n\\n\\nmstr = ''\\nif m < 10:\\n    mstr = '0' + str(m)\\nelse:\\n    mstr = str(m)\\n\\nhstr = ''\\nif h < 10:\\n    hstr = '0' + str(h)\\nelse:\\n    hstr = str(h)\\n\\nprint(hstr + ':' + mstr)\\n\\n\", \"s1=input().strip()\\ns2=input().strip()\\nh1=int(s1[:2])\\nh2=int(s2[:2])\\nm1=int(s1[3:])\\nm2=int(s2[3:])\\nh3=h1-h2\\nm3=m1-m2\\nif m3<0:\\n    m3=60+m3\\n    h3-=1\\nif h3<0:\\n    h3=24+h3\\nprint((2-len(str(h3)))*'0'+str(h3)+':'+(2-len(str(m3)))*'0'+str(m3))\\n\", \"s = list(map(int,input().split(':')))\\ns = (24+s[0])*60+s[1]\\nt = list(map(int,input().split(':')))\\nt = t[0]*60+t[1]\\np = (s - t) % (24 * 60)\\np = '{:02}:{:02}'.format(p//60, p % 60)\\nprint(p)\\n\", \"h,m = [int(x) for x in input().split(\\\":\\\")]\\nhdiff, mdiff = [int(x) for x in input().split(\\\":\\\")]\\n\\nm1=m-mdiff\\nh1=h-hdiff\\nif m1<0:\\n  m1=60+m1\\n  h1=h1-1\\nif h1<0:\\n  h1=24+h1\\nh1=str(h1)\\nm1=str(m1)\\nprint(h1.zfill(2)+\\\":\\\"+m1.zfill(2))\", \"from sys import stdin\\nfrom datetime import datetime, timedelta\\n\\ndef main():\\n\\ts = stdin.readline().strip()\\n\\tt = stdin.readline().strip()\\n\\n\\ts = datetime.strptime(s, '%H:%M')\\n\\tt = datetime.strptime(t, '%H:%M')\\n\\n\\tt = timedelta(hours = t.hour, minutes = t.minute)\\n\\n\\tp = s - t\\n\\n\\tprint('{:02}:{:02}'.format(p.hour, p.minute))\\n\\ndef __starting_point(): main()\\n__starting_point()\", \"a = input()\\nq1, q2, q3, q4 = int(a[0]), int(a[1]), int(a[3]), int(a[4])\\nb = input()\\nw1, w2, w3, w4 = int(b[0]), int(b[1]), int(b[3]), int(b[4])\\nww = (q3*10 + q4) + (q1*10 + q2)*60\\nqq = (w3*10 + w4) + (w1*10 + w2)*60\\ns = \\\"\\\"\\nif ww == qq:\\n    print(\\\"00:00\\\")\\nelif (ww - qq) > 0:\\n    if(ww - qq) // 60 > 9:\\n        d = str((ww - qq)//60)\\n        s += d\\n    else:\\n        s += \\\"0\\\"\\n        d = str((ww - qq)//60)\\n        s += d\\n    s += \\\":\\\"\\n    if (ww - qq) % 60 > 9:\\n        d = str((ww - qq)%60)\\n        s += d\\n    else:\\n        s += \\\"0\\\"\\n        d = str((ww - qq)%60)\\n        s += d \\n    print(s)\\nelse:\\n    if(ww - qq + 1440) // 60 > 9:\\n            d = str((ww - qq+ 1440)//60)\\n            s += d\\n    else:\\n        s += \\\"0\\\"\\n        d = str((ww - qq+ 1440)//60)\\n        s += d\\n    s += \\\":\\\"\\n    if (ww - qq + 1440) % 60 > 9:\\n        d = str((ww - qq + 1440)%60)\\n        s += d\\n    else:\\n        s += \\\"0\\\"\\n        d = str((ww - qq + 1440)%60)\\n        s += d   \\n    print(s)\\n\\n\", \"from datetime import *\\na = input().split(\\\":\\\")\\nb = input().split(\\\":\\\")\\nx = datetime(1,1,3,int(a[0]),int(a[1]))\\ny = timedelta(hours=int(b[0]),minutes=int(b[1]))\\nz = str(x - y).split(' ')[1].split(\\\":\\\")\\nprint(\\\"%s:%s\\\"%(z[0],z[1]))\\n\", \"current = input()\\nsleep = input()\\n\\nhour_current = current[:current.index(':')]\\nmin_current = current[current.index(':')+1:]\\n\\nhour_sleep = sleep[:sleep.index(':')]\\nmin_sleep = sleep[sleep.index(':')+1:]\\n\\ncurrent_in_min = int(hour_current)*60 + int(min_current)\\nsleep_in_min = int(hour_sleep)*60 + int(min_sleep)\\n\\nbed_time = current_in_min - sleep_in_min\\nif bed_time < 0 :\\n    bed_time = 24*60 + bed_time\\n    out_hour = bed_time // 60\\n    out_min = bed_time % 60\\nelse:\\n    out_hour = bed_time // 60\\n    out_min = bed_time % 60\\nif out_hour < 10 :\\n    out_hour = \\\"0\\\"+str(out_hour)\\nif out_min < 10 :\\n    out_min = \\\"0\\\" + str(out_min)\\nprint(str(out_hour) + \\\":\\\" + str(out_min))\\n\", \"s1=input()\\ns2=input()\\nh1,m1=s1.split(':')\\nh2,m2=s2.split(':')\\nm=int(m1)-int(m2)\\nh=int(h1)-int(h2)-1*(m<0)\\nprint(str(h%24).zfill(2),str(m%60).zfill(2),sep=':')\\n\\n\\n\", \"import sys\\nimport math\\nimport heapq\\nimport random\\nimport collections\\nimport datetime\\n\\ndef main():\\n    # sys.stdin = open('input.txt', 'r')\\n    # sys.stdout = open('output.txt', 'w')\\n\\n    t1 = list(map(int, input().strip().split(':')))\\n    t2 = list(map(int, input().strip().split(':')))\\n\\n    t1_ = datetime.timedelta(hours=t1[0], minutes=t1[1])\\n    t2_ = datetime.timedelta(hours=t2[0], minutes=t2[1])\\n\\n    t3_ = t1_- t2_\\n    s = str(t3_)\\n\\n    if len(s[-8:-3]) == 4:\\n        print('0'+s[-8:-3])\\n\\n    elif len(s[-8:-3]) == 5 and s[-8] == ' ':\\n        print('0'+s[-7:-3])\\n\\n    else:\\n        print(s[-8:-3])\\n\\n    # sys.stdin.close()\\n    # sys.stdout.close()\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"[e1,e2] = map(int,input().split(':'))\\n[s1,s2] = map(int,input().split(':'))\\n\\ntotal1 = e1*60 + e2;\\ntotal2 = s1*60 + s2;\\nans = 0\\nif total1 >= total2 :\\n    ans = total1 - total2\\nelse:\\n    ans = 1440 - total2 + total1\\nout = ''\\nif int(ans/60) < 10:\\n    out = out + '0' + str(int(ans/60))\\nelse:\\n    out = str(int(ans/60))\\nout = out + ':'\\nif int(ans%60) < 10:\\n    out = out + '0' + str(ans%60)\\nelse:\\n    out = out + str(ans%60)\\nprint(out)\", \"[e1,e2] = map(int,input().split(':'))\\n[s1,s2] = map(int,input().split(':'))\\n\\ntotal1 = e1*60 + e2;\\ntotal2 = s1*60 + s2;\\nans = 0\\nif total1 >= total2 :\\n    ans = total1 - total2\\nelse:\\n    ans = 1440 - total2 + total1\\nprint('{:02}:{:02}'.format(int(ans/60),int(ans%60)))\", \"def ss(a):\\n    if a > 9:\\n        return str(a)\\n    else:\\n        return '0'+str(a)\\na = [int(x) for x in input().split(':')]\\nb = [int(x) for x in input().split(':')]\\nh = a[0] - b[0]\\nm = a[1] - b[1]\\nhh = 0\\nwhile m < 0:\\n    m = 60 - abs(m)\\n    hh += 1\\nh -= hh\\nwhile h < 0:\\n    h = 24 - abs(h)\\nprint(ss(h),':',ss(m),sep = '')\", \"s = list(map(int, input().split(':')))\\nt = list(map(int, input().split(':')))\\n\\np = [0, 0]\\nif s[0] - t[0] < 0:\\n    p[0] = 24 - (t[0] - s[0])\\nelse:\\n    p[0] = s[0] - t[0]\\n\\nif s[1] - t[1] < 0:\\n    p[1] = 60 - (t[1] - s[1])\\n    if p[0] == 0:\\n        p[0] = 23\\n    else:\\n        p[0] -= 1\\nelse:\\n    p[1] = s[1] - t[1]\\n\\nif p[0] < 10:\\n    print('0', p[0], sep = '', end = ':')\\nelse:\\n    print(p[0], end = ':')\\nif p[1] < 10:\\n    print('0', p[1], sep = '')\\nelse:\\n    print(p[1])\\n\"]",
        "difficulty": "interview",
        "input": "10:00\n01:00\n",
        "output": "09:00\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/387/A",
        "input_output": "{\"inputs\": [\"10:00\\n01:00\\n\"], \"outputs\": [\"09:00\\n\"]}",
        "generated_code": "s = input()\nt = input()\n\n# Convert the input strings to integers\ns_h, s_m = map(int, s.split(':'))\nt_h, t_m = map(int, t.split(':'))\n\n# Calculate the time George went to bed\np_h = s_h - t_h\np_m = s_m - t_m\n\n# Check if George went to bed yesterday\nif p_h < 0:\n    p_h += 24\n\n# Print the time George went to bed\nprint(f\"{p_h:02d}:{p_m:02d}\")",
        "inout": "{\"inputs\": [\"00:00\\n01:00\\n\"], \"outputs\": [\"23:00\\n\"]}"
    },
    "3170": {
        "id": 50,
        "task_id": 3170,
        "test_case_id": 3,
        "question": "From her friends, Theta learned a $2$-player card game called Trash. Trash is played with a standard $52$-card deck consisting of Ace, $2$ to $10$, Jack, Queen, and King in each of the $4$ suits. Each player is dealt $10$ cards face down that are arranged in $2$ rows for each player as shown in the figure. The first row represents slots for an ace, a $2$, a $3$, a $4$, and a $5$ of any suit, the second row represents slots for $6$, $7$, $8$, $9$, $10$ of any suit. The first player who can fill all $10$ of their slots with a card of the appropriate kind wins.\n\nPlayers take turns to play Trash. At the beginning of each turn, a player draws from the drawing pile, which initially contains all cards that have not been dealt face-down. If the player can use the card drawn to fill one of their slots that has not been filled, they uncover and remove the face-down card from the slot and put the drawn card face up in the slot. Then, the player repeats their turn with the card uncovered (instead of drawing a new card from the drawing pile) until they either fill all slots or uncover a card that cannot fill a slot.\n\nIf a player draws or uncovers a card that cannot fill any slot (such as a Queen or King), or if a player draws or uncovers a card that corresponds to a slot they\u2019ve already filled, that card is put on the discard pile and the player loses their turn. Then, the other player takes their turn or turns by first drawing from the drawing pile, then placing cards as long as they fill slots. Note that in this version of Trash, a player may never take any cards from the discard pile. Whichever player first fills all of their slots wins.\n\nA special case is the Jack, which acts as a wildcard. Whenever a player draws (or uncovers) a Jack, they can use the Jack to fill any of their remaining slots.\n\nTheta quickly discovers that it matters how you use any Jacks you draw, namely so that you minimize the chance of being left with an unfilled slot. If there are multiple optimal choices for slots in which to place a Jack, she chooses the lowest-numbered slot (Ace counts as $1$). Most of her friends, however, use a simpler strategy of always using their Jacks to fill the lowest-numbered unfilled slot, regardless of which cards were already placed or discarded.\n\nWrite a program that determines who wins in a game between Theta and one of her friends! Note that Theta bases her decision on only those cards that are turned face-up in a slot and the cards that have been discarded onto the discard pile, but not the face-down cards or the cards remaining in the drawing pile.\n\n-----Input-----\nInput consists of a single string denoting the shuffled deck, which consists of $52$ characters, with each of A, J, Q, K, 2, 3, 4, 5, 6, 7, 8, 9, and T appearing exactly $4$ times. Since the suit of a card does not matter for the game, it is not given in the input. 2 - 9 stand for cards $2$ to $9$, T stands for $10$, and A, J, Q, and K stand for Ace, Jack, Queen, and King.\n\nThe first $10$ cards in the deck are dealt face-down to Theta, with the first card in her Ace/$1$ slot, the second card in her $2$ slot, and so on. The next $10$ cards are dealt to her friend, with the $11^{\\texttt{th}}$ in the Ace/$1$ slot, and so on. The $21^{\\texttt{st}}$ card in the deck is the first card drawn. Neither player is allowed to look at their face-down cards. Theta starts the game.\n\nYou are guaranteed that one player will be able to win before the deck runs out of cards.\n\n-----Output-----\nIf Theta wins this game with her strategy, output \u201cTheta wins\u201d. Otherwise, output \u201cTheta loses\u201d. Do not add a period to the output.\n\n-----Examples-----\nSample Input 1:\n23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5\nSample Output 1:\nTheta wins\n\nSample Input 2:\n89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49\nSample Output 2:\nTheta wins",
        "solutions": "",
        "difficulty": "competition",
        "input": "6Q4K476722745A9A9875A2TT3JA6K5K34JKQQTQ235T9868J893J\n",
        "output": "Theta loses\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://open.kattis.com/problems/trash",
        "input_output": "{\"inputs\": [\"6Q4K476722745A9A9875A2TT3JA6K5K34JKQQTQ235T9868J893J\\n\"], \"outputs\": [\"Theta loses\\n\"]}",
        "generated_code": "def trash(deck):\n    # Initialize Theta's slots and the drawing pile\n    slots = [None] * 10\n    drawing_pile = deck\n\n    # Deal the cards to Theta and her friend\n    for i in range(10):\n        slots[i] = deck[i]\n        slots[i + 10] = deck[i + 10]\n\n    # Determine who wins\n    while True:\n        # Theta's turn\n        for i in range(10):\n            if slots[i] is None:\n                # Draw a card from the drawing pile\n                card = drawing_pile.pop()\n                slots[i] = card\n                break\n        else:\n            # Theta has no more cards to draw, so she loses\n            return \"Theta loses\"\n\n        # Theta's friend's turn\n        for i in range(10):\n            if slots[i + 10] is None:\n                # Draw a card from the drawing pile\n                card = drawing_pile.pop()\n                slots[i + 10] = card\n                break\n        else:\n            # Theta's friend has no more cards to draw, so she loses\n            return \"Theta loses\"\n\n        # Check if Theta has filled all of her slots\n        if all(slots[i] is not None for i in range(10)):\n            # Theta has won\n            return \"Theta wins\"\n\n# Read the input deck from standard input\ndeck = input()\n\n# Play the game\nresult = trash(deck)\n\n# Print the result\nprint(result)",
        "inout": "{\"inputs\": [\"89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49\\n\"], \"outputs\": [\"Theta wins\\n\"]}"
    },
    "3339": {
        "id": 52,
        "task_id": 3339,
        "test_case_id": 2,
        "question": "Evenland used to be a normal country. Then Steven became ruler and now everything must be done as he wishes. For some odd reason he is obsessed with the number two. Everything must be even in his country, hence he even changed the name to Evenland. \n\nThe other day, Steven was driving through his country when he noticed that, at some intersections, an odd number of roads meet. Naturally, some roads must now be destroyed in order to make the number of roads even at every intersection.\n\nYou are in charge of this project. You start wondering: in how many ways can this project be carried out? In other words, in how many ways can you select a set of roads to destroy so that all intersections become even? The resulting road network does not have to be connected, so for instance, one possible way is to destroy all roads.\n\n-----Input-----\nThe first line of the input contains two integers $N$ and $M$, where $1\\leq N, M\\leq 100000$. $N$ denotes the number of intersections in Evenland and $M$ is the number of roads. $M$ lines follow, each contains two space separated integers $a$, $b$ indicating that there is a road between intersections $a$ and $b$. You may assume that $1\\leq a, b\\leq N$ and $a\\not= b$. There might be more than one road connecting a pair of intersections.\n\n-----Output-----\nOutput one line with one integer \u2013 the number of ways of making all intersections even. Since this number might be big, output the remainder modulo $1000000009$.\n\n-----Examples-----\nSample Input:\n4 5\n1 2\n1 3\n1 4\n2 3\n2 4\nSample Output:\n4",
        "solutions": "",
        "difficulty": "competition",
        "input": "2 1\n1 2\n",
        "output": "1\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://open.kattis.com/problems/evenland",
        "input_output": "{\"inputs\": [\"2 1\\n1 2\\n\"], \"outputs\": [\"1\\n\"]}",
        "generated_code": "import itertools\n\ndef get_even_intersections(intersections, roads):\n    # Initialize a dictionary to store the number of roads connecting each intersection\n    intersection_counts = {i: 0 for i in range(1, intersections + 1)}\n    for road in roads:\n        intersection_counts[road[0]] += 1\n        intersection_counts[road[1]] += 1\n    \n    # Find the intersections with odd number of roads\n    odd_intersections = [i for i in intersection_counts if intersection_counts[i] % 2 == 1]\n    \n    # Calculate the number of ways to destroy roads to make all intersections even\n    num_ways = 0\n    for combination in itertools.combinations(odd_intersections, len(odd_intersections) // 2):\n        num_ways += 1\n    \n    return num_ways % 1000000009\n\n# Test case 1:\nintersections = 4\nroads = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4)]\nprint(get_even_intersections(intersections, roads))\n\n# Test case 2:\nintersections = 5\nroads = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\nprint(get_even_intersections(intersections, roads))",
        "inout": "{\"inputs\": [\"2 1\\n1 2\\n\"], \"outputs\": [\"1\\n\"]}"
    },
    "66": {
        "id": 153,
        "task_id": 66,
        "test_case_id": 105,
        "question": "Vector Willman and Array Bolt are the two most famous athletes of Byteforces. They are going to compete in a race with a distance of L meters today.\n\n [Image] \n\nWillman and Bolt have exactly the same speed, so when they compete the result is always a tie. That is a problem for the organizers because they want a winner. \n\nWhile watching previous races the organizers have noticed that Willman can perform only steps of length equal to w meters, and Bolt can perform only steps of length equal to b meters. Organizers decided to slightly change the rules of the race. Now, at the end of the racetrack there will be an abyss, and the winner will be declared the athlete, who manages to run farther from the starting point of the the racetrack (which is not the subject to change by any of the athletes). \n\nNote that none of the athletes can run infinitely far, as they both will at some moment of time face the point, such that only one step further will cause them to fall in the abyss. In other words, the athlete will not fall into the abyss if the total length of all his steps will be less or equal to the chosen distance L.\n\nSince the organizers are very fair, the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to t (both are included). What is the probability that Willman and Bolt tie again today?\n\n\n-----Input-----\n\nThe first line of the input contains three integers t, w and b (1 \u2264 t, w, b \u2264 5\u00b710^18) \u2014 the maximum possible length of the racetrack, the length of Willman's steps and the length of Bolt's steps respectively.\n\n\n-----Output-----\n\nPrint the answer to the problem as an irreducible fraction [Image]. Follow the format of the samples output.\n\nThe fraction [Image] (p and q are integers, and both p \u2265 0 and q > 0 holds) is called irreducible, if there is no such integer d > 1, that both p and q are divisible by d.\n\n\n-----Examples-----\nInput\n10 3 2\n\nOutput\n3/10\n\nInput\n7 1 2\n\nOutput\n3/7\n\n\n\n-----Note-----\n\nIn the first sample Willman and Bolt will tie in case 1, 6 or 7 are chosen as the length of the racetrack.",
        "solutions": "[\"from fractions import gcd\\n\\nt,w,b = map(int,input().split())\\nper = w*b//gcd(w,b)\\ncan = (t//per+1)*min(w,b)-1\\nif t%per<min(w,b):\\n    can-=min(w,b)\\n    can+=t%per+1\\ng = gcd(can,t)\\ncan//=g\\nt//=g\\nprint(str(can)+\\\"/\\\"+str(t))\", \"\\nfrom fractions import gcd\\na, b, c = list(map(int, input().split(' ')))\\nl = b * c // gcd(b, c)\\nb, c = min(b, c), max(b, c)\\n\\n## 0...b-1 ##\\nmults = a // l\\nrem = a - l * mults + 1\\n\\nnum = mults * (b)\\nrem = min(b, rem)\\nx = num + rem - 1\\n\\ng = gcd(x, a)\\nprint(str(x//g) + '/' + str(a//g))\\n\", \"def gcd(a,b):\\n    if b == 0:\\n        return a\\n    return gcd(b,a%b)\\ndef lcm(a,b):\\n    return (a*b)//gcd(a,b)\\nt,w,b = map(int,input().split())\\nlc = lcm(w,b)\\nmn = 0\\nif w > b:\\n    mn = b\\nelse:\\n    mn = w\\nans = mn*(t//lc+1)-1\\nval = (t//lc)*lc + mn - 1\\nif t - val < 0:\\n    ans += t-val\\ng = gcd(ans,t)\\nans //= g\\nt //= g\\nprint(ans,end=\\\"\\\")\\nprint(\\\"/\\\",end=\\\"\\\")\\nprint(t)\", \"from fractions import gcd\\n\\nt, w, b = map(int, input().split())\\nmn = min(w, b)\\nnk = w // gcd(w, b) * b\\nfirst = (t  + 1) // nk * mn - 1\\ne = first + min(mn, (t + 1) % nk)\\nnd = gcd(e, t)\\nprint(e // nd, \\\"/\\\", t // nd, sep = \\\"\\\")\\n\", \"from fractions import gcd\\n\\nt, w, b = map(int, input().split())\\nnok = w * b // gcd(w, b)\\nans = (t // nok) * min(w, b) + min(w - 1, b - 1, t % nok)\\nans, t = ans // gcd(ans, t), t // gcd(ans, t)\\nprint (ans, t, sep = \\\"/\\\")\\n\", \"def gcd(a, b):\\n    while (b > 0):\\n        a, b = b, a % b\\n    return a\\n\\ninp = [int(i) for i in input().split(' ')]\\nt = inp[0]\\nw = inp[1]\\nb = inp[2]\\nnok = w * b // gcd(w, b)\\nans = t // nok * min(w, b) - 1\\ntmp = t % nok\\nans += min(tmp + 1, min(w, b))\\ng = gcd(ans, t)\\nprint(ans // g, t // g, sep='/')\\n\", \"import math\\nimport sys\\n\\ndef Cmmdc(a, b):\\n\\tr = 0\\n\\twhile b > 0:\\n\\t\\tr = a % b\\n\\t\\ta = b\\n\\t\\tb = r\\n\\treturn a\\n\\nlst = list(map(int, input().split()))\\n\\nt = auxT = lst[0]\\nn = lst[1]\\nm = lst[2]\\n\\nif n > m:\\n\\taux = n\\n\\tn = m\\n\\tm = aux\\n\\ncmmdc = Cmmdc(n, m)\\ncmmmc = n * m // cmmdc\\n\\nfav = (t // cmmmc) * n\\nt = t % cmmmc\\nfav += min(n - 1, t)\\n\\nt = auxT\\nc = Cmmdc(fav, t)\\nfav //= c\\nt //= c\\n\\nprint(str(fav) + \\\"/\\\" + str(t) + \\\"\\\\n\\\")\\n\", \"import sys\\nfrom math import *\\nsys.setrecursionlimit(100000000)\\n\\ndef pgcd(a,b):\\n    while b!=0:\\n        a,b=b,a%b\\n    return a\\n\\ndef ppcm(a,b):\\n    if (a==0) or (b==0):\\n        return 0\\n    else:\\n        return (a*b)//pgcd(a,b)\\n\\nt,w,b=map(int,input().split())\\na=ppcm(w,b)\\nx=min(w,b)\\ny=t//a\\nv=x*y+min(x,t%a+1)-1\\n\\nw=pgcd(v,t)\\nif v==0:print(\\\"0/1\\\")\\nelse:\\n\\tprint(v//w,end=\\\"\\\")\\n\\tprint(\\\"/\\\",end=\\\"\\\")\\n\\tprint(t//w)\", \"t, w, b = list(map(int, input().split()))\\n\\n\\ndef NOK(a, b):\\n    m = a*b\\n    while a != 0 and b != 0:\\n        if a > b:\\n            a %= b\\n        else:\\n            b %= a\\n    return m // (a+b)\\n\\ndef NOD(a, b):\\n    while a != 0 and b != 0:\\n        if a > b:\\n            a %= b\\n        else:\\n            b %= a\\n    return (a+b)\\n\\n\\nif w == 1 or b == 1:\\n    res = t // max (w, b)\\nelse:\\n    k = NOK(w, b)\\n    ost = max(0, min(w, b) - 1 - t % k)\\n    res = (t // k + 1) * min(w,b) - 1 - ost\\n\\nm = NOD(t, res)\\n\\nprint(str(res // m) + '/' + str(t // m))\\n\", \"def gcd(a,b):\\n    if b == 0: return a\\n    return gcd(b, a%b)\\n\\ndef lcm(a,b):\\n    return a//gcd(a,b)*b\\n\\nt,w,b = map(int,input().split())\\np = min(w,b)\\nlc = lcm(w,b)\\nkol = t//lc\\nret = kol*p\\nzv = t%lc\\nret += min(zv, p-1)\\ng = gcd(ret, t)\\nret//=g\\nt//=g\\nprint(ret,'/',t,sep=\\\"\\\")\\n\", \"l, n, m = map(int, input().split())\\nfrom fractions import gcd\\nlcm = lambda x, y: x // gcd(x,y) * y\\nu = lcm(n,m)\\nv = min(n,m)\\na = (l//u) * v + min(v, l%u+1) - 1    \\nprint(a//gcd(a,l),'/',l//gcd(a,l),sep='')\\n\\n\", \"#!/usr/bin/env python3\\nimport math\\nt, a, b = list(map(int,input().split()))\\nl= a * b // math.gcd(a,b)\\np = (t // l) * min(a,b) + min(t % l, min(a,b) - 1)\\nq = t\\nr = math.gcd(p, q)\\nprint('{}/{}'.format(p//r, q//r))\\n\", \"#!/usr/bin/env python3\\n\\ndef gcd(a, b):\\n    return a if b == 0 else gcd(b, a % b)\\n\\ndef main():\\n    L, a, b = list(map(int, input().split()))\\n    c = a // gcd(a, b) * b\\n    m = min(a, b)\\n    if c <= m:\\n        print('1/1')\\n    else:\\n        p = L // c * m\\n        p += min(L % c, m - 1)\\n        g = gcd(p, L)\\n        print('%d/%d' % (p // g, L // g))\\n\\nmain()\", \"def gcd (a, b) :\\n\\twhile (b) :\\n\\t\\ta %= b\\n\\t\\ta, b = b, a\\n\\treturn a;\\n\\n\\nt, w, b = map(int, input().split())\\ng = w * b // gcd(w, b)\\nres = 0\\nminh = min(w, b)\\nres += (t // g + 1) * minh - 1\\ncorrect = (t // g) * g + minh - 1\\nif (correct > t) :\\n\\tres -= correct - t\\ny = gcd(res, t)\\nprint(res // y, \\\"/\\\", t // y, sep = \\\"\\\")\", \"from fractions import gcd\\n\\nt, a, b = map(int, input().split())\\n\\nif a > b:\\n    a, b = b, a\\n\\nlcm = a * b // gcd(a, b)\\ncnt = t // lcm\\nlst = lcm * cnt\\n\\nans = cnt * a + a - 1 \\n\\nif lst + a > t + 1:\\n    ans -= lst + a - t - 1\\n\\nnum = ans\\nden = t\\n\\ng = gcd(num, den)\\nnum //= g\\nden //= g\\n\\nprint(num, den, sep='/')\\n\\n\", \"from fractions import gcd\\n\\ndef lcm(a, b):\\n    return (a * b) // gcd(a, b)\\n\\n\\ndef __starting_point():\\n    t, w, b = list(map(int, input().split()))\\n\\n    l = lcm(w, b)\\n    m = min(w, b)\\n\\n    count = t // l\\n    result = count * m\\n    result += (m - 1) # 1 to m-1\\n\\n    diff = max(count*l + m - t - 1, 0)\\n    result -= diff\\n\\n    g = gcd(result, t)\\n\\n    print('{}/{}'.format(result//g, t//g))\\n\\n\\n\\n__starting_point()\", \"t, w, b = map(int, input().split())\\n\\ndef gcd(a, b):\\n    if b == 0: return a\\n    return gcd(b, a % b)\\n\\ndef lcm(a, b):\\n    return a // gcd(a, b) * b\\n\\nadd = min(w, b) - 1\\nl = lcm(w, b)\\n\\ncnt = t // l\\n\\nans = add + cnt + cnt * add\\nans -= max(0, l * cnt + add - t)\\n\\ng = gcd(ans, t)\\nif g != 0:\\n    ans //= g\\n    t //= g\\n\\nprint(ans, end='')\\nprint('/', end='')\\nprint(t)\\n\", \"3\\n\\ndef gcd(a, b):\\n\\tif b == 0:\\n\\t\\treturn a\\n\\treturn gcd(b, a%b)\\n\\nx = input()\\nx = [int(_) for _ in x.split()]\\n# print(x)\\n\\nt = x[0]\\nw = x[1]\\nb = x[2]\\n\\nx = gcd(w, b)\\nk = min(w,b)\\n\\nlcm = (w*b)//x\\n\\nalpha = t//lcm\\n\\nans = alpha*(k)\\n\\nl = alpha*lcm + k- 1\\n\\nif l <= t :\\n\\tans += k\\nelse:\\n\\tans += t - (alpha*lcm) + 1\\n\\nans -= 1\\n\\ngg = gcd(ans, t)\\nans = ans//gg\\nt = t//gg\\n\\nprint(str(ans)+\\\"/\\\"+str(t))\", \"# your code goes here\\n\\n[t, w, b] = [int(x) for x in input().split()]\\n\\ndef gcd(a, b):\\n    if (b==0):\\n        return a\\n    else:\\n        return gcd(b, a%b)\\n\\nd = w*b // gcd(w, b)\\nm = min(w, b)\\n\\ndint = t // d\\n\\ncount = m * dint\\n\\ncount += m - 1\\n    \\nd = dint * d + m - 1\\n\\nif (d > t):\\n    count -= (d - t)\\n\\ngcdtcnt = gcd(t, count)\\nt = t // gcdtcnt\\ncount = count // gcdtcnt\\n\\nprint(count, '/', t, sep='')\", \"#! /usr/bin/python\\n\\nfrom fractions import gcd\\n\\nt, w, b = list(map(int, input().split()))\\n\\nif w == b:\\n    print('1/1')\\nelse:\\n    wb = w * b // gcd(w, b)\\n    m = min(w, b)\\n    n = t // wb * m - 1 + min(t % wb + 1, m)\\n    g = gcd(n, t)\\n    print(\\\"%d/%d\\\" % (n // g, t // g))\\n\", \"t, a, b = list(map(int, input().split()))\\n\\ndef gcd(a, b):\\n    if (b == 0):\\n        return a\\n    return gcd(b, a % b)\\n\\ndef lcm(a, b):\\n    return a // gcd(a, b) * b\\n\\nl = lcm(a, b)\\nlast = t // l * l\\nans = t // l * min(a, b)\\nans += min(a, b, t - last + 1)\\nans -= 1\\ng = gcd(ans, t)\\nans //= g\\nt //= g\\nans = str(ans) + '/' + str(t)\\nprint(ans)\\n\\n\", \"def gcd(a, b):\\n    return a if b == 0 else gcd(b, a % b)\\n\\n\\nt, w, b = [int(i) for i in input().split()]\\nmi = min(w, b)\\nlcm = w * b // gcd(w, b)\\n\\np = t // lcm * mi + min(mi - 1, t % lcm)\\nq = t\\nprint(\\\"{0}/{1}\\\".format(p // gcd(p, q), q // gcd(p, q)))\", \"t, w, b = list(map(int, input().split()))\\n\\ndef gcd(x, y):\\n    while (x != 0 and y != 0):\\n        if (x < y):\\n            x, y = y, x\\n        x %= y\\n    return x + y;\\n\\nans = (t // (w * b // gcd(w, b)) - 1) * min(w, b)\\nans += min(t - (t // (w * b // gcd(w, b))) * (w * b // gcd(w, b)) + 1, min(b, w))\\nans += min(w, b) - 1;\\nprint(ans // gcd(ans, t), end = \\\"/\\\")\\nprint(t // gcd(ans, t))\", \"from fractions import gcd\\ns = list(map(int, input().split()))\\nt = s[0]\\na = s[1]\\nb = s[2]\\nnod = gcd(a, b)\\nnok = a * b // nod\\nans = t // nok * min(a, b) + min(a, b) - 1\\nans -= max(0, ((t // nok) * nok) + min(a, b) - 1 - t)\\ngc = gcd(ans, t)\\nans //= gc\\nt //= gc\\nprint(str(int(ans)) + '/' + str(int(t)))\", \"from fractions import gcd\\nt, w, b = list(map(int, input().split()))\\nif w > b:\\n    w, b = b, w\\nl = w * b // gcd(w, b)\\nc = t // l\\nans = c * w + (min((t + 1) - l * c, w)) - 1\\ng = gcd(ans, t)\\nprint('{}/{}'.format(ans // g, t // g))\\n\"]",
        "difficulty": "interview",
        "input": "314159265358979323 314159265358979167 314159265358979213\n",
        "output": "314159265358979166/314159265358979323\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/592/C",
        "input_output": "{\"inputs\": [\"314159265358979323 314159265358979167 314159265358979213\\n\"], \"outputs\": [\"314159265358979166/314159265358979323\\n\"]}",
        "generated_code": "t, w, b = map(int, input().split())\n\n# Calculate the probability that Willman and Bolt will tie\nprobability = (t - w - b) / t\n\n# Print the result as an irreducible fraction\nprint(f\"{probability:.10f}\")",
        "inout": "{\"inputs\": [\"7 1 2\\n\"], \"outputs\": [\"3/7\\n\"]}"
    },
    "643": {
        "id": 178,
        "task_id": 643,
        "test_case_id": 38,
        "question": "You are an experienced Codeforces user. Today you found out that during your activity on Codeforces you have made y submissions, out of which x have been successful. Thus, your current success rate on Codeforces is equal to x / y.\n\nYour favorite rational number in the [0;1] range is p / q. Now you wonder: what is the smallest number of submissions you have to make if you want your success rate to be p / q?\n\n\n-----Input-----\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000)\u00a0\u2014 the number of test cases.\n\nEach of the next t lines contains four integers x, y, p and q (0 \u2264 x \u2264 y \u2264 10^9; 0 \u2264 p \u2264 q \u2264 10^9; y > 0; q > 0).\n\nIt is guaranteed that p / q is an irreducible fraction.\n\nHacks. For hacks, an additional constraint of t \u2264 5 must be met.\n\n\n-----Output-----\n\nFor each test case, output a single integer equal to the smallest number of submissions you have to make if you want your success rate to be equal to your favorite rational number, or -1 if this is impossible to achieve.\n\n\n-----Example-----\nInput\n4\n3 10 1 2\n7 14 3 8\n20 70 2 7\n5 6 1 1\n\nOutput\n4\n10\n0\n-1\n\n\n\n-----Note-----\n\nIn the first example, you have to make 4 successful submissions. Your success rate will be equal to 7 / 14, or 1 / 2.\n\nIn the second example, you have to make 2 successful and 8 unsuccessful submissions. Your success rate will be equal to 9 / 24, or 3 / 8.\n\nIn the third example, there is no need to make any new submissions. Your success rate is already equal to 20 / 70, or 2 / 7.\n\nIn the fourth example, the only unsuccessful submission breaks your hopes of having the success rate equal to 1.",
        "solutions": "[\"def solve(x, y, p, q):\\n    if p == 0: return 0 if x == 0 else -1\\n    pp = (x - 1) // p + 1 if p != 0 else 0\\n    L = max((y - 1) // q + 1, pp) - 1\\n    L = max(L, -1)\\n    z = y - x\\n    INF = L + 10 ** 10\\n    R = INF\\n    while R - L > 1:\\n        M = (L + R) >> 1\\n        cur = q * M\\n        curp = p * M\\n        curz = cur - curp\\n        dl = cur - y\\n        if curp >= x and curz >= z:\\n            R = M\\n        else:\\n            L = M\\n        #print(L, R)\\n    if R == INF:\\n        return -1\\n    return R * q - y\\n\\nread = lambda: map(int, input().split())\\nt = int(input())\\nfor i in range(t):\\n    x, y, p, q = read()\\n    print(solve(x, y, p, q))\", \"def gcd(a, b):\\n    if b == 0:\\n        return a\\n    else:\\n        return gcd(b, a % b)\\n\\nclass solution:\\n    def __init__(self, a=0, b=0):\\n        self.x = a\\n        self.y = b\\n\\ndef eu (a, b, sol):\\n    if a == 0:\\n        sol.x = 0\\n        sol.y = 1\\n        return b\\n    sol2 = solution()\\n    d = eu (b%a, a, sol2)\\n    sol.x = sol2.y - (b // a) * sol2.x\\n    sol.y = sol2.x\\n    return d\\n\\n\\ndef find_any_solution (a, b, c, sol):\\n    g = eu(abs(a), abs(b), sol)\\n    if c % g != 0:\\n        return -1\\n    sol.x *= c // g\\n    sol.y *= c // g\\n    if (a < 0):\\n        sol.x *= -1\\n    if (b < 0):\\n        sol.y *= -1\\n    return g\\n\\n\\ndef shift_solution (sol, a, b, cnt):\\n    sol.x += cnt * b\\n    sol.y -= cnt * a\\n\\n\\ndef find_all_solution(a, b, c, minx, maxx, miny, maxy):\\n    sol = solution()\\n    g = find_any_solution(a, b, c, sol)\\n    if g == -1:\\n        return (-1, -1)\\n\\n    a //= g\\n    b //= g\\n\\n    sign_a = 1\\n    if a < 0:\\n        sign_a = -1\\n    sign_b = 1\\n    if b < 0:\\n        sign_b = -1\\n\\n    shift_solution(sol, a, b, (minx - sol.x) // b)\\n    if sol.x < minx:\\n        shift_solution (sol, a, b, sign_b)\\n    if sol.x > maxx:\\n        return (-1, -1)\\n    lx1 = sol.x\\n\\n    shift_solution (sol, a, b, (maxx - sol.x) // b)\\n    if sol.x > maxx:\\n        shift_solution (sol, a, b, -sign_b)\\n    rx1 = sol.x\\n\\n    shift_solution (sol, a, b, - (miny - sol.y) // a)\\n    if sol.y < miny:\\n        shift_solution (sol, a, b, -sign_a)\\n    if sol.y > maxy:\\n        return (-1, -1)\\n    lx2 = sol.x\\n\\n    shift_solution (sol, a, b, - (maxy - sol.y) // a)\\n    if sol.y > maxy:\\n        shift_solution (sol, a, b, sign_a)\\n    rx2 = sol.x\\n\\n    if lx2 > rx2:\\n        lx2, rx2 = rx2, lx2\\n    lx = max (lx1, lx2)\\n    rx = min (rx1, rx2)\\n\\n    if lx > rx:\\n        return (-1, -1)\\n    return (lx, rx)\\n\\ndef solve():\\n    s = input().split()\\n    x = int(s[0])\\n    y = int(s[1])\\n    p = int(s[2])\\n    q = int(s[3])\\n\\n    # x, y, p, q = 3, 10, 1, 2\\n \\n    if p == 0:\\n        if x == 0:\\n            return 0\\n        else:\\n            return -1\\n    if q == p:\\n        if x == y:\\n            return 0\\n        return -1\\n    if p * y - q * x == 0:\\n        return 0\\n\\n    a = q - p\\n    b = -p\\n    c = p * y - q * x\\n\\n    ans1, ans2 = find_all_solution(a, b, c, 0, int(10 ** 20), 0, int(10 ** 20))\\n\\n    ansy1 = (p * y - q * x - (q - p) * ans1) // (-p)\\n    ansy2 = (p * y - q * x - (q - p) * ans2) // (-p)\\n\\n    # print(x, y)\\n\\n    sum1 = int(10 ** 25)\\n    if ans1 >= 0 and ansy1 >= 0 and (x + ans1) * q == (y + ansy1 + ans1) * p:\\n        sum1 = min(sum1, ans1 + ansy1)\\n\\n    if ans2 >= 0 and ansy2 >= 0 and (x + ans2) * q == (y + ansy2 + ans2) * p:\\n        sum1 = min(sum1, ans2 + ansy2)\\n    if sum1 == int(10 ** 25):\\n        return -1\\n    return sum1\\n# print(solve())\\n\\nt = int(input())\\nfor i in range(t):\\n    print(solve())\", \"t = int(input())\\nfor i in range(t):\\n    x, y, p, q = map(int, input().split())\\n    \\n    if p == q:\\n        if x != y:\\n            print(-1)\\n        else:\\n            if x == y == 0:\\n                print(1)\\n            else:\\n                print(0)\\n        continue\\n    if p == 0:\\n        if x == 0:\\n            if y == 0:\\n                print(1)\\n            else:\\n                print(0)\\n        else:\\n            print(-1)\\n        continue\\n    \\n    k = max((y - x + q - p - 1) // (q - p), (x + p - 1) // p) \\n    print(k * q - y)\", \"def gcd(a, b):\\n\\tif a == 0:\\n\\t\\treturn [b, 0, 1]\\n\\td = gcd(b % a, a)\\n\\treturn [d[0], d[2] - (b // a) * d[1], d[1]]\\n\\nt = int(input())\\nwhile t > 0:\\n\\tt -= 1\\n\\tx, y, p, q = list(map(int, input().split()))\\n\\tif p == q:\\n\\t\\tif x == y:\\n\\t\\t\\tprint(0)\\n\\t\\telse:\\n\\t\\t\\tprint(-1)\\n\\t\\tcontinue\\n\\tif p == 0:\\n\\t\\tif x == 0:\\n\\t\\t\\tprint(0)\\n\\t\\telse:\\n\\t\\t\\tprint(-1)\\n\\t\\tcontinue\\n\\ta = p - q\\n\\tb = p\\n\\tc = q * x - p * y\\n\\tg, xa, ya = gcd(abs(a), abs(b))\\n\\tif c % g != 0:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\txa *= c // g\\n\\t\\tya *= c // g\\n\\t\\tif a < 0:\\n\\t\\t\\txa = -xa\\n\\t\\tif b < 0:\\n\\t\\t\\tya = -ya\\n\\t\\tif xa < 0:\\n\\t\\t\\tgaps = (-xa + (b // g) - 1) // (b // g)\\n\\t\\t\\txa += gaps * (b // g)\\n\\t\\t\\tya -= gaps * (a // g)\\n\\t\\tif ya < 0:\\n\\t\\t\\tgaps = (-ya + (-a // g) - 1) // (-a // g)\\t\\t\\n\\t\\t\\txa += gaps * (b // g)\\n\\t\\t\\tya -= gaps * (a // g)\\n\\t\\t#print(xa, ya, a, b, c)\\n\\t\\tif xa < 0 or ya < 0:\\n\\t\\t\\tprint(-1)\\n\\t\\telse:\\n\\t\\t\\taddon = min(xa // (b // g), ya // (-a // g))\\n\\t\\t\\txa -= addon * (b // g)\\n\\t\\t\\tya += addon * (a // g)\\n\\t\\t\\tprint(xa + ya)\\n\", \"import sys\\ndef de(x, y):\\n\\tif (x % y == 0):\\n\\t\\t return x // y\\n\\treturn x // y + 1\\n\\ndef euc(a, b):\\n\\tif (b == 0):\\n\\t\\treturn 1, 0\\n\\tx, y = euc(b, a % b)\\n\\treturn -y, -x - y * (a // b)\\n\\n\\n\\ndef solve( x, y, p, q):\\n\\tif (q == p):\\n\\t\\tif (x == y):\\n\\t\\t\\t return 0\\n\\t\\treturn -1\\n\\tif (p == 0):\\n\\t\\tif (x == 0):\\n\\t\\t\\t return 0\\n\\t\\treturn -1\\n\\t\\n\\t\\t\\n\\ta0, b0 = euc(p, q)\\n\\tg = a0 * p - q * b0\\n\\tc = x * q - p * y\\n\\tif (c % g):\\n\\t\\treturn -1\\n\\ta0 = a0 * (c // g)\\n\\tb0 = b0 * (c // g)\\n\\tt1 = a0 // q\\n\\t\\n\\tt = max(de(b0 - a0, q - p), de(-b0, p))\\n\\ta = a0 + q * t\\n\\tb = b0 + p * t\\n\\n\\treturn a\\n\\n\\n#sys.stdin = open('input.txt', 'r')\\n\\n\\nt = int(input())\\nfor it in range(t):\\n\\tx, y, p, q = list(map(int, input().split()))\\n\\tprint(solve(x, y, p, q))\\n\", \"def xgcd(a, b):\\n    if b == 0:\\n        return 1, 0\\n    x1, y1 = xgcd(b, a % b)\\n    return y1, x1 - (a // b) * y1\\n\\ndef gcd(a, b):\\n    if b == 0:\\n        return a\\n    return gcd(b, a % b)\\n\\nt = int(input())\\nfor kek in range(t):\\n    x, y, p, q = map(int, input().split())\\n    if p == 0:\\n        if x == 0:\\n            print(0)\\n        else:\\n            print(-1)\\n        continue\\n    if p == q:\\n        if x == y:\\n            print(0)\\n        else:\\n            print(-1)\\n        continue\\n\\n    v = p * y - q * x\\n    g = gcd(q - p, p)\\n    k0, l0 = xgcd(q - p, p)\\n    l0 *= -1\\n    g1 = v // g\\n    k0 *= g1\\n    l0 *= g1\\n\\n    xx = (-k0 + p - 1) // p\\n    \\n    xx = max(xx, (-l0 + q - p - 1) // (q - p))\\n    \\n    l = l0 + xx * (q - p)\\n    k = k0 + xx * p;\\n\\n    print(k + l)\", \"def gcd(a, b):\\n    if a == 0:\\n        return b, 0, 1\\n\\n    g, x1, y1 = gcd(b % a, a);\\n\\n    y = x1;\\n    x = y1 - (b // a) * x1;\\n    return g, x, y;\\n\\ndef comp(da, db, t, a, b):\\n    ra = a + da * t\\n    rb = b + db * t\\n\\n    # assert(ra.v0 >= 0);\\n    # assert(ra.v1 >= 0);\\n    # assert(rb.v0 >= 0);\\n    # assert(rb.v1 >= 0);\\n    return ra + rb\\n\\ndef solve():\\n    x, y, p, q = list(map(int, input().split()))\\n\\n    if p == q:\\n        if x == y:\\n            print(0)\\n        else:\\n            print(-1)\\n        return\\n\\n    if p == 0:\\n        if x == 0:\\n            print(0)\\n        else:\\n            print(-1)\\n        return;\\n\\n    r = x * q - y * p;\\n    g, a, b = gcd(p - q, p);\\n    if r % g != 0:\\n        print(-1)\\n        return\\n\\n    a *= r // g;\\n    b *= r // g;\\n\\n    da = p;\\n    db = q - p;\\n    minT = -10**18;\\n    minT = max(minT, ((-a + (da - 1)) // da));\\n    minT = max(minT, ((-b + (db - 1)) // db));\\n\\n    t = minT;\\n    rr = comp(da, db, t, a, b);\\n    print(rr)\\n\\n\\ndef main():\\n    t = int(input())\\n    for i in range(t):\\n        solve()\\n\\ndef __starting_point():\\n    main()\\n\\n\\n__starting_point()\", \"def gcd(a, b):\\n\\tif (a == 0):\\n\\t\\treturn (b, 0, 1)\\n\\n\\t(g, x, y) = gcd(b % a, a)\\n\\treturn (g, y - (b // a) * x, x) \\n\\n\\nt = int(input())\\n\\nfor i in range(t):\\n\\t(x, y, p, q) = list(map(int, input().split()))\\n\\tval = p * y - q * x\\n\\t(g, a, b) = gcd(q, -p)\\n\\n\\tif (val % g != 0):\\n\\t\\tprint(-1)\\n\\t\\tcontinue\\n\\n\\ta *= val // g\\n\\tb *= val // g\\n\\n\\tda = abs(p // g)\\n\\tdb = abs(q // g)\\n\\n\\tif (a < 0):\\n\\t\\tif (da == 0):\\n\\t\\t\\tprint(-1)\\n\\t\\t\\tcontinue\\n\\n\\t\\tmul = (abs(a) + da - 1) // da\\n\\t\\ta += mul * da\\n\\t\\tb += mul * db\\n\\n\\n\\tif (b < 0):\\n\\t\\tif (db == 0):\\n\\t\\t\\tprint(-1)\\n\\t\\t\\tcontinue\\n\\n\\t\\tmul = (abs(b) + db - 1) // db;\\n\\t\\ta += mul * da\\n\\t\\tb += mul * db\\n\\n\\tif (a > b):\\n\\t\\tif (da == db):\\n\\t\\t\\tprint(-1)\\n\\t\\t\\tcontinue\\n\\n\\t\\tdiff = a - b\\n\\t\\tstep = db - da\\n\\t\\tmul = (diff + step - 1) // step\\n\\t\\ta += mul * da\\n\\t\\tb += mul * db\\n\\n\\tmul = b // db;\\n\\tif (da != 0):\\n\\t\\tmul = min(mul, a // da)\\n\\n\\tif (da != db):\\n\\t\\tmul = min(mul, (b - a) // (db - da))\\n\\n\\tprint(b - db * mul) \\n\", \"INF = 10**40\\n\\ndef gcd_ex(A, B):\\n    if A == 0:\\n        return B, 0, 1\\n    g, a1, b1 = gcd_ex(B % A, A)\\n    a = b1 - (B // A) * a1\\n    b = a1\\n    return g, a, b\\n\\ndef round_down(a, b):\\n    s = (a < 0) != (b < 0)\\n    a = abs(a)\\n    b = abs(b)\\n    if not s:\\n        return a // b\\n    return -((a + b - 1) // b)\\n\\ndef round_up(a, b):\\n    s = (a < 0) != (b < 0)\\n    a = abs(a)\\n    b = abs(b)\\n    if not s:\\n        return (a + b - 1) // b\\n    return -(a // b)\\n\\ndef solve():\\n    x, y, p, q = list(map(int, input().split()))\\n\\n    A = q\\n    B = -p\\n    C = p * y - q * x\\n\\n    g, a0, b0 = gcd_ex(A, -B)\\n    b0 *= -1\\n\\n    if C % g != 0:\\n        print(-1)\\n        return\\n    a0 *= C // g\\n    b0 *= C // g\\n\\n    k_up1 = 0\\n    if B == 0:\\n        if -a0 > 0:\\n            print(-1)\\n            return\\n        k_up1 = INF\\n    else:\\n        k_up1 = round_down(-a0, B // g)\\n\\n    k_down2 = 0\\n    k_up2 = 0\\n    if A + B == 0:\\n        if b0 - a0 < 0:\\n            print(-1)\\n            return\\n        k_down2 = -INF\\n        k_up2 = INF\\n    elif A + B > 0:\\n        k_down2 = -INF\\n        k_up2 = round_down(b0 - a0, (A + B) // g)\\n    else:\\n        k_down2 = round_up(b0 - a0, (A + B) // g)\\n        k_up2 = INF\\n\\n    k_down = k_down2\\n    k_up = min(k_up1, k_up2)\\n    if k_down > k_up:\\n        print(-1)\\n        return\\n\\n    if k_up == INF:\\n        raise Exception\\n    b = b0 - (A // g) * k_up\\n\\n    print(b)\\n\\ndef main():\\n    t = int(input())\\n    for i in range(t):\\n        solve()\\n\\nmain()\\n\", \"t = int(input())\\n\\nfor i in range(t):\\n    x, y, p, q = [int(i) for i in input().split()]\\n    \\n    if p == 0:\\n        if x == 0:\\n            print(0)\\n        else:\\n            print(-1)\\n        continue\\n\\n    l = 0\\n    r = 10000000000\\n\\n    while l < r:\\n        t = (l + r) // 2\\n\\n        c1 = p * t - x\\n        c2 = q * t - y - c1\\n\\n        if c1 >= 0 and c2 >= 0:\\n            r = t\\n        else:\\n            l = t + 1\\n\\n    if r == 10000000000:\\n        print(-1)\\n    else:\\n        print(q * l - y)\\n\", \"def gcd(a, b):\\n    if b > a:\\n        return gcd(b, a)\\n    if b == 0:\\n        return a\\n    return gcd(b, a % b)\\n\\ndef works(a, b, c, d, x):\\n    return b <= d * x and a <= c * x and d * x - b >= c * x - a\\n\\ndef solve():\\n    a, b, c, d = list(map(int, input().rstrip().split()))\\n    if c == d == 1 and not a / b == 1:\\n        print(-1)\\n        return\\n    if c == 0 and not a == 0:\\n        print(-1)\\n        return\\n    g = gcd(c, d)\\n    c //= g\\n    d //= g\\n    low = -1\\n    high = 1000000000000\\n    while low + 1 < high:\\n        mid = (low + high) // 2\\n        if works(a, b, c, d, mid):\\n            high = mid\\n        else:\\n            low = mid\\n    print(d * high - b)\\n\\ndef __starting_point():\\n    t = int(input())\\n    for _ in range(t):\\n        solve()\\n\\n__starting_point()\", \"# cook your code here\\ndef solve():\\n    x, y, p, q = map(int, input().split())\\n    \\n    if p == 0:\\n        if x == 0:\\n            print(0)\\n            return\\n        else:\\n            print(-1)\\n            return\\n        \\n    if p == q:\\n        if x == y:\\n            print(0)\\n            return\\n        else:\\n            print(-1)\\n            return\\n        \\n    var1 = ( p + x - 1 ) // p;\\n    var2 = ((y - x) + (q - p) - 1) // (q - p);\\n    max1 = max(var1, var2);\\n    solution = (max1 * q) - y;\\n    \\n    print(solution)\\n    return\\n\\n\\ndef main():\\n    n = int(input())\\n    for i in range (n):\\n        solve()\\n        \\nmain()\", \"for i in range(int(input())):\\n    x, y, p, q = map(int, input().split())\\n    print(-(x > 0) if not p else -(y > x) if p == q else max((x - 1) // p, (y - x - 1) // (q - p)) * q + q - y)\", \"import math\\nimport sys\\nt=int(input())\\nfor j in range(1,(t+1)):\\n    x,y,p,q=(list(map(int,input().split())))\\n    f1=0\\n    if(p!=q and p!=0):\\n            tmp=max(((y-x)+(q-p)-1)//(q-p),(x+p-1)//p)\\n            #print(tmp)\\n            #include<FU*k> test case\\n            print((q*tmp)-y)\\n            f1=1\\n           \\n    if(p==0 and x==0):\\n            print(0)\\n    elif(p==q and x==y):\\n            print(0)\\n    elif (not f1):\\n            print(-1)\\n        \\n        \\n\\n\\n    \\n\", \"for case in range(int(input())):\\n    x,y,p,q = map(int, input().split())\\n\\n    lo = 0\\n    hi = 10**10\\n    while lo < hi:\\n        mid = lo + (hi - lo) // 2\\n         \\n        np,nq = mid*p, mid*q\\n        if nq >= y and np >= x:\\n            if nq - y >= np - x:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        else:\\n            lo = mid + 1\\n     \\n    print(lo * q - y if lo != 10**10 else -1)\", \"for _ in range(int(input())):\\n\\n  x,y,p,q=list(map(int,input().split()))\\n\\n  l,r,res=0,10**18,-1\\n\\n  while l<=r:\\n\\n    mid=(l+r)//2\\n\\n    a,b=p*mid-x,q*mid-y\\n\\n    if a<=b and a>-1 and b>-1:res=b;r=mid-1\\n\\n    else :l=mid+1\\n\\n  print(res)\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"R = lambda: map(int, input().split())\\nmx = 10**9 + 7\\nt = int(input())\\nfor i in range(t):\\n    a, b, p, q = R()\\n    l, r = 1, mx\\n    while l < r:\\n        k = (l + r) // 2\\n        x, y = k * p - a, k * q - b\\n        if 0 <= x <= y and y >= 0:\\n            r = k\\n        else:\\n            l = k + 1\\n    if r >= mx:\\n        print(\\\"-1\\\")\\n    else:\\n        print(r * q - b)\", \"N = int(input())\\nimport math\\nfor _ in range(N):\\n    x,y,p,q = [int(x) for x in input().split()]\\n    if (p == 0) or (p==q):\\n        if (x*q == p*y):\\n            print(0)\\n        else:\\n            print(-1)\\n        continue\\n    n = math.ceil((y-x)/(q-p))\\n    n = max(n,math.ceil(x/p))\\n    n = max(n,math.ceil(y/q))\\n    print(n*q-y)\\n\", \"import math\\nfor _ in range(int(input())):\\n    x,y,p,q = [int(x) for x in input().split()]\\n    print(math.ceil(max((y-x)/(q-p),x/p,y/q))*q-y) if p%q else print(0) if (x*q == p*y) else print(-1)\\n\", \"#https://codeforces.com/problemset/problem/773/A\\n\\nt = int(input())\\nfor i in range(t):\\n    x, y, p, q = list(map(int, input().split()))\\n    left = -1\\n    right = 10**9\\n    r = right\\n    while left + 1 < right:\\n        t = (left + right) // 2\\n        if p*t >= x and q*t - p*t >= y - x:\\n            right = t\\n        else:\\n            left = t\\n    if not (p*r >= x and q*r - p*r >= y - x):\\n        print(-1)\\n    else:\\n        print(q*right - y)\\n    \\n\", \"from math import ceil\\nfor _ in range(int(input())):\\n    x, y, p, q = list(map(int, input().split()))\\n    if p == q and x != y:\\n        print(-1)\\n    elif p == q:\\n        print(0)\\n    elif p == 0 and x == 0:\\n        print(0)\\n    elif p == 0:\\n        print(-1)\\n    else:\\n        a = y // q\\n        r = y % q\\n        g1 = (x - p * a + p - 1) // p\\n        g2 = ceil((x - r - p * a) / (p - q))\\n        print(max(g1, g2) * q - r)\\n\", \"import math\\nfor _ in range(int(input())):\\n    x, y, p, q = list(map(int,input().split()))\\n    if p == 0 or  p == q :\\n        print(0 if  x * q == p * y else  -1 )\\n        continue    \\n    n = math.ceil((y - x) / (q - p) )\\n    n = max(n, math.ceil(x / p))\\n    n = max(n, math.ceil(y / q))\\n    print(n * q - y )\\n\", \"T = int(input())\\n\\nfor t in range(T):\\n  x, y, p, q = map(int, input().split())\\n  if p == q and x != y:\\n      print(-1)\\n      continue\\n\\n  INF = 10000000000\\n  lb = -1\\n  ub = INF\\n  mod_y = (q - y % q) % q\\n\\n  while ub - lb > 1:\\n    mid = (ub + lb) // 2\\n    diff = mod_y + q * mid\\n    bunbo = y + diff\\n    bunshi = p * bunbo // q\\n    if bunshi >= x and bunshi - x <= diff:\\n      ub = mid\\n    else:\\n      lb = mid\\n  if ub == INF:\\n    print(-1)\\n  else:\\n    print(mod_y + q * ub)\", \"def chec(a,b,p,q,mid):\\n    if p*r>=a and (q-p)*mid>=b-a:\\n        return True\\n    else:\\n        return False\\ndef check(np, nq):\\n  return np >= a and nq >= b and (np - a <= nq - b)    \\nfor _ in range(int(input())):\\n    a,b,p,q = list(map(int,input().split()))\\n    l=0\\n    r=10000000000\\n    if check(p*r,q*r)==False:\\n        print(-1)\\n        continue\\n    while l<=r:\\n        mid = l +(r-l)//2\\n        if check(p*mid,q*mid):\\n            r=mid-1\\n        else:\\n            l=mid+1\\n    print(l*q-b)\\n\", \"def div(a, b):\\n\\treturn (a+b-1)//b\\n\\nfor t in range(int(input())):\\n\\tx,y,p,q = map(int,input().split())\\n\\tif q == 1:\\n\\t\\tif p == 0 and x == 0 or p == 1 and x == y:\\n\\t\\t\\tprint(0)\\n\\t\\telse:\\n\\t\\t\\tprint(-1)\\n\\telse:\\n\\t\\tz = max(max(div(x,p),div(y,q)),max(div(y-x,q-p),0))\\n\\t\\tprint(z*q-y)\"]",
        "difficulty": "interview",
        "input": "4\n1 1000000000 999999999 1000000000\n1 1000000000 999999999 1000000000\n1 1000000000 999999999 1000000000\n1 1000000000 999999999 1000000000\n",
        "output": "999999998000000000\n999999998000000000\n999999998000000000\n999999998000000000\n",
        "halu_type": "Identification Hallucination",
        "fn_name": null,
        "starter_code": "",
        "url": "https://codeforces.com/problemset/problem/773/A",
        "input_output": "{\"inputs\": [\"4\\n1 1000000000 999999999 1000000000\\n1 1000000000 999999999 1000000000\\n1 1000000000 999999999 1000000000\\n1 1000000000 999999999 1000000000\\n\"], \"outputs\": [\"999999998000000000\\n999999998000000000\\n999999998000000000\\n999999998000000000\\n\"]}",
        "generated_code": "t = int(input())\n\nfor i in range(t):\n    x, y, p, q = map(int, input().split())\n    if p / q == 0:\n        print(-1)\n    else:\n        num_submissions = (y - x) // (p / q)\n        print(num_submissions)",
        "inout": "{\"inputs\": [\"8\\n0 1 0 1\\n0 2 1 2\\n0 3 1 1\\n1 2 0 1\\n1 2 1 1\\n2 2 0 1\\n3 3 1 2\\n4 4 1 1\\n\"], \"outputs\": [\"0\\n2\\n-1\\n-1\\n-1\\n-1\\n3\\n0\\n\"]}"
    }
}